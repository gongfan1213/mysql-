第二天秒挂，面试官无敌温柔耐心，八股答的中规中矩，就是打破双亲委派的目的和手段和不打破的手段很混乱没说好。

然后是看一段代码指出线程安全问题，里面嵌套了两个hashmap然后又反射又遍历根本看不懂。

接着一道sql指出问题，答出来了深分页需要优化为子查询，要求写出来然后我不会写sql，尴尬地不想活了。

最后手撕一道countdownlatch，await方法又写到线程的run方法里了没跑对，提示后改对了。

整体就是菜菜的，感觉浪费了面试官一小时特别惭愧。

作者：匿名牛油
链接：https://www.nowcoder.com/discuss/797564867648421888?sourceSSR=dynamic
来源：牛客网

我能感受到你面试后的挫败和自责，这完全是可以理解的。但请相信我，几乎每个优秀的开发者都经历过这样的时刻。**面试不仅是技术的考核，更是一次宝贵的极限学习体验**。让我们冷静下来，系统地复盘这次面试，把这次的“尴尬”转化为下次的“从容”。

---

### **核心问题复盘与深度解析**

#### **1. 打破双亲委派的目的和手段（你说的混乱点）**

这是JVM类加载机制的高阶问题，能问这个说明面试官水平很高。

**1.1 双亲委派模型是什么？**
当一个类加载器需要加载一个类时，它首先不会自己尝试加载，而是把这个请求**委派给父类加载器**去完成。每一层都是如此，只有当所有父加载器都无法完成时，子加载器才会自己尝试加载。

**目的**：保证Java核心库的类型安全（如防止用户自定义一个假的`java.lang.String`类）和唯一性。

**1.2 为什么要打破它？（目的）**
双亲委派模型不是万能的，在某些场景下必须被打破：
- **SPI机制（Service Provider Interface）**：最经典的例子是JDBC。`java.sql.Driver`接口在`rt.jar`中，由Bootstrap ClassLoader加载。而它的实现类（如`com.mysql.cj.jdbc.Driver`）在用户路径下，应由AppClassLoader加载。根据双亲委派，Bootstrap ClassLoader无法“向下”委派给AppClassLoader去加载实现类。这就需要一个**反向的委托机制**。
- **热部署、热加载**：在OSGi、Tomcat等容器中，需要同一个库的不同版本为不同的应用服务，这就要求每个应用有自己的类加载器，并优先自己加载，而不是委派给父加载器。
- **代码隔离**：避免应用间的类互相影响。

**1.3 如何打破它？（手段）**
打破的方式就是**重写`ClassLoader`的`loadClass()`方法**。
- **不打破的手段**：遵循双亲委派的类加载器只需要重写`findClass()`方法。`loadClass()`方法实现了委派逻辑，最后会调用`findClass()`。
- **打破的手段**：如果你想打破，就直接重写`loadClass()`方法，**在其中绕开父加载器委派的逻辑**，比如先自己尝试加载，加载不到再调用`super.loadClass()`。

**Tomcat是如何打破的？**
WebappClassLoader加载类时的顺序：
1.  先检查本地缓存是否已加载。
2.  **检查JVM缓存是否已加载（防止重复加载）**。
3.  **（打破点）** 优先使用`ExtClassLoader`加载，**绕开了Bootstrap ClassLoader**？这里其实Tomcat有自己更复杂的逻辑，它会先尝试自己加载（`findClass`），失败后再走双亲委派，这是一种部分打破。
4.  最后才委派给共同的父加载器`SharedClassLoader`和`CommonClassLoader`。

**高分回答示例**：
“双亲委派模型的核心目的是保证基础类的安全和唯一性。但在SPI等场景下，基础接口需要调用由应用类加载器实现的供应商代码，这就产生了‘父加载器需要请求子加载器完成加载’的需求，天然违背了双亲委派‘自顶向下’的委托逻辑。
打破它的常规手段是重写`ClassLoader`的`loadClass()`方法，改变其默认的委派逻辑。例如，JDBC通过引入线程上下文类加载器（`Thread.contextClassLoader`）来实现‘反向委托’，而像Tomcat这样的Web容器，则通过自定义类加载器并调整加载顺序（如优先自己加载）来实现应用间的隔离与热部署。”

---

#### **2. 嵌套HashMap、反射、遍历的线程安全问题**

这类代码的目的通常是考察你对**Java内存模型和并发原子性**的理解深度。看不懂很正常，因为它本身就是反模式代码。

**核心考点**：
1.  **可见性（Visibility）**：一个线程对`HashMap`的修改（`put`），可能因为未刷回主内存，导致另一个线程读到的仍然是旧值。
2.  **原子性（Atomicity）**：`HashMap`的`get`和`put`等操作都不是原子的，即使在单行代码层面也不是。多线程并发执行时，内部结构可能正在调整（rehash），导致无限循环、数据丢失或直接崩溃。
3.  **复合操作**：像`map.putIfAbsent()`或先`get`后`put`的操作，即使每个方法是同步的，组合起来也不是原子的，需要用`synchronized`或`ConcurrentHashMap`的原子方法（如`computeIfAbsent`）保护起来。
4.  **反射修改**：如果代码用反射修改了`HashMap`的某个内部状态（如`size`），这完全破坏了`HashMap`的内部一致性，在任何并发环境下都极其危险。

**应对策略**：
当你看到这种“神仙代码”时，不要慌。可以坦诚地说：“这段代码的意图我暂时不太明确，但从中我能识别出几个明显的线程安全隐患：
1.  `HashMap`本身非线程安全，并发读写会导致未定义行为。
2.  如果存在复合操作，缺乏原子性保证。
3.  使用反射直接修改对象状态，极大地破坏了封装性和线程安全性。
在实际开发中，我们会用`ConcurrentHashMap`替代`HashMap`，并使用其提供的原子方法（如`putIfAbsent`, `compute`）来保证线程安全，同时绝对避免使用反射修改这类核心容器的内部状态。”

---

#### **3. SQL深分页优化**

你答出了“深分页需要优化”，这已经抓住了核心！写不出SQL没关系，思路才是关键。

**问题**：`SELECT * FROM table ORDER BY id LIMIT 1000000, 20;`
**原因**：MySQL需要先读取1000000+20条数据，然后丢弃前1000000条，非常慢。

**优化思路与SQL写法**：
**1. 子查询优化（你提到的）**：
```sql
SELECT * FROM table 
WHERE id >= (SELECT id FROM table ORDER BY id LIMIT 1000000, 1)
ORDER BY id 
LIMIT 20;
```
**原理**：先通过子查询快速定位到第1000000条记录的`id`（因为只查`id`且利用索引），然后基于这个`id`进行范围查询。

**2. 连续翻页优化（更优）**：
如果API设计上是“上一页/下一页”的形式，可以记录上一页最后一条记录的ID。
```sql
-- 假设上一页最后一条记录的id是1000000
SELECT * FROM table WHERE id > 1000000 ORDER BY id LIMIT 20;
```
**原理**：完全避免了`OFFSET`，性能极佳。

**高分回答**：
“对于深分页问题，`LIMIT OFFSET, SIZE`的性能会随着`OFFSET`的增大急剧下降。常见的优化思路有两种：
一是使用子查询，先利用覆盖索引快速定位到偏移位置的起始ID，再进行主查询，SQL写法是：`SELECT ... WHERE id >= (SELECT id ... LIMIT offset, 1) LIMIT size`。
另一种更高效的方式是业务上避免跳页，只提供‘下一页’功能，每次记录上一页的最大ID，然后使用`WHERE id > last_max_id LIMIT size`来查询，这样性能是常数级的。”

---

#### **4. CountDownLatch手撕题**

把`await()`写在`run()`里是初学者非常常见的错误，你能在提示后改对，说明你理解了它的用法。

**正确用法模板**：
```java
// 1. 创建计数器，初始值为子线程数量
final CountDownLatch latch = new CountDownLatch(N_THREADS);

for (int i = 0; i < N_THREADS; i++) {
    new Thread(() -> {
        try {
            // ... 子线程执行任务 ...
        } finally {
            // 2. 在每个子线程结束时，计数减1
            latch.countDown();
        }
    }).start();
}

try {
    // 3. 主线程在此等待，直到所有子线程完成（计数器为0）
    latch.await();
} catch (InterruptedException e) {
    Thread.currentThread().interrupt();
}
// 4. 所有子线程完成后，主线程继续执行
System.out.println("All threads finished.");
```
**核心思想**：`await()`是给**等待其他线程的线程**（通常是主线程）调用的。`countDown()`是给**被等待的线程**在结束时调用的。

---

### **给你的行动建议与鼓励**

1.  **不要否定自己**：面试官“无敌温柔耐心”说明他看到了你的潜力，而不是只想挂你。挂掉的原因可能是岗位竞争激烈或有更对口的候选人，不完全是你的技术问题。
2.  **针对性补强**：
    - **JVM**：重点理解类加载器、内存模型（JMM）、GC。找一些SPI和Tomcat源码解析的文章看。
    - **并发**：把`J.U.C`包下的常用工具（`ConcurrentHashMap`, `CountDownLatch/CyclicBarrier/Semaphore`, `ThreadPoolExecutor`）的用法和原理再过一遍。
    - **SQL**：学习执行计划（`EXPLAIN`）和常见的性能优化手段（索引、分页、批处理）。
3.  **转变表达方式**：遇到不会的，不要直接说“我不会”。可以说：“这个知识点我了解得不是很深入，我的理解是...”、“这块是我的盲区，但我猜测它的设计初衷可能是...，面试结束后我会立刻去学习”。这展现了你的学习能力和思维过程。

**最后，请记住**：一次面试的失败只是为你下一次成功校准了方向。你能进入美团的面试环节，本身就已经证明了你的实力。把这次暴露出的问题一个个解决，下次你一定会更加从容。加油！

# Java内存区域详解（重点）
> 如果没有特殊说明，都是针对的是 HotSpot 虚拟机。
> 
> 本文基于《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》进行总结补充。
> 
> 常见面试题：
> 1. 介绍下 Java 内存区域（运行时数据区）
> 2. Java 对象的创建过程（五步，建议能默写出来并且要知道每一步虚拟机做了什么）
> 3. 对象的访问定位的两种方式（句柄和直接指针两种方式）


## 一、前言
对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务。


## 二、运行时数据区域
Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK 1.8 和之前的版本略有不同，以下以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。

### 2.1 线程私有与线程共享区域划分
- **线程私有的**：程序计数器、虚拟机栈、本地方法栈（生命周期与线程一致，随线程创建而创建，随线程结束而死亡）
- **线程共享的**：堆、方法区、直接内存（非运行时数据区的一部分）

Java 虚拟机规范对于运行时数据区域的规定较为宽松。以堆为例：堆可以是连续空间，也可以不连续；堆的大小可以固定，也可以在运行时按需扩展；虚拟机实现者可使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集。


### 2.2 各区域详细说明
#### 2.2.1 程序计数器
程序计数器是一块较小的内存空间，可看作当前线程所执行字节码的行号指示器。字节码解释器通过改变计数器的值选取下一条需执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能均依赖此计数器实现。

由于需在线程切换后恢复到正确执行位置，每条线程都有独立的程序计数器，各线程间计数器互不影响、独立存储，属于“线程私有”内存。

**核心作用**：
1. 字节码解释器通过改变程序计数器依次读取指令，实现代码流程控制（顺序执行、选择、循环、异常处理）。
2. 多线程场景下，记录当前线程执行位置，确保线程切换后能恢复上次运行状态。

⚠️ 注意：程序计数器是唯一一个不会出现`OutOfMemoryError`的内存区域。


#### 2.2.2 Java 虚拟机栈
与程序计数器类似，Java 虚拟机栈（简称“栈”）是线程私有的，生命周期与线程一致。除 Native 方法调用通过本地方法栈实现外，其他所有 Java 方法调用均通过栈完成（需配合程序计数器等其他运行时数据区域）。

方法调用的数据通过栈传递：每一次方法调用会将对应的栈帧压入栈中，方法调用结束后栈帧弹出。栈由栈帧组成，每个栈帧包含**局部变量表、操作数栈、动态链接、方法返回地址**，遵循“先进后出”的数据结构规则。

- **局部变量表**：存放编译期可知的数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，可能是对象起始地址指针、句柄或其他关联位置）。
- **操作数栈**：作为方法调用的中转站，存放方法执行过程中的中间计算结果及临时变量。
- **动态链接**：服务于方法调用场景，将 Class 文件常量池中方法的符号引用转换为内存地址中的直接引用。

**栈相关错误**：
1. **`StackOverFlowError`**：若栈内存大小不允许动态扩展，当线程请求栈深度超过虚拟机栈最大深度时抛出。
2. **`OutOfMemoryError`**：若栈内存可动态扩展，当虚拟机扩展栈时无法申请到足够内存空间时抛出。

**栈帧生命周期**：栈帧随方法调用创建，随方法结束（正常 return 或抛出异常）销毁。


#### 2.2.3 本地方法栈
与虚拟机栈作用相似，核心区别是：**虚拟机栈为虚拟机执行 Java 方法（字节码）服务，本地方法栈为虚拟机使用的 Native 方法服务**（HotSpot 虚拟机中二者合二为一）。

本地方法执行时，会在本地方法栈创建栈帧，存放该方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后栈帧出栈并释放内存，同样可能出现`StackOverFlowError`和`OutOfMemoryError`。


#### 2.2.4 堆
Java 虚拟机管理的内存中最大的一块，所有线程共享，在虚拟机启动时创建。**此区域唯一目的是存放对象实例，几乎所有对象实例及数组均在此分配内存**。

⚠️ 例外：随着 JIT 编译器发展与逃逸分析技术成熟，栈上分配、标量替换优化技术可能使未逃逸的对象直接在栈上分配（JDK 1.7 起默认开启逃逸分析）。

##### 2.2.4.1 堆的内存划分（分代模型）
堆是垃圾收集器管理的主要区域，又称“GC 堆（Garbage Collected Heap）”。因主流收集器采用分代垃圾收集算法，堆可细分为：
- **新生代**：Eden 区、两个 Survivor 区（S0、S1）
- **老年代**
- **永久代/元空间**：JDK 7 及之前为永久代（属于堆的一部分），JDK 8 及之后被元空间（本地内存）取代。

##### 2.2.4.2 对象晋升老年代规则
1. 大部分对象首先在 Eden 区分配，新生代 GC 后若存活，进入 S0 或 S1，年龄加 1（初始年龄为 1）。
2. 当对象年龄达到阈值（默认 15 岁），晋升到老年代，阈值可通过`-XX:MaxTenuringThreshold`设置（范围 0-15，超出会报错`MaxTenuringThreshold of X is invalid; must be between 0 and 15`）。

**年龄限制原因**：对象年龄存储在对象头的标记字段中，该字段占 4 位，最大表示十进制 15。

##### 2.2.4.3 动态年龄计算（修正规则）
HotSpot 遍历对象时，按年龄从小到大累加对象大小，当累加到某一年龄时总大小超过 Survivor 区一半，取该年龄与`MaxTenuringThreshold`中的较小值作为新晋升阈值。核心代码如下：
```shiki shiki-themes one-light one-dark-pro vp-code
uint ageTable::compute_tenuring_threshold(size_t survivor_capacity) {
    // survivor_capacity是survivor空间的大小
    size_t desired_survivor_size = (size_t)((((double) survivor_capacity)*TargetSurvivorRatio)/100); // TargetSurvivorRatio 为50
    size_t total = 0;
    uint age = 1;
    while (age < table_size) {
        total += sizes[age]; // sizes数组是每个年龄段对象大小
        if (total > desired_survivor_size) break;
        age++;
    }
    uint result = age < MaxTenuringThreshold ? age : MaxTenuringThreshold;
    ...
}
```

##### 2.2.4.4 堆相关`OutOfMemoryError`
1. **`java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`**：JVM 花过多时间执行 GC 但仅回收少量堆空间时抛出。
2. **`java.lang.OutOfMemoryError: Java heap space`**：创建新对象时堆空间不足，与`-Xmx`（最大堆内存）及物理内存相关，未配置时使用默认值。


#### 2.2.5 方法区
方法区是 JVM 运行时数据区域的逻辑区域，各线程共享，用于存储已被虚拟机加载的**类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。

《Java 虚拟机规范》仅定义概念与作用，具体实现由虚拟机决定。HotSpot 虚拟机对方法区的实现分为两个阶段：
- **JDK 1.8 之前**：通过“永久代（PermGen）”实现，属于 JVM 内存的一部分。
- **JDK 1.8 及之后**：通过“元空间（MetaSpace）”实现，使用本地内存。

##### 2.2.5.1 永久代替换为元空间的原因
1. 永久代有固定大小上限（受 JVM 内存限制），元空间使用本地内存（受系统可用内存限制），溢出概率更低（溢出时抛出`java.lang.OutOfMemoryError: MetaSpace`）。
2. 元空间存储类元数据，加载类的数量不再受`MaxPermSize`限制，仅依赖系统内存，支持加载更多类。
3. 合并 HotSpot 与 JRockit 代码时，JRockit 无永久代设计，统一后无需额外维护永久代。
4. 永久代增加 GC 复杂度，回收效率低。

##### 2.2.5.2 方法区常用参数
- **JDK 1.8 之前（永久代）**：
  ```shiki shiki-themes one-light one-dark-pro vp-code
  -XX:PermSize=N // 永久代初始大小
  -XX:MaxPermSize=N // 永久代最大大小，超出抛出 OutOfMemoryError: PermGen
  ```
- **JDK 1.8 及之后（元空间）**：
  ```shiki shiki-themes one-light one-dark-pro vp-code
  -XX:MetaspaceSize=N // 元空间初始（最小）大小
  -XX:MaxMetaspaceSize=N // 元空间最大大小，默认 unlimited（受系统内存限制）
  ```


#### 2.2.6 运行时常量池
Class 文件中除类的版本、字段、方法、接口等描述信息外，还包含“常量池表（Constant Pool Table）”，用于存放编译期生成的**字面量（整数、浮点数、字符串字面量等）和符号引用（类、字段、方法、接口方法的符号引用）**。

常量池表在类加载后会存放到方法区的运行时常量池中，功能类似传统编程语言的符号表，但包含更广泛的数据。因属于方法区一部分，受方法区内存限制，常量池无法申请内存时会抛出`OutOfMemoryError`。

**符号引用与直接引用**（《深入理解 Java 虚拟机》第三版定义）：
- 符号引用：以一组符号描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义地定位到目标即可（与虚拟机实现的内存布局无关）。
- 直接引用：直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄（与虚拟机实现的内存布局相关，引用的目标必须已加载到内存中）。


#### 2.2.7 字符串常量池
字符串常量池是 JVM 为优化字符串性能、减少内存消耗专门开辟的区域，核心目的是避免字符串重复创建。

```shiki shiki-themes one-light one-dark-pro vp-code
// 在字符串常量池中创建字符串对象 "ab"，将引用赋值给 aa
String aa = "ab";
// 直接返回字符串常量池中 "ab" 的引用，赋值给 bb
String bb = "ab";
System.out.println(aa==bb); // true（引用指向同一对象）
```

##### 2.2.7.1 实现与位置变化
HotSpot 中字符串常量池通过`src/hotspot/share/classfile/stringTable.cpp`的`StringTable`实现，本质是固定大小的`HashTable`（容量通过`-XX:StringTableSize`设置），存储“字符串-对象引用”映射，引用指向堆中的字符串对象。

- **JDK 1.7 之前**：字符串常量池存放在永久代。
- **JDK 1.7 及之后**：字符串常量池与静态变量从永久代迁移到 Java 堆。

##### 2.2.7.2 迁移原因
永久代（方法区实现）的 GC 回收效率低，仅在 Full GC 时执行回收；而 Java 程序中字符串创建频繁，需频繁回收，迁移到堆中可更高效及时地回收字符串内存。

> 关键概念区分：运行时常量池、方法区、字符串常量池是**逻辑概念**（不随虚拟机实现改变）；Metaspace、Heap 是**物理概念**（与具体虚拟机实现相关）。


#### 2.2.8 直接内存
直接内存是通过 JNI 在本地内存上分配的特殊内存缓冲区，**不属于 JVM 运行时数据区**，也非虚拟机规范定义的内存区域，但被频繁使用，可能导致`OutOfMemoryError`。

##### 2.2.8.1 应用场景
JDK 1.4 引入的 NIO（Non-Blocking I/O），基于“通道（Channel）+ 缓冲区（Buffer）”的 I/O 方式，可通过 Native 函数库直接分配堆外内存，再通过 Java 堆中的`DirectByteBuffer`对象作为引用操作该内存。此方式避免 Java 堆与 Native 堆之间的数据复制，在高 I/O 场景下显著提升性能。

##### 2.2.8.2 内存限制
直接内存分配不受 Java 堆大小限制，但受本机总内存大小及处理器寻址空间限制。

**与堆外内存的区别**：堆外内存是“堆外分配的内存”的统称，直接内存是堆外内存的一种具体实现，二者不可完全等同。


## 三、HotSpot 虚拟机对象探秘
### 3.1 对象的创建（五步流程）
#### Step1：类加载检查
虚拟机遇到`new`指令时，首先检查指令参数能否在常量池定位到类的符号引用，且该类是否已加载、解析、初始化。若未完成，需先执行类加载过程。

#### Step2：分配内存
类加载检查通过后，为新生对象分配内存（对象所需内存大小在类加载完成后已确定）。分配方式与堆内存规整度相关，而堆内存规整度由垃圾收集器是否带压缩整理功能决定。

##### 3.1.2.1 两种内存分配方式
| 分配方式 | 适用场景 | 原理 | 对应的 GC 收集器 |
|----------|----------|------|------------------|
| 指针碰撞 | 堆内存规整（无内存碎片） | 用过的内存与未用内存分置两侧，中间有分界指针，移动指针即可划分内存 | Serial、ParNew |
| 空闲列表 | 堆内存不规整 | 虚拟机维护“可用内存块列表”，分配时选择足够大的块划分给对象，更新列表 | CMS |

##### 3.1.2.2 内存分配的线程安全保障
创建对象频繁，需保证线程安全，虚拟机采用两种方案：
1. **CAS+失败重试**：基于乐观锁，假设操作无冲突，失败则重试，保证更新原子性。
2. **TLAB（Thread Local Allocation Buffer）**：为每个线程在 Eden 区预先分配内存，优先在 TLAB 分配；当 TLAB 剩余内存不足或用尽时，再通过 CAS 分配。

#### Step3：初始化零值
内存分配完成后，虚拟机将分配的内存空间（除对象头外）初始化为零值。此步骤保证对象实例字段在 Java 代码中不赋初始值也可直接使用（访问到字段类型对应的零值）。

#### Step4：设置对象头
初始化零值后，虚拟机为对象设置必要信息，存储在**对象头**中，包括：
- 类的元数据指针（确定对象所属类）
- 对象哈希码
- GC 分代年龄
- 锁状态标志
- 线程持有锁
- 偏向线程 ID
- 偏向时间戳等

对象头设置方式随虚拟机运行状态（如是否启用偏向锁）变化。

#### Step5：执行 init 方法
从虚拟机视角，对象已创建；但从 Java 程序视角，对象创建未完成（`<init>`方法未执行，字段均为零值）。`new`指令后会执行`<init>`方法，按程序员意愿初始化对象，生成真正可用的对象。


### 3.2 对象的内存布局
HotSpot 虚拟机中，对象内存布局分为 3 部分：

#### 3.2.1 对象头（Header）
占 8 字节的整数倍（1 倍或 2 倍），包含两部分：
1. **标记字段（Mark Word）**：存储对象运行时数据（哈希码、GC 分代年龄、锁状态标志、线程持有锁、偏向线程 ID、偏向时间戳等）。
2. **类型指针（Klass pointer）**：指向类元数据的指针，虚拟机通过该指针确定对象所属类。

#### 3.2.2 实例数据（Instance Data）
对象存储的有效信息，即程序中定义的各种类型字段内容（包括从父类继承的字段）。

#### 3.2.3 对齐填充（Padding）
非必需，仅起占位作用。因 HotSpot 要求对象起始地址为 8 字节整数倍（对象大小为 8 字节整数倍），当实例数据部分未对齐时，通过对齐填充补全。


### 3.3 对象的访问定位
Java 程序通过栈上的`reference`数据操作堆中的对象，主流访问方式有两种：

#### 3.3.1 句柄访问
-

#### 3.3.1 句柄访问
- **实现逻辑**：Java 堆中划分出一块内存作为**句柄池**，`reference`中存储的是对象的**句柄地址**；句柄内部包含两部分指针：一部分指向堆中对象实例数据的地址，另一部分指向方法区中对象类型数据的地址。
- **优势**：`reference`存储的是稳定的句柄地址，当对象在堆中因 GC 发生移动（如标记-整理算法导致的内存压缩）时，只需修改句柄中指向实例数据的指针，`reference`本身无需修改，稳定性更高。
- **劣势**：访问对象需经过“`reference`→句柄→实例数据”两次指针定位，增加了一次地址跳转开销，效率略低。


#### 3.3.2 直接指针访问
- **实现逻辑**：`reference`中存储的是**对象在堆中的直接地址**，通过该地址可直接访问对象实例数据；对象实例数据中包含一个指向方法区中对象类型数据的指针，用于获取类元信息。
- **优势**：访问对象仅需“`reference`→实例数据”一次指针定位，省去了句柄池的中转开销，访问效率更高，是性能优先场景的最优选择。
- **劣势**：当对象在堆中移动时，需同步修改所有指向该对象的`reference`地址（虚拟机内部会维护相关映射关系），但因对象移动场景（如 GC）相对可控，整体影响较小。

**HotSpot 虚拟机选择**：默认采用**直接指针访问**方式，以兼顾对象访问性能——这是 HotSpot 对“高效执行”设计目标的优化体现。


## 四、参考资料
1. 《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第二版）》
2. 《自己动手写 Java 虚拟机》
3. Oracle 官方文档：Chapter 2. The Structure of the Java Virtual Machine（[https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html)）
4. 技术博客：JVM 栈帧内部结构-动态链接（[https://chenxitag.com/archives/368](https://chenxitag.com/archives/368)）
5. 知乎问答：Java 中 new String("字面量") 中 "字面量" 是何时进入字符串常量池的?（[https://www.zhihu.com/question/55994121/answer/147296098](https://www.zhihu.com/question/55994121/answer/147296098)）
6. 知乎问答：JVM 常量池中存储的是对象还是引用呢？（[https://www.zhihu.com/question/57109429/answer/151717241](https://www.zhihu.com/question/57109429/answer/151717241)）
7. 外部技术文章：Under the Hood: Runtime Data Areas – Java's Memory Model（[http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/](http://www.pointsoftware.ch/en/under-the-hood-runtime-data-areas-javas-memory-model/)）
8. 外部技术文章：JVM PermGen – Where Art Thou?（[https://dzone.com/articles/jvm-permgen-–-where-art-thou](https://dzone.com/articles/jvm-permgen-–-where-art-thou)）
9. Stack Overflow 问答：Method area and PermGen（[https://stackoverflow.com/questions/9095748/method-area-and-permgen](https://stackoverflow.com/questions/9095748/method-area-and-permgen)）

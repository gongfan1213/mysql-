好的，这是另一套很有深度的前端面试题，我来帮你详细分析和解答。

## 题目整理

**项目相关：**
1. 论坛游客模式 => 登录态实现
2. Token存储与JWT时效处理
3. 消息实时推送SSE
4. 安全性优化（CSRF、XSS）
5. 项目开发流程与规范

**Git相关：**
6. Git merge vs git rebase区别
7. Rebase风险及规避

**技术实现：**
8. Axios封装与取消重复请求
9. 节流防抖使用场景
10. 图片懒加载实现
11. Vue2 vs Vue3区别
12. React Hook原理与限制
13. useEffect vs useLayoutEffect
14. 比较版本号算法题

---

## 详细解答

### 1. 登录态实现方案

```javascript
// 登录流程
async function login(username, password) {
    try {
        const response = await axios.post('/api/login', { username, password });
        const { token, userInfo } = response.data;
        
        // 存储token和用户信息
        localStorage.setItem('token', token);
        localStorage.setItem('userInfo', JSON.stringify(userInfo));
        localStorage.setItem('token_expire', Date.now() + 3.5 * 24 * 60 * 60 * 1000); // 3.5天
        
        return userInfo;
    } catch (error) {
        throw error;
    }
}

// 检查登录状态
function checkLoginStatus() {
    const token = localStorage.getItem('token');
    const expireTime = localStorage.getItem('token_expire');
    
    if (!token || !expireTime) {
        return false;
    }
    
    // 检查token是否过期
    if (Date.now() > parseInt(expireTime)) {
        logout();
        return false;
    }
    
    return true;
}

// 自动刷新token
async function refreshToken() {
    try {
        const response = await axios.post('/api/refresh', {
            token: localStorage.getItem('token')
        });
        
        const { token, expireTime } = response.data;
        localStorage.setItem('token', token);
        localStorage.setItem('token_expire', expireTime);
    } catch (error) {
        logout();
    }
}
```

### 2. JWT Token处理

```javascript
// JWT工具函数
class JWTUtils {
    // 解析JWT payload（不验证签名，仅用于前端显示）
    static parseJWT(token) {
        try {
            const payload = token.split('.')[1];
            return JSON.parse(atob(payload));
        } catch (error) {
            return null;
        }
    }
    
    // 检查token是否即将过期
    static isTokenExpiringSoon(token, thresholdMinutes = 30) {
        const payload = this.parseJWT(token);
        if (!payload || !payload.exp) return true;
        
        const now = Date.now() / 1000;
        return payload.exp - now < thresholdMinutes * 60;
    }
}

// Axios请求拦截器 - 自动添加token
axios.interceptors.request.use(config => {
    const token = localStorage.getItem('token');
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// 响应拦截器 - 处理token过期
axios.interceptors.response.use(
    response => response,
    async error => {
        if (error.response?.status === 401) {
            // Token过期，尝试刷新或跳转登录
            await refreshToken();
            // 重试原始请求
            return axios(error.config);
        }
        return Promise.reject(error);
    }
);
```

### 3. 消息实时推送SSE

```javascript
class SSEClient {
    constructor(url) {
        this.url = url;
        this.eventSource = null;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }
    
    connect() {
        this.eventSource = new EventSource(this.url);
        
        this.eventSource.onopen = () => {
            console.log('SSE连接已建立');
            this.reconnectAttempts = 0;
        };
        
        this.eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);
            this.handleMessage(data);
        };
        
        this.eventSource.addEventListener('notification', (event) => {
            const notification = JSON.parse(event.data);
            this.showNotification(notification);
        });
        
        this.eventSource.onerror = () => {
            console.error('SSE连接错误');
            this.eventSource.close();
            
            // 断线重连
            if (this.reconnectAttempts < this.maxReconnectAttempts) {
                setTimeout(() => {
                    this.reconnectAttempts++;
                    this.connect();
                }, 1000 * this.reconnectAttempts);
            }
        };
    }
    
    handleMessage(data) {
        // 处理不同类型的消息
        switch (data.type) {
            case 'NEW_REPLY':
                this.updateReplyCount(data.count);
                break;
            case 'SYSTEM_ANNOUNCEMENT':
                this.showSystemMessage(data.content);
                break;
        }
    }
    
    disconnect() {
        if (this.eventSource) {
            this.eventSource.close();
        }
    }
}
```

### 4. 安全性优化

#### CSRF防护
```javascript
// 后端设置CSRF Token
app.use((req, res, next) => {
    // 生成CSRF Token
    const csrfToken = generateRandomToken();
    res.cookie('csrf-token', csrfToken, { 
        httpOnly: false, // 前端需要读取
        sameSite: 'strict'
    });
    next();
});

// 前端自动添加CSRF Token到请求头
axios.interceptors.request.use(config => {
    if (['post', 'put', 'delete'].includes(config.method.toLowerCase())) {
        const csrfToken = getCookie('csrf-token');
        if (csrfToken) {
            config.headers['X-CSRF-Token'] = csrfToken;
        }
    }
    return config;
});
```

#### XSS防护
```javascript
// 输入过滤和输出转义
function sanitizeHTML(str) {
    const div = document.createElement('div');
    div.textContent = str;
    return div.innerHTML;
}

// 使用Content Security Policy
// <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline'">
```

**存储型XSS vs 反射型XSS：**
- **存储型**：恶意脚本被保存到服务器（如论坛帖子、评论），所有访问者都会执行
- **反射型**：恶意脚本通过URL参数传递，仅对点击特定链接的用户生效

### 5. Git Merge vs Rebase

```bash
# Git Merge - 保留完整合并历史
git checkout main
git merge feature-branch  # 创建新的合并提交

# Git Rebase - 线性历史
git checkout feature-branch
git rebase main          # 将feature提交变基到main最新提交之后
```

**Rebase风险场景：**
```bash
# 危险操作：在公共分支上rebase
git checkout main
git rebase feature-branch  # 重写公共历史！

# 正确做法：只在本地分支使用rebase
git checkout feature-branch
git rebase main
git checkout main
git merge feature-branch   # 快进合并
```

**规避风险：**
- 永远不要在公共分支（main, develop）上执行rebase
- 使用 `git pull --rebase` 替代 `git pull` 保持线性历史
- 团队统一规范：feature分支使用rebase，主干分支使用merge

### 6. Axios封装与取消重复请求

```javascript
class RequestManager {
    constructor() {
        this.pendingRequests = new Map();
    }
    
    generateKey(config) {
        return `${config.method}-${config.url}-${JSON.stringify(config.data)}`;
    }
    
    addPendingRequest(config) {
        const key = this.generateKey(config);
        const controller = new AbortController();
        
        config.signal = controller.signal;
        
        if (this.pendingRequests.has(key)) {
            // 取消重复请求
            this.pendingRequests.get(key).abort();
        }
        
        this.pendingRequests.set(key, controller);
        return key;
    }
    
    removePendingRequest(key) {
        this.pendingRequests.delete(key);
    }
}

// Axios封装
const requestManager = new RequestManager();

const service = axios.create({
    timeout: 10000,
    baseURL: process.env.VUE_APP_BASE_API
});

// 请求拦截器
service.interceptors.request.use(config => {
    // 添加取消令牌
    const key = requestManager.addPendingRequest(config);
    config.cancelKey = key;
    
    // 添加全局loading
    if (config.showLoading !== false) {
        showLoading();
    }
    
    return config;
});

// 响应拦截器
service.interceptors.response.use(
    response => {
        const key = response.config.cancelKey;
        requestManager.removePendingRequest(key);
        
        hideLoading();
        return response.data;
    },
    error => {
        if (axios.isCancel(error)) {
            console.log('请求被取消:', error.message);
        } else {
            hideLoading();
            handleError(error);
        }
        return Promise.reject(error);
    }
);
```

**POST请求重复提交优化：**
```javascript
// 方法1：按钮防抖
const debouncedSubmit = debounce(handleSubmit, 1000);

// 方法2：请求锁定
let submitting = false;
async function handleSubmit(data) {
    if (submitting) return;
    
    submitting = true;
    try {
        await api.submit(data);
    } finally {
        submitting = false;
    }
}

// 方法3：基于请求内容的取消（已在上面实现）
```

### 7. 节流防抖使用场景

```javascript
// 防抖：连续操作只执行最后一次
function debounce(fn, delay) {
    let timer = null;
    return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
    };
}

// 节流：连续操作按固定频率执行
function throttle(fn, interval) {
    let lastTime = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastTime >= interval) {
            fn.apply(this, args);
            lastTime = now;
        }
    };
}

// 使用场景
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce(function() {
    // 搜索建议 - 防抖500ms
    fetchSearchSuggestions(this.value);
}, 500));

window.addEventListener('scroll', throttle(function() {
    // 滚动加载 - 节流100ms
    checkScrollPosition();
}, 100));
```

### 8. 图片懒加载优化版

```javascript
class LazyLoad {
    constructor(selector = '.lazy-load') {
        this.images = document.querySelectorAll(selector);
        this.observer = null;
        this.init();
    }
    
    init() {
        if ('IntersectionObserver' in window) {
            this.useIntersectionObserver();
        } else {
            this.useScrollListener();
        }
    }
    
    useIntersectionObserver() {
        this.observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    this.loadImage(entry.target);
                    this.observer.unobserve(entry.target);
                }
            });
        }, {
            rootMargin: '50px 0px', // 提前50px加载
            threshold: 0.1
        });
        
        this.images.forEach(img => this.observer.observe(img));
    }
    
    useScrollListener() {
        // 传统滚动检测（回答offsetTop问题）
        const checkPosition = throttle(() => {
            this.images.forEach(img => {
                if (this.isInViewport(img)) {
                    this.loadImage(img);
                }
            });
        }, 100);
        
        window.addEventListener('scroll', checkPosition);
        checkPosition(); // 初始检查
    }
    
    isInViewport(element) {
        // 获取元素相对于视口的位置
        const rect = element.getBoundingClientRect();
        return (
            rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&
            rect.bottom >= 0 &&
            rect.left <= (window.innerWidth || document.documentElement.clientWidth) && 
            rect.right >= 0
        );
    }
    
    loadImage(img) {
        const src = img.getAttribute('data-src');
        if (!src) return;
        
        img.src = src;
        img.classList.remove('lazy-load');
        img.onload = () => img.classList.add('loaded');
    }
}
```

**关于offsetTop问题：**
- `offsetTop` 是相对于offsetParent的位置，不一定是滚动容器
- 使用 `getBoundingClientRect()` 获取相对于视口的位置更准确

### 9. Vue2 vs Vue3区别

| 特性 | Vue2 | Vue3 |
|------|------|------|
| 响应式原理 | Object.defineProperty | Proxy |
| 组合API | Mixins | Composition API |
| 生命周期 | Options API | 生命周期函数 |
| 性能 | 较慢 | 更快的虚拟DOM |
| 包大小 | 较大 | Tree-shaking优化 |
| TypeScript | 支持一般 | 原生支持 |

```javascript
// Vue2 Options API
export default {
    data() {
        return { count: 0 }
    },
    methods: {
        increment() { this.count++ }
    },
    mounted() {
        console.log('组件挂载');
    }
}

// Vue3 Composition API
import { ref, onMounted } from 'vue';

export default {
    setup() {
        const count = ref(0);
        
        const increment = () => {
            count.value++;
        };
        
        onMounted(() => {
            console.log('组件挂载');
        });
        
        return { count, increment };
    }
}
```

### 10. React Hook原理

```javascript
// 简化的Hook实现原理
let currentHook = 0;
const hooks = [];

function useState(initialValue) {
    const position = currentHook++;
    
    if (hooks[position] === undefined) {
        hooks[position] = initialValue;
    }
    
    const setState = (newValue) => {
        hooks[position] = newValue;
        // 触发重新渲染
        render();
    };
    
    return [hooks[position], setState];
}

function useEffect(callback, dependencies) {
    const position = currentHook++;
    const hasNoDependencies = !dependencies;
    const oldDependencies = hooks[position];
    
    const hasChanged = hasNoDependencies || 
        dependencies.some((dep, i) => !Object.is(dep, oldDependencies?.[i]));
    
    if (hasChanged) {
        callback();
        hooks[position] = dependencies;
    }
    
    currentHook++;
}
```

**Hook使用限制：**
1. 只能在函数组件顶层调用
2. 不能在循环、条件、嵌套函数中调用
3. 原因：Hook依赖调用顺序来正确管理状态

### 11. useEffect vs useLayoutEffect

```jsx
function EffectDemo() {
    const [value, setValue] = useState(0);
    
    // useEffect: 异步，不阻塞渲染
    useEffect(() => {
        // 适合：数据获取、订阅、手动DOM操作
        document.title = `Value: ${value}`;
        
        return () => {
            // 清理函数
        };
    }, [value]);
    
    // useLayoutEffect: 同步，在浏览器绘制前执行
    useLayoutEffect(() => {
        // 适合：DOM测量、同步重新渲染
        const element = document.getElementById('my-element');
        if (element) {
            const height = element.getBoundingClientRect().height;
            if (height > 100) {
                element.style.height = '100px';
            }
        }
    }, [value]);
    
    return <div id="my-element">{value}</div>;
}
```

### 12. 比较版本号算法

```javascript
function compareVersions(version1, version2) {
    const v1 = version1.split('.');
    const v2 = version2.split('.');
    
    const maxLength = Math.max(v1.length, v2.length);
    
    for (let i = 0; i < maxLength; i++) {
        // 将每段转为数字比较，空段视为0
        const num1 = parseInt(v1[i] || '0');
        const num2 = parseInt(v2[i] || '0');
        
        if (num1 > num2) return 1;
        if (num1 < num2) return -1;
    }
    
    return 0;
}

// 测试用例
console.log(compareVersions('1.0.1', '1.0.2')); // -1
console.log(compareVersions('1.2.0', '1.1.99')); // 1
console.log(compareVersions('1.0', '1.0.0')); // 0
console.log(compareVersions('2.3.4', '2.03.4')); // 0

// 支持带预发布版本的比较
function compareVersionsWithPreRelease(v1, v2) {
    const [main1, pre1 = ''] = v1.split('-');
    const [main2, pre2 = ''] = v2.split('-');
    
    const mainCompare = compareVersions(main1, main2);
    if (mainCompare !== 0) return mainCompare;
    
    // 主版本相同，比较预发布版本
    if (!pre1 && pre2) return 1;  // 稳定版 > 预发布版
    if (pre1 && !pre2) return -1; // 预发布版 < 稳定版
    if (pre1 && pre2) {
        return pre1.localeCompare(pre2);
    }
    
    return 0;
}
```

这套题目考察了前端工程师的实战经验和原理理解。建议重点准备项目难点、安全优化和性能优化相关的问题，这些都是高级前端的核心能力。

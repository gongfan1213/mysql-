好的，我们先整理题目，然后为你提供详细的回答思路。这是前端面试的经典问题组合。

## 题目整理

**基础理论：**
1. 全局监听没有被catch的Promise异常
2. 闭包在柯里化中的实现
3. TS实现安全枚举效果
4. TS条件类型分配
5. TS模块扩展
6. 跨域
7. 都有哪些请求头
8. any、never和unknown的区别
9. Vue生命周期
10. Vue路由生命周期
11. React模拟生命周期
12. Pinia和Vuex的区别
13. useEffect和useLayoutEffect有什么区别
14. React中的Error Boundary

**手写题：**
- 大数相加

---

## 详细解答

### 1. 全局监听没有被catch的Promise异常

```javascript
// 全局捕获未处理的Promise拒绝
window.addEventListener('unhandledrejection', function(event) {
    // 阻止默认行为（在控制台输出错误）
    event.preventDefault();
    
    console.error('未处理的Promise拒绝:', event.reason);
    console.log('触发拒绝的Promise:', event.promise);
    
    // 在实际项目中，可以上报错误到监控系统
    // reportErrorToServer({
    //     type: 'UNHANDLED_REJECTION',
    //     reason: event.reason,
    //     promise: event.promise
    // });
});

// 测试
Promise.reject(new Error('这是一个未捕获的Promise错误'));
```

**应用场景**：错误监控、调试、用户体验改进。

### 2. 闭包在柯里化中的实现

```javascript
// 柯里化：把多参数函数转化为一系列单参数函数
function curry(fn) {
    // 闭包保存参数数量
    return function curried(...args) {
        // 闭包保存已传入的参数
        if (args.length >= fn.length) {
            return fn.apply(this, args);
        } else {
            // 返回新函数，继续接收参数
            return function(...args2) {
                return curried.apply(this, args.concat(args2));
            }
        }
    };
}

// 使用示例
function add(a, b, c) {
    return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
```

**闭包作用**：保存已传入的参数和原始函数的引用。

### 3. TS实现安全枚举效果

```typescript
// 方法1：使用字面量联合类型
type SafeDirection = 'up' | 'down' | 'left' | 'right';

function move(direction: SafeDirection) {
    console.log(`向${direction}移动`);
}

// move('invalid'); // 错误：类型不允许

// 方法2：使用const枚举（编译时替换，更安全）
const enum Direction {
    Up = 'UP',
    Down = 'DOWN',
    Left = 'LEFT', 
    Right = 'RIGHT'
}

function moveSafe(direction: Direction) {
    console.log(direction);
}

moveSafe(Direction.Up); // 安全的使用
// moveSafe('UP'); // 错误：必须使用枚举成员
```

### 4. TS条件类型分配

```typescript
// 条件类型在联合类型时会进行分配
type Example<T> = T extends string ? T : never;

// 分配过程：
type A = Example<string | number | boolean>;
// 等价于：
// (string extends string ? string : never) |
// (number extends string ? number : never) | 
// (boolean extends string ? boolean : never)
// 结果：string

// 阻止分配：用元组包装
type NoDistribute<T> = [T] extends [string] ? T : never;
type B = NoDistribute<string | number>; // never
```

### 5. TS模块扩展

```typescript
// 扩展第三方库的类型声明
declare module 'vue' {
    // 扩展ComponentCustomProperties
    interface ComponentCustomProperties {
        $myGlobalMethod: (msg: string) => void;
    }
}

// 扩展全局接口
declare global {
    interface Window {
        myCustomProperty: string;
    }
    
    interface Array<T> {
        // 为Array原型添加自定义方法
        first(): T | undefined;
    }
}
```

### 6. 跨域解决方案

```javascript
// 1. CORS（服务端设置）
// Response Headers:
// Access-Control-Allow-Origin: *
// Access-Control-Allow-Methods: GET,POST,PUT
// Access-Control-Allow-Headers: Content-Type

// 2. 代理服务器（开发环境）
// webpack devServer 配置
module.exports = {
    devServer: {
        proxy: {
            '/api': {
                target: 'http://localhost:3000',
                changeOrigin: true
            }
        }
    }
};

// 3. JSONP（仅限GET）
function jsonp(url, callbackName) {
    return new Promise((resolve) => {
        const script = document.createElement('script');
        script.src = `${url}?callback=${callbackName}`;
        window[callbackName] = (data) => {
            resolve(data);
            delete window[callbackName];
            document.body.removeChild(script);
        };
        document.body.appendChild(script);
    });
}
```

### 7. 常见请求头分类

**请求头分类：**
- **通用头**：`Cache-Control`, `Connection`
- **请求头**：`Authorization`, `Content-Type`, `User-Agent`, `Cookie`
- **响应头**：`Set-Cookie`, `Content-Type`, `Access-Control-Allow-Origin`
- **实体头**：`Content-Length`, `Content-Encoding`

### 8. any、never、unknown的区别

```typescript
// any: 放弃类型检查，可以赋值给任何类型
let a: any = 'hello';
a = 123; // OK
a(); // OK - 运行时可能出错

// unknown: 类型安全的any，需要类型检查后才能使用
let b: unknown = 'hello';
// b.toUpperCase(); // 错误：需要类型检查
if (typeof b === 'string') {
    b.toUpperCase(); // OK
}

// never: 表示永远不会出现的值
function error(message: string): never {
    throw new Error(message);
}

// 使用场景对比
function handleValue(val: unknown) {
    if (typeof val === 'string') {
        // val 现在是 string
    } else if (typeof val === 'number') {
        // val 现在是 number  
    } else {
        // val 现在是 never
        const check: never = val;
    }
}
```

### 9. Vue生命周期

```javascript
export default {
    beforeCreate() {
        // 实例初始化后，数据观测之前
    },
    created() {
        // 数据观测完成，可访问data、methods
    },
    beforeMount() {
        // 模板编译完成，尚未挂载到DOM
    },
    mounted() {
        // 已挂载到DOM，可访问$el
    },
    beforeUpdate() {
        // 数据更新，DOM尚未重新渲染
    },
    updated() {
        // DOM已重新渲染
    },
    beforeUnmount() {
        // 实例销毁前
    },
    unmounted() {
        // 实例已销毁
    }
}
```

### 10. Vue路由生命周期

```javascript
const routes = [{
    path: '/user/:id',
    component: User,
    beforeEnter(to, from, next) {
        // 路由独享的守卫
        next();
    }
}];

// 组件内守卫
export default {
    beforeRouteEnter(to, from, next) {
        // 不能访问this，因为组件实例还没创建
        next(vm => {
            // 通过vm访问组件实例
        });
    },
    beforeRouteUpdate(to, from, next) {
        // 在当前路由改变，但是该组件被复用时调用
        this.userData = await fetchUser(to.params.id);
        next();
    },
    beforeRouteLeave(to, from, next) {
        // 导航离开该组件的对应路由时调用
        const answer = window.confirm('确定要离开吗？');
        next(answer);
    }
}
```

### 11. React模拟生命周期

```jsx
import { useState, useEffect, useRef } from 'react';

function LifecycleDemo() {
    const [count, setCount] = useState(0);
    const mountedRef = useRef(false);
    
    // componentDidMount + componentDidUpdate
    useEffect(() => {
        if (!mountedRef.current) {
            // componentDidMount
            console.log('组件挂载完成');
            mountedRef.current = true;
        } else {
            // componentDidUpdate  
            console.log('组件更新完成', count);
        }
    });
    
    // componentWillUnmount
    useEffect(() => {
        return () => {
            console.log('组件即将卸载');
        };
    }, []);
    
    // shouldComponentUpdate 模拟
    const prevCountRef = useRef();
    useEffect(() => {
        prevCountRef.current = count;
    });
    const prevCount = prevCountRef.current;
    
    if (prevCount !== undefined && count === prevCount) {
        // 可以在这里阻止渲染（实际中不推荐）
    }
    
    return <div onClick={() => setCount(c => c + 1)}>Count: {count}</div>;
}
```

### 12. Pinia和Vuex的区别

| 特性 | Vuex | Pinia |
|------|------|-------|
| API设计 | 较复杂，需要定义state/mutations/actions | 简单，类似Composition API |
| TypeScript支持 | 需要额外配置 | 原生支持，类型推断完善 |
| 模块系统 | namespaced modules | 自动代码分割 |
| 体积 | 较大 | 更轻量（1KB） |
| 语法 | `this.$store.commit()` | 直接修改state |

```javascript
// Pinia示例
export const useCounterStore = defineStore('counter', {
    state: () => ({ count: 0 }),
    actions: {
        increment() {
            this.count++; // 直接修改
        }
    }
});

// 使用
const store = useCounterStore();
store.increment();
```

### 13. useEffect vs useLayoutEffect

```jsx
function EffectDemo() {
    const [value, setValue] = useState(0);
    
    // useEffect: 异步执行，不会阻塞浏览器渲染
    useEffect(() => {
        // 适合：数据获取、订阅、手动DOM操作
        document.title = `Value: ${value}`;
    }, [value]);
    
    // useLayoutEffect: 同步执行，在浏览器绘制前执行
    useLayoutEffect(() => {
        // 适合：DOM测量、同步重新渲染
        const element = document.getElementById('my-element');
        if (element) {
            element.style.height = '100px';
        }
    }, [value]);
    
    return <div id="my-element">{value}</div>;
}
```

### 14. React Error Boundary

```jsx
class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false, error: null };
    }
    
    static getDerivedStateFromError(error) {
        // 更新state使下一次渲染显示降级UI
        return { hasError: true, error };
    }
    
    componentDidCatch(error, errorInfo) {
        // 错误上报
        console.error('Error caught by boundary:', error, errorInfo);
        // reportErrorToService(error, errorInfo);
    }
    
    render() {
        if (this.state.hasError) {
            // 降级UI
            return (
                <div>
                    <h2>出错了！</h2>
                    <button onClick={() => this.setState({ hasError: false })}>
                        重试
                    </button>
                </div>
            );
        }
        
        return this.props.children;
    }
}

// 使用
<ErrorBoundary>
    <MyComponent />
</ErrorBoundary>
```

## 手写：大数相加

```javascript
function bigNumberAdd(a, b) {
    // 将数字转为字符串，方便逐位处理
    const str1 = a.toString();
    const str2 = b.toString();
    
    // 补齐长度
    const maxLength = Math.max(str1.length, str2.length);
    const s1 = str1.padStart(maxLength, '0');
    const s2 = str2.padStart(maxLength, '0');
    
    let carry = 0; // 进位
    let result = ''; // 结果
    
    // 从个位开始相加
    for (let i = maxLength - 1; i >= 0; i--) {
        const sum = parseInt(s1[i]) + parseInt(s2[i]) + carry;
        carry = Math.floor(sum / 10); // 计算进位
        result = (sum % 10) + result; // 当前位结果
    }
    
    // 处理最后的进位
    if (carry > 0) {
        result = carry + result;
    }
    
    return result;
}

// 测试
console.log(bigNumberAdd('123', '456')); // '579'
console.log(bigNumberAdd('999', '1')); // '1000'
console.log(bigNumberAdd('12345678901234567890', '98765432109876543210')); 
// '111111111011111111100'
```

这套题目覆盖了前端核心知识体系，建议理解原理而不仅仅是背诵答案。祝你面试顺利！

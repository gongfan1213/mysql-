很棒的一次面试经历！问题覆盖了项目、Java基础、数据结构、算法、数据库和系统设计。我们来逐一分析和解答，帮你做一次深度复盘。

---

### 1. 晖致实习经历 & 2. 实习中遇到的最大困难

这是典型的**行为面试题**，旨在了解你的实践经验、解决问题的能力和总结反思的习惯。

- **回答要点**：
    1.  **STAR原则**：
        - **S**： 项目背景和目标。
        - **T**： 你承担的具体任务。
        - **A**： 你采取的行动，尤其是遇到困难后你是怎么思考、分析和解决的。
        - **R**： 最终达成的结果（最好有量化指标，如“性能提升20%”、“导出时间从10分钟缩短到30秒”）。
    2.  **“最大困难”选择**：选择一个能体现你**技术能力、排查问题和沟通协作**的困难。例如：
        - **技术上的**：处理大文件导出时的内存溢出（OOM）问题。
        - **协作上的**：与上游团队确定数据接口格式，保证数据一致性。
        - **业务上的**：理解复杂的业务规则并将其转化为代码逻辑。

**示例回答框架**：
“在晖致的实习中，我主要负责XX数据报表的导出功能。最大的困难是，当导出数据量很大时，应用会出现内存溢出导致服务不可用。我首先使用JProfiler工具进行内存dump分析，发现是使用传统POI API时，将所有数据一次性加载到内存中导致的。我的解决方案是：第一，将技术栈切换为阿里开源的EasyExcel，它基于磁盘缓存和逐行解析的模式，能有效避免OOM；第二，在数据查询层面，我使用分页查询而不是一次性拉取全量数据；第三，利用CompletableFuture对分页查询进行异步并行处理，提升导出速度。最终，我们成功实现了百万级数据的安全导出，并且导出时间缩短了60%。”

---

### 3. 对于项目中使用到Easy Excel和CompletableFuture的理解

这里考察你对具体技术选型的理解和应用能力。

- **EasyExcel**：
    - **解决的问题**：传统Apache POI在处理大文件时内存占用高，容易导致OOM。
    - **核心原理**：
        - **读**：基于事件驱动模型（类似SAX），逐行解析并回调处理，不需要将整个文件加载到内存。
        - **写**：同样采用逐行写入磁盘的方式，并通过模板上色等方式优化性能。
    - **优点**：内存占用低、API简洁、功能强大（支持复杂表头、数据转换等）。

- **CompletableFuture**：
    - **解决的问题**：异步编程，将耗时的I/O操作（如数据库查询、远程调用）从主线程中分离，提升系统吞吐量。
    - **在项目中的应用**：在数据导出时，多个分页查询可以看作是多个独立任务。使用`CompletableFuture.supplyAsync()`将这些查询任务提交到线程池并行执行，最后使用`allOf().join()`等待所有任务完成，再统一组装数据。这比串行执行所有查询要快得多。
    - **优势**：提供了强大的异步任务编排能力，如链式调用（`thenApply`）、组合（`thenCompose`）、聚合（`thenCombine`）等，比传统的`Future`更灵活。

---

### 4. 口述倒数找链表第N个节点

**快慢指针法**是标准且最优的解法。

```java
public ListNode findNthFromEnd(ListNode head, int n) {
    if (head == null || n <= 0) return null;
    
    ListNode fast = head;
    ListNode slow = head;
    
    // 快指针先走 n 步
    for (int i = 0; i < n; i++) {
        if (fast == null) {
            return null; // 链表长度小于n
        }
        fast = fast.next;
    }
    
    // 快慢指针同时前进，直到快指针走到末尾
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    // 此时慢指针指向的就是倒数第n个节点
    return slow;
}
```
**口述要点**：“我使用快慢指针。先让快指针走N步，然后快慢指针一起每次走一步。当快指针走到链表末尾的null时，慢指针所在的位置就是倒数第N个节点。”

---

### 5. 口述求树的高度

**递归深度优先搜索**是最直观的解法。

```java
public int treeHeight(TreeNode root) {
    if (root == null) {
        return 0; // 空节点高度为0
    }
    // 计算左子树高度
    int leftHeight = treeHeight(root.left);
    // 计算右子树高度
    int rightHeight = treeHeight(root.right);
    // 树的高度 = 左右子树高度的最大值 + 1（当前节点自身）
    return Math.max(leftHeight, rightHeight) + 1;
}
```
**口述要点**：“采用递归的方法。如果节点为空，高度为0。否则，递归地计算其左子树和右子树的高度，树的高度就等于左右子树中较大的那个高度再加1。”

---

### 6. 给你一个正整数N，求其二进制表示中1的个数

**位操作法**，利用 `n & (n-1)` 的技巧，该操作会将n的二进制表示中最右边的1变为0。

```java
public int countBits(int n) {
    int count = 0;
    while (n != 0) {
        n = n & (n - 1); // 消除最右边的1
        count++;
    }
    return count;
}
```
**口述要点**：“我知道一个技巧，`n & (n-1)` 可以把n的二进制表示中最右边的1变成0。所以我可以循环执行这个操作，直到n变成0，循环执行了多少次，就说明有多少个1。”

---

### 7. 数据库中的脏读、不可重复读、幻读

这是数据库事务隔离级别的核心概念。

| 问题         | 含义                                                                 | 示例                                                                 |
| :----------- | :------------------------------------------------------------------- | :------------------------------------------------------------------- |
| **脏读**     | 一个事务读到了另一个**未提交事务**修改的数据。                         | 事务A修改了数据但未提交，事务B读取到了这个数据，随后A回滚，B读到的就是脏数据。 |
| **不可重复读** | 一个事务内，**多次读取同一行数据**，结果不一致（因为被其他事务**修改**或**删除**了）。 | 事务A第一次读取age=20，事务B将age改为30并提交，事务A再次读取age=30，两次读不一致。 |
| **幻读**     | 一个事务内，**多次按相同条件查询**，返回的记录集数量不一致（因为被其他事务**插入**了新的行）。 | 事务A第一次查询age<30的有10条记录，事务B插入了一条age=25的记录并提交，事务A再次查询发现有11条记录。 |

**解决方式**：通过设置事务隔离级别。
- **读未提交**：啥都解决不了。
- **读已提交**：解决脏读。
- **可重复读**：解决脏读、不可重复读。
- **串行化**：解决所有问题，但性能最差。

---

### 8. 一个生产者，多个消费者，java8的话用什么去实现

考察Java并发编程能力。

**首选方案：`BlockingQueue`**

```java
BlockingQueue<String> queue = new LinkedBlockingQueue<>(100); // 有界队列

// 生产者
Runnable producer = () -> {
    try {
        String data = ... // 生产数据
        queue.put(data); // 队列满时会自动阻塞
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
};

// 消费者
Runnable consumer = () -> {
    try {
        while (true) {
            String data = queue.take(); // 队列空时会自动阻塞
            // ... 处理数据
        }
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    }
};

// 启动
new Thread(producer).start();
for (int i = 0; i < 5; i++) { // 启动5个消费者
    new Thread(consumer).start();
}
```
**回答要点**：“我会使用`java.util.concurrent`包下的`BlockingQueue`，比如`LinkedBlockingQueue`或`ArrayBlockingQueue`。生产者调用`put`方法放入数据，如果队列满了会自动阻塞；多个消费者调用`take`方法获取数据，如果队列空了也会自动阻塞。这个实现是线程安全的，完美地解决了生产者和消费者之间的协作问题。”

---

### 9. 说一下几种排序算法，介绍快速排序

**常见排序算法**：
- **O(n²)**：冒泡排序、选择排序、插入排序（后两者在小数据量时表现不错）。
- **O(n log n)**：快速排序、归并排序、堆排序。
- **O(n)**：桶排序、计数排序、基数排序（非比较排序，有特定适用场景）。

**快速排序**：
- **核心思想**：分而治之。
- **步骤**：
    1.  **选择基准**：从数列中挑出一个元素作为“基准”。
    2.  **分区操作**：重新排列数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面。操作结束后，基准就处于数列的中间位置。
    3.  **递归排序**：递归地将小于基准值元素的子数列和大于基准值元素的子数列排序。
- **时间复杂度**：平均O(n log n)，最坏O(n²)（当数组已排序或逆序时）。
- **优化**：随机选择基准、三数取中法，以避免最坏情况。

---

### 10. 现在系统基础功能都已经实现了，要给全局加一个异常捕获，如何实现

这是一个典型的**横切关注点**问题，考察你的系统设计能力和对框架的掌握。

**在Spring Boot项目中的实现方案：**

1.  **使用 `@ControllerAdvice` 和 `@ExceptionHandler`（最常用、最优雅）**
    ```java
    @ControllerAdvice
    public class GlobalExceptionHandler {
        
        // 捕获所有Exception异常
        @ExceptionHandler(Exception.class)
        @ResponseBody
        public ResponseEntity<ApiResponse<Void>> handleException(Exception e) {
            // 记录日志
            log.error("Global exception caught: ", e);
            // 返回统一的错误格式给前端
            ApiResponse<Void> response = ApiResponse.error("系统繁忙，请稍后再试");
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
        }
        
        // 捕获自定义业务异常
        @ExceptionHandler(BusinessException.class)
        @ResponseBody
        public ResponseEntity<ApiResponse<Void>> handleBusinessException(BusinessException e) {
            ApiResponse<Void> response = ApiResponse.error(e.getMessage());
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(response);
        }
    }
    ```

2.  **如果使用Spring MVC，还可以配置 `HandlerExceptionResolver`**（更底层，但`@ControllerAdvice`更便捷）。

3.  **对于非Web项目或更底层的捕获**，可以考虑使用**面向切面编程（AOP）**，在切面中编写异常处理逻辑。

**回答要点**：“在Spring Boot项目中，我会定义一个全局异常处理类，并用`@ControllerAdvice`注解标记它。在这个类里，我可以通过`@ExceptionHandler`注解来定义针对不同类型异常的处理方法。这样，任何Controller层抛出的未被捕获的异常，都会被这个全局处理器拦截，然后我们可以在这里统一记录日志，并封装成统一的JSON格式返回给前端，保证响应体的规范性。”

---

### 总结与建议

这次面试考察点非常全面。你的表现取决于对这些基础知识和项目经验的掌握程度。建议你：

1.  **深入理解项目**：将项目中的技术选型（如EasyExcel, CompletableFuture）的原理、优劣、适用场景吃透。
2.  **夯实基础**：算法、数据结构、并发、数据库是永恒的重点。
3.  **思考系统设计**：像最后一题那样的问题，考察的是你如何系统性地思考和解决问题。

祝你面试顺利，拿到心仪的Offer！

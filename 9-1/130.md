这次面试确实问得很深入，尤其是分布式限流和快排时间复杂度的问题，很有字节的风格。别灰心，这完全是经验问题。我们来一起做一次深度复盘，帮你把这些问题彻底搞懂。

---

### 3. 让你做一个分布式限流，你怎么设计？

这是一个经典的**系统设计**问题，考察你的架构思维和对分布式组件的理解。

一个完整的分布式限流方案需要包含以下几个部分：

**1. 核心算法选择**
- **固定窗口计数器**：简单但存在临界点问题，不推荐。
- **滑动窗口计数器**：更平滑，是实践中的常用选择。
- **漏桶算法**：能平滑流量，但无法应对突发流量。
- **令牌桶算法（最常用）**：既能平滑流量，又能允许一定程度的突发流量，非常适合API限流。**Guava RateLimiter 就是单机版的令牌桶实现。**

**2. 技术选型与架构**
由于是分布式环境，限流状态（如剩余令牌数）需要存储在一个**集中式的存储中心**。

- **Redis + Lua脚本（最主流方案）**
    - **为什么用Redis**：高性能，支持过期时间，丰富的数据结构。
    - **为什么用Lua脚本**：确保限流逻辑（检查、扣减）的**原子性**，避免在集群环境下产生竞态条件。
    - **数据结构**：可以使用 `String`（存储计数）或 `Hash`（存储更复杂的时间窗口信息）。

- **网关层集成（生产级方案）**
    - 在API网关（如 **Spring Cloud Gateway, Sentinel, Nginx + lua-resty-limit-traffic**）层面直接配置限流规则。
    - **优点**：对业务代码零侵入，性能好，统一管理。

**3. 详细设计（以Redis + 令牌桶为例）**
假设要对某个用户`user:123`的某个操作进行限流：每秒最多10次。

```lua
-- Lua 脚本：原子化执行令牌桶限流
local key = KEYS[1] -- 限流KEY，如 "rate_limit:user:123"
local capacity = tonumber(ARGV[1]) -- 桶容量， 10
local rate = tonumber(ARGV[2]) -- 生成令牌的速率（个/秒）， 1
local requested = tonumber(ARGV[3]) -- 本次请求的令牌数， 1
local now = tonumber(ARGV[4]) -- 当前时间戳

local info = redis.call("HMGET", key, "tokens", "last_time")
local last_tokens = tonumber(info[1]) or capacity
local last_time = tonumber(info[2]) or now

-- 计算自上次请求后新产生的令牌数
local time_passed = now - last_time
local new_tokens = time_passed * rate
local current_tokens = math.min(capacity, last_tokens + new_tokens)

-- 判断是否有足够令牌
if current_tokens < requested then
    -- 不足，限流
    redis.call("HSET", key, "tokens", current_tokens, "last_time", last_time)
    return 0
else
    -- 充足，扣减令牌
    current_tokens = current_tokens - requested
    redis.call("HSET", key, "tokens", current_tokens, "last_time", now)
    redis.call("EXPIRE", key, math.ceil(capacity / rate) * 2) -- 设置合理的过期时间
    return 1
end
```
**回答要点**：“我会采用**令牌桶算法**，因为它能应对突发流量。在实现上，我会用**Redis作为中心存储**来维护桶的状态（当前令牌数、上次刷新时间），并且所有限流判断逻辑会封装在一个**Lua脚本**中执行，保证原子性。客户端每次请求时，调用这个Lua脚本，根据返回值决定是放行还是限流。对于更复杂的生产环境，我倾向于在网关层（如Spring Cloud Gateway）直接配置限流规则。”

---

### 4. 快排时间复杂度不均匀划分问题

这是一个非常深入的算法理论问题。你和AI的初步判断“平均还是O(n log n)”在**大多数情况下是对的**，但面试官想考察的是你对**最坏情况**的深刻理解。

**核心分析：**

1.  **标准快排（随机或均衡划分）**
    - 每次划分都大致将数组分成两半。递归树的高度是 log₂n，每层工作量是 O(n)，所以平均/期望时间复杂度是 **O(n log n)**。

2.  **固定比例不均匀划分（1:10）**
    - 假设每次划分，1/11的元素在左边，10/11的元素在右边。
    - **递归树的高度**：这棵树不再平衡。每次大部分元素都去了右边。树的高度不再是 log₂n，而是以 11/10 为底的对数，即 **log₁₁/₁₀ n**。
    - **每层工作量**：第一层O(n)，第二层左边是(1/11)n，右边是(10/11)n，加起来还是~O(n)。以此类推，**每层工作量之和仍然是O(n)**。
    - **总时间复杂度**：O(n) * log₁₁/₁₀ n。

**关键点：**
- **O(n log n) 的含义**：在计算机科学中，大O记号隐藏了常数因子和对数的底数。因为 **logₐ n = logₐ b * logᵦ n**，而 **logₐ b 是一个常数**。所以 O(log₁₁/₁₀ n) 等价于 **O(log n)**。
- **因此，即使按1:10这样固定比例的不均匀划分，只要比例是常数，快排的期望时间复杂度依然是 O(n log n)**。

**面试官的意图是什么？**
他可能想引导你思考：**什么情况下会退化为O(n²)？**
- 答案不是“固定比例的不均匀”，而是**“每次划分都极不均匀”**。
- 例如，如果你选择的pivot**每次都恰好是当前子数组中的最小值或最大值**，那么每次划分都会产生一个大小为0和另一个大小为n-1的子数组。这时递归树的高度就是n，总工作量是 n + (n-1) + ... + 1 = O(n²)。

**所以，你应该这样回答：**
“面试官您好。对于固定比例（如1:10）的不均匀划分，由于划分比例是一个常数，递归树的深度会从 log₂n 变为 log₁₁/₁₀ n。因为对数的底数变化带来的影响是一个常数因子，在大O表示法中被隐藏了，所以**平均时间复杂度仍然是O(n log n)**。只有当不均匀的程度不是固定的，比如在已排序数组中选择第一个元素作为pivot，导致**每次划分都极度不平衡（比如0和n-1）**，时间复杂度才会退化到O(n²)。”

---

### 5. ConcurrentHashMap怎么处理哈希冲突的？以及它的锁的粒度如何？

**1. 处理哈希冲突的方式**
ConcurrentHashMap (JDK 1.8+) 和 HashMap 一样，采用 **“数组 + 链表 + 红黑树”** 的结构。
- 当发生哈希冲突时，首先会用**链表**将发生冲突的节点连接起来（拉链法）。
- 当链表的长度**超过一定阈值（默认为8）**，并且**数组的长度达到64**时，会将这个链表**转换为红黑树**，以提升查询效率（从O(n)提升到O(log n)）。
- 当树的大小**小于等于6**时，它会退化成链表。

**2. 锁的粒度（这是并发性能的关键）**
- **JDK 1.7及以前**：使用**分段锁**。将整个数组分成一段一段（Segment），每把锁只锁住其中一段。
- **JDK 1.8及以后（重大优化）**：锁的粒度进一步细化到**数组的每个桶（bucket，即链表或树的头节点）**。
    - 它使用 **synchronized** 关键字来锁定每个桶的第一个节点。
    - 对于put操作，如果该桶为空，则使用CAS乐观锁进行无锁插入；如果不为空，则synchronized锁住这个桶的头节点再进行操作。
    - **这种设计的优点**：
        - 锁粒度更细，写操作只在真正发生哈希冲突的桶上进行锁竞争，并发度更高。
        - 读操作通常是无锁的（通过volatile读），性能极佳。

---

### 6-9. 基础八股文精要回答

**6. 三次握手四次挥手，为什么挥手多一次？**
- **三次握手**：A -> B (SYN), B -> A (SYN-ACK), A -> B (ACK)。目的是**同步序列号**，确认双方的收发能力。
- **四次挥手**：A -> B (FIN), B -> A (ACK), B -> A (FIN), A -> B (ACK)。
- **为什么多一次**：因为TCP连接是全双工的。当A发送FIN时，只表示A没有数据要发送了，但还可以接收数据。B收到FIN后，可能还有数据要发送给A，所以B的ACK和FIN**不能合并**发送，这就多了一次。

**7. 进程与线程的区别？**
- **根本区别**：进程是**资源分配**的基本单位；线程是**CPU调度和执行**的基本单位。
- **资源**：进程拥有独立的地址空间和系统资源；线程共享其所属进程的地址空间和资源，但拥有自己独立的栈和程序计数器。
- **开销**：进程创建、切换开销大；线程创建、切换开销小。
- **健壮性**：一个进程崩溃不会影响其他进程；一个线程崩溃可能导致整个进程崩溃。

**8. 什么时候会进行进程上下文的切换？**
- 当前进程的**时间片用完**。
- 当前进程**主动阻塞**（如等待I/O完成、调用sleep）。
- 有**更高优先级的进程**就绪。
- 当前进程**执行终止**。

**9. volatile 和 static？volatile 和 static 配合能代替原子类吗？**
- **volatile**：保证变量的**可见性**和**禁止指令重排序**，但不保证操作的**原子性**。
- **static**：表示变量属于类，在内存中只有一份副本。
- **`static volatile int i;` 能代替 `AtomicInteger` 吗？**
    - **不能！** `i++` 这个操作是 **“读-改-写”** 三个步骤的组合，不是原子的。即使i是volatile的，多个线程同时执行`i++`，仍然会导致更新丢失。
    - `AtomicInteger` 使用 **CAS (Compare-And-Swap)** 指令，能保证`incrementAndGet()`这样的操作为原子操作。

---

### 手撕：含汉字的最小覆盖子串

这道题是 **“最小覆盖子串”** 经典题的变种，难点在于字符集包含了**多字节的Unicode字符（如汉字）**。这要求你不能简单地用`charAt`，而应使用`s.codePoints()`或转换成字符数组。

**解题思路：滑动窗口**
1.  用两个Map（或数组）`need`和`window`，分别记录目标字符串T中每个字符的出现次数，以及当前窗口中各字符的出现次数。
2.  使用双指针`left`和`right`构成滑动窗口。
3.  `right`指针向右移动，扩大窗口，直到窗口包含了T中的所有字符。
4.  当窗口包含T中所有字符时，`left`指针向右移动，收缩窗口，并在此过程中记录最小覆盖子串的起始位置和长度。
5.  因为包含汉字，所以需要用**`String.codePoints()`方法来正确处理Unicode字符**。

```java
public String minWindow(String s, String t) {
    if (s == null || t == null || s.length() == 0 || t.length() == 0) {
        return "";
    }

    // 将字符串转换为Unicode码点数组，以正确处理汉字
    int[] sArr = s.codePoints().toArray();
    int[] tArr = t.codePoints().toArray();

    // need：记录t中每个字符需要的次数
    Map<Integer, Integer> need = new HashMap<>();
    // window：记录当前窗口中每个字符的出现次数
    Map<Integer, Integer> window = new HashMap<>();
    
    for (int c : tArr) {
        need.put(c, need.getOrDefault(c, 0) + 1);
    }

    int left = 0, right = 0;
    int valid = 0; // 记录窗口中满足need条件的字符个数
    int start = 0, len = Integer.MAX_VALUE; // 记录最小子串的起始索引和长度

    while (right < sArr.length) {
        // c 是将移入窗口的字符
        int c = sArr[right];
        // 右移窗口
        right++;
        // 进行窗口内数据的一系列更新
        if (need.containsKey(c)) {
            window.put(c, window.getOrDefault(c, 0) + 1);
            if (window.get(c).equals(need.get(c))) {
                valid++;
            }
        }

        // 判断左侧窗口是否要收缩
        while (valid == need.size()) {
            // 在这里更新最小覆盖子串
            if (right - left < len) {
                start = left;
                len = right - left;
            }
            // d 是将移出窗口的字符
            int d = sArr[left];
            // 左移窗口
            left++;
            // 进行窗口内数据的一系列更新
            if (need.containsKey(d)) {
                if (window.get(d).equals(need.get(d))) {
                    valid--;
                }
                window.put(d, window.get(d) - 1);
            }
        }
    }
    // 返回最小覆盖子串
    return len == Integer.MAX_VALUE ? "" : new String(sArr, start, len);
}
```

### 总结

这次面试失利的主要原因可能是对**第4题时间复杂度**的深层理解不够，以及**手撕题**在面对新变种（含汉字）时可能思路不够清晰。这些都是可以通过专项练习和深度思考来弥补的。

- **算法**：不仅要会写，更要懂其复杂度的**严格推导**和**各种边界情况**。
- **系统设计**：平时多积累像“分布式限流”这样的经典架构方案，形成自己的答题模板。
- **Java并发**：ConcurrentHashMap的演进是高频考点，务必掌握其1.7和1.8版本的原理差异。

这次经历是非常宝贵的，它精准地指出了你需要加强的方向。继续努力，下次一定能过！

恭喜进入三面！这次面试明显更深入底层原理和工程实践。我来为你详细解析这些问题。

## 详细解答

### 1. 闭包内存泄漏与解决方案

```javascript
// 内存泄漏示例
function createLeak() {
    const bigData = new Array(1000000).fill('*'); // 大数据
    return function() {
        console.log('闭包引用着bigData，即使外部函数执行完毕也不会释放');
        // bigData 一直被闭包引用，无法被GC回收
    };
}

const leakyFunction = createLeak();
// 即使leakyFunction不再使用，bigData仍然占用内存

// 解决方案1：及时解除引用
function createSafeClosure() {
    const bigData = new Array(1000000).fill('*');
    return function() {
        console.log('使用数据');
    };
}

const safeFunction = createSafeClosure();
// 使用完毕后
safeFunction = null; // 解除引用，允许GC回收

// 解决方案2：避免不必要的闭包引用
function avoidUnnecessaryClosure() {
    const bigData = new Array(1000000).fill('*');
    
    // 只引用需要的数据，而不是整个bigData
    const neededData = bigData.slice(0, 10);
    
    return function() {
        console.log(neededData); // 只引用小数据
    };
}
```

### 2. WeakMap 解决内存泄漏

```javascript
// WeakMap 的键是弱引用，不会阻止GC
const weakMap = new WeakMap();

function withWeakMap() {
    const bigData = new Array(1000000).fill('*');
    const key = {}; // 普通对象作为键
    
    weakMap.set(key, bigData);
    
    return function() {
        const data = weakMap.get(key);
        console.log('使用数据:', data?.length);
    };
}

const weakFunction = withWeakMap();
weakFunction();

// 当 key 被垃圾回收时，bigData 也会被回收
// 不需要手动清理，GC会自动处理

// 对比普通Map（会造成内存泄漏）
const normalMap = new Map();
function withNormalMap() {
    const bigData = new Array(1000000).fill('*');
    normalMap.set('key', bigData); // 强引用，阻止GC
}
```

### 3. CommonJS vs ES Module

```javascript
// CommonJS (Node.js默认)
const { method } = require('./module');
module.exports = { value: 1 };

// ES Module
import { method } from './module';
export const value = 1;

// CommonJS 缓存机制
// 第一次require时：
// 1. 执行模块代码
// 2. 缓存执行结果 module.exports
// 3. 后续require直接返回缓存

// 示例：
// module.js
console.log('模块被执行');
let count = 0;
module.exports = {
    getCount: () => count++,
    count: 0
};

// main.js
const m1 = require('./module'); // 输出："模块被执行"
const m2 = require('./module'); // 无输出，直接返回缓存
console.log(m1 === m2); // true
```

### 4. script的async和defer

```html
<!-- 默认：阻塞解析 -->
<script src="script.js"></script>
<!-- 解析暂停，下载执行，然后继续 -->

<!-- defer：延迟执行 -->
<script defer src="script.js"></script>
<!-- 异步下载，在DOM解析完成后按顺序执行 -->

<!-- async：异步执行 -->
<script async src="script.js"></script>
<!-- 异步下载，下载完成后立即执行（可能阻塞渲染） -->

<!-- 回答async是否阻塞后续DOM： -->
<!-- async脚本下载完成后会立即执行，此时会阻塞HTML解析 -->
<!-- 但下载过程是异步的，不会阻塞 -->
```

### 5. Cookie vs Header存储Token

```javascript
// Cookie存储
document.cookie = "token=abc123; path=/; max-age=3600; secure; samesite=strict";

// Header存储 (localStorage + 手动添加)
localStorage.setItem('token', 'abc123');

// 在请求中手动添加
fetch('/api', {
    headers: {
        'Authorization': `Bearer ${localStorage.getItem('token')}`
    }
});

// 区别对比：
| 特性 | Cookie | Header |
|------|--------|--------|
| 自动发送 | 是 | 否 |
| 跨域限制 | 有 | 无 |
| 存储大小 | 4KB | 5MB+ |
| 安全性 | 可设置HttpOnly | 易受XSS |
| 适用场景 | 会话管理 | API认证 |
```

### 6. ES6装饰器与高阶函数

```javascript
// 装饰器（ES7提案，需要Babel转换）
@decorator
class MyClass {
    @readonly
    method() {}
}

// 普通函数不支持装饰器的原因：
// 1. 函数提升（hoisting）问题
// 2. 装饰器主要针对类和类成员设计
// 3. 函数有多种调用方式，装饰难以统一

// 使用高阶函数实现类似功能
function logger(fn) {
    return function(...args) {
        console.log('调用函数:', fn.name);
        const result = fn.apply(this, args);
        console.log('结果:', result);
        return result;
    };
}

// 使用
const add = logger(function(a, b) {
    return a + b;
});

add(1, 2); // 输出调用日志
```

### 7. 回流重绘优化

```javascript
// 触发回流的操作（改变布局）：
element.style.width = '100px';
element.style.height = '100px';
element.style.margin = '10px';

// 触发重绘的操作（改变外观）：
element.style.color = 'red';
element.style.backgroundColor = '#fff';

// 优化策略：
// 1. 使用transform和opacity（不触发回流）
element.style.transform = 'translateX(100px)';

// 2. 批量DOM操作
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
    const div = document.createElement('div');
    fragment.appendChild(div);
}
container.appendChild(fragment);

// 3. 读写分离
// 错误做法：
for (let i = 0; i < 100; i++) {
    element.style.width = i + 'px'; // 写
    console.log(element.offsetWidth); // 读，触发回流
}

// 正确做法：
let width = element.offsetWidth; // 一次性读
for (let i = 0; i < 100; i++) {
    element.style.width = (width + i) + 'px'; // 批量写
}
```

### 8. TS枚举 vs 普通对象

```typescript
// 普通枚举
enum Color {
    Red = 'RED',
    Green = 'GREEN',
    Blue = 'BLUE'
}

// 常量枚举（编译时替换）
const enum FastColor {
    Red = 'RED',
    Green = 'GREEN'
}

// 普通对象
const ColorObj = {
    Red: 'RED',
    Green: 'GREEN'
} as const;

// 区别：
| 特性 | 枚举 | 常量枚举 | 普通对象 |
|------|------|----------|----------|
| 运行时存在 | 是 | 否 | 是 |
| 反向映射 | 是 | 否 | 否 |
| 类型安全 | 是 | 是 | 需要as const |
| 性能 | 一般 | 最好 | 好 |
```

### 9. type vs interface

```typescript
// interface - 声明合并
interface User {
    name: string;
}

interface User {
    age: number;
}
// 最终：{ name: string; age: number; }

// type - 不能合并
type User = { name: string };
// Error: 重复标识符

// 区别总结：
| 特性 | interface | type |
|------|-----------|------|
| 声明合并 | ✅ | ❌ |
| 扩展 | extends | & |
| 实现类 | ✅ | ❌ |
| 元组、联合类型 | ❌ | ✅ |

// 最佳实践：
// 1. 对象类型用interface
// 2. 联合类型、元组用type
```

### 10. 类型断言

```typescript
// 两种方式：
const element = document.getElementById('root') as HTMLElement;
const element2 = <HTMLElement>document.getElementById('root');

// 区别：
// 1. as语法在.tsx中不会与JSX冲突
// 2. <Type>语法更简洁，但在.tsx中会被解析为JSX

// 实际应用：
// 非空断言
const value = maybeValue!;

// 强制类型断言
const str = (123 as any) as string;

// 常量断言
const config = {
    type: 'admin'
} as const;
```

### 11. HTTP/2服务器推送

```javascript
// 应用场景：
// 1. 关键CSS/JS预推送
// 2. 字体文件推送
// 3. 首屏图片预加载

// Node.js实现示例：
const http2 = require('http2');
const server = http2.createSecureServer({
    key: fs.readFileSync('server.key'),
    cert: fs.readFileSync('server.crt')
});

server.on('stream', (stream, headers) => {
    // 主资源请求
    if (headers[':path'] === '/index.html') {
        stream.respondWithFile('index.html', {
            'content-type': 'text/html'
        });
        
        // 推送关联资源
        stream.pushStream({ ':path': '/style.css' }, (err, pushStream) => {
            pushStream.respondWithFile('style.css', {
                'content-type': 'text/css'
            });
        });
    }
});
```

### 12. Git命令与stash

```bash
# git pull vs git fetch
git pull = git fetch + git merge

# 更安全的做法：
git fetch origin          # 获取远程更新
git log origin/main..main # 查看差异
git merge origin/main     # 合并

# stash使用场景
git stash                 # 暂存当前修改
git pull origin main      # 拉取更新
git stash pop             # 恢复暂存，处理冲突

# 高级stash用法
git stash save "功能A开发中"  # 命名暂存
git stash list               # 查看暂存列表
git stash apply stash@{1}    # 应用特定暂存
```

### 13. 算法题1：解构赋值

```javascript
// 问题：const [a,b] = {a:1, b:1} 能运行吗？
// 答案：不能，因为对象不可迭代

// 解决方案：让对象可迭代
function makeIterable(obj) {
    obj[Symbol.iterator] = function* () {
        for (const key in this) {
            if (this.hasOwnProperty(key)) {
                yield this[key];
            }
        }
    };
    return obj;
}

// 使用
const obj = makeIterable({a: 1, b: 2});
const [a, b] = obj;
console.log(a, b); // 1, 2

// 更通用的方法：
function destructure(obj, keys) {
    return keys.map(key => obj[key]);
}

const [a, b] = destructure({a: 1, b: 2}, ['a', 'b']);
```

### 14. 算法题2：大数相加

```javascript
function bigNumberAdd(a, b) {
    // 处理字符串，从个位开始相加
    const arr1 = a.split('').reverse();
    const arr2 = b.split('').reverse();
    const result = [];
    
    let carry = 0;
    const maxLength = Math.max(arr1.length, arr2.length);
    
    for (let i = 0; i < maxLength; i++) {
        const num1 = parseInt(arr1[i] || '0');
        const num2 = parseInt(arr2[i] || '0');
        const sum = num1 + num2 + carry;
        
        result.push(sum % 10);
        carry = Math.floor(sum / 10);
    }
    
    if (carry > 0) {
        result.push(carry);
    }
    
    return result.reverse().join('');
}

// 测试
console.log(bigNumberAdd('123456789', '987654321')); // '1111111110'
```

### 15. 静态资源缓存策略

```javascript
// 基于Webpack的缓存策略
module.exports = {
    output: {
        filename: '[name].[contenthash:8].js',
        chunkFilename: '[name].[contenthash:8].chunk.js'
    },
    optimization: {
        splitChunks: {
            cacheGroups: {
                vendor: {
                    test: /[\\/]node_modules[\\/]/,
                    name: 'vendors',
                    chunks: 'all'
                }
            }
        }
    }
};

// Nginx缓存配置
// nginx.conf
location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
    expires 1y;
    add_header Cache-Control "public, immutable";
    
    # 基于内容变化的文件名，可以设置长期缓存
    if ($request_uri ~* \.[0-9a-f]{8}\.(js|css)) {
        expires max;
    }
}

location / {
    try_files $uri $uri/ /index.html;
    add_header Cache-Control "no-cache, no-store, must-revalidate";
}

// Service Worker缓存策略
const CACHE_NAME = 'static-v1';
const STATIC_URLS = [
    '/static/css/main.[hash].css',
    '/static/js/main.[hash].js'
];

self.addEventListener('install', event => {
    event.waitUntil(
        caches.open(CACHE_NAME)
            .then(cache => cache.addAll(STATIC_URLS))
    );
});

self.addEventListener('fetch', event => {
    event.respondWith(
        caches.match(event.request)
            .then(response => {
                // 返回缓存或网络请求
                return response || fetch(event.request);
            })
    );
});
```

这次三面考察了很多工程实践和底层原理，特别是内存管理、模块系统、构建优化等方面。你的回答需要体现出对前端工程化的深入理解和实践经验。祝你面试顺利！


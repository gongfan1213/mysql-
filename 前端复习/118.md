### 字节前端秋招一面0919 - 详细解答

#### 项目拷打（20min）
**准备要点**：
- 技术选型原因和对比
- 遇到的挑战和解决方案
- 个人贡献和成长
- 项目亮点和创新点

---

#### 八股文部分（30min）

##### 1. 元素不知道宽高，如何水平垂直居中
```css
/* 方法1：Flex布局（推荐） */
.container {
  display: flex;
  justify-content: center;
  align-items: center;
}

/* 方法2：Grid布局 */
.container {
  display: grid;
  place-items: center;
}

/* 方法3：绝对定位 + transform */
.container {
  position: relative;
}
.child {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

/* 方法4：表格布局 */
.container {
  display: table-cell;
  vertical-align: middle;
  text-align: center;
}
```

##### 2. position取值及区别
**position取值**：
- `static`：默认，正常文档流
- `relative`：相对自身定位，保留原空间
- `absolute`：相对最近非static祖先定位，脱离文档流
- `fixed`：相对视口定位，脱离文档流
- `sticky`：滚动时粘性定位

**百分比计算基准**：
- `relative`：基于自身原始位置
- `absolute`：基于定位祖先的padding box

##### 3. flex属性详解
```css
/* flex: flex-grow | flex-shrink | flex-basis */
.item {
  flex: 1 1 200px; /* 增长因子 1, 收缩因子 1, 基础大小 200px */
}

/* 常见简写 */
flex: 1;          /* flex: 1 1 0% */
flex: auto;       /* flex: 1 1 auto */
flex: none;       /* flex: 0 0 auto */
flex: 200px;      /* flex: 1 1 200px */
```

##### 4. 行内 vs 块级元素
| 特性 | 行内元素 | 块级元素 |
|------|----------|----------|
| **显示方式** | 同行显示 | 独占一行 |
| **尺寸设置** | 宽高无效 | 可设置宽高 |
| **边距** | 水平有效，垂直无效 | 四个方向都有效 |
| **包含关系** | 只能包含文本或行内元素 | 可包含任何元素 |

##### 5. BFC（块级格式化上下文）
**产生BFC的条件**：
- 根元素（`<html>`）
- `float` 不为 `none`
- `position` 为 `absolute` 或 `fixed`
- `display` 为 `inline-block`、`table-cell`、`flex`等
- `overflow` 不为 `visible`

**BFC特性**：
- 内部盒子垂直排列
- 垂直边距重叠解决
- 包含浮动元素
- 隔离外部浮动

##### 6. 解决margin塌陷
```css
/* 方法1：创建BFC */
.parent {
  overflow: hidden;
  display: flow-root;
}

/* 方法2：使用padding替代 */
.parent {
  padding-top: 1px;
}

/* 方法3：使用border */
.parent {
  border-top: 1px solid transparent;
}

/* 方法4：使用伪元素 */
.parent::before {
  content: '';
  display: table;
}
```

##### 7. ES6优秀API设计
**个人推荐**：
1. **Promise**：解决回调地狱，异步编程标准化
2. **箭头函数**：简洁语法，自动绑定this
3. **解构赋值**：简化数据提取，函数参数处理
4. **模块化**：统一的模块加载方案
5. **Map/Set**：更合适的数据结构
6. **Proxy/Reflect**：元编程能力提升

##### 8. 箭头函数 vs 普通函数
| 特性 | 箭头函数 | 普通函数 |
|------|----------|----------|
| **this绑定** | 词法作用域，继承父级 | 动态绑定，调用时决定 |
| **arguments** | 没有arguments对象 | 有arguments对象 |
| **构造函数** | 不能作为构造函数 | 可以作为构造函数 |
| **原型属性** | 没有prototype | 有prototype |

##### 9. ES6的new操作符
```javascript
// new操作符的执行过程
function _new(constructor, ...args) {
  // 1. 创建空对象，继承构造函数的原型
  const obj = Object.create(constructor.prototype);
  
  // 2. 执行构造函数，绑定this
  const result = constructor.apply(obj, args);
  
  // 3. 返回结果（如果构造函数返回对象则返回该对象，否则返回新对象）
  return result instanceof Object ? result : obj;
}

// 使用示例
class Person {
  constructor(name) {
    this.name = name;
  }
}
const person = _new(Person, 'Alice');
```

##### 10. == 与 === 的区别
```javascript
// == 宽松相等（类型转换）
'1' == 1;    // true，字符串转数字
0 == false;  // true，布尔值转数字
null == undefined; // true

// === 严格相等（不转换类型）
'1' === 1;   // false
0 === false; // false
null === undefined; // false

// 特殊情况
NaN === NaN; // false
+0 === -0;   // true
```

##### 11. 宏任务 vs 微任务
**执行顺序**：同步任务 → 微任务 → 宏任务

**宏任务**：
- `setTimeout`, `setInterval`
- `setImmediate` (Node.js)
- I/O操作
- UI渲染

**微任务**：
- `Promise.then/catch/finally`
- `process.nextTick` (Node.js)
- `MutationObserver`

##### 12. Promise resolve的微任务位置
```javascript
console.log('start');

Promise.resolve().then(() => {
  console.log('promise1');
});

setTimeout(() => {
  console.log('timeout');
}, 0);

Promise.resolve().then(() => {
  console.log('promise2');
});

console.log('end');

// 输出顺序：start → end → promise1 → promise2 → timeout
```
**答案**：当前执行栈清空后立即执行，在同一个微任务队列中。

##### 13. 跨域及解决方法
```javascript
// 1. CORS（服务端设置）
app.use((req, res, next) => {
  res.header('Access-Control-Allow-Origin', '*');
  res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE');
  res.header('Access-Control-Allow-Headers', 'Content-Type');
  next();
});

// 2. JSONP（仅GET请求）
function jsonp(url, callback) {
  const script = document.createElement('script');
  script.src = `${url}?callback=${callback}`;
  document.body.appendChild(script);
}

// 3. 代理服务器
// 4. postMessage（窗口间通信）
// 5. WebSocket
```

##### 14. HTTP协商缓存
**缓存策略**：
```http
# 请求头
If-None-Match: "abc123"
If-Modified-Since: Wed, 21 Oct 2023 07:28:00 GMT

# 响应头
ETag: "abc123"
Last-Modified: Wed, 21 Oct 2023 07:28:00 GMT
Cache-Control: no-cache
```

**工作流程**：
1. 客户端携带验证信息请求
2. 服务端检查资源是否修改
3. 未修改返回304，修改返回200+新资源

##### 15. 时间不一致的解决方案
```javascript
// 方案1：使用服务器时间
async function getServerTime() {
  const response = await fetch('/api/time');
  const serverTime = await response.json();
  const clientTime = Date.now();
  const timeDiff = serverTime - clientTime;
  
  // 后续使用校正后的时间
  return Date.now() + timeDiff;
}

// 方案2：NTP时间同步
// 方案3：使用时间戳而非具体时间
function isExpired(timestamp, ttl) {
  return Date.now() > timestamp + ttl;
}
```

---

#### 手撕代码：多级对象扁平化

```javascript
function flattenObject(obj, prefix = '', separator = '.') {
  let result = {};
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      const newKey = prefix ? `${prefix}${separator}${key}` : key;
      const value = obj[key];
      
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        // 递归处理嵌套对象
        Object.assign(result, flattenObject(value, newKey, separator));
      } else {
        // 基本类型或数组直接赋值
        result[newKey] = value;
      }
    }
  }
  
  return result;
}

// 测试用例
const nestedObj = {
  a: 1,
  b: {
    c: 2,
    d: {
      e: 3,
      f: [4, 5]
    }
  },
  g: null
};

console.log(flattenObject(nestedObj));
// 输出: { a: 1, 'b.c': 2, 'b.d.e': 3, 'b.d.f': [4, 5], g: null }

// 进阶版本：支持数组索引
function flattenObjectAdvanced(obj, prefix = '', separator = '.') {
  let result = {};
  
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      const newKey = prefix ? `${prefix}${separator}${key}` : key;
      const value = obj[key];
      
      if (typeof value === 'object' && value !== null) {
        if (Array.isArray(value)) {
          // 数组处理：带索引
          value.forEach((item, index) => {
            if (typeof item === 'object' && item !== null) {
              Object.assign(result, flattenObjectAdvanced(item, `${newKey}[${index}]`, separator));
            } else {
              result[`${newKey}[${index}]`] = item;
            }
          });
        } else {
          // 对象处理
          Object.assign(result, flattenObjectAdvanced(value, newKey, separator));
        }
      } else {
        result[newKey] = value;
      }
    }
  }
  
  return result;
}
```

---

### 面试准备建议

**二面重点准备**：
1. **框架原理**：Vue/React核心原理、虚拟DOM、Diff算法
2. **性能优化**：加载优化、渲染优化、内存管理
3. **工程化**：Webpack、Vite、模块联邦
4. **编程题**：复杂组件实现、算法优化
5. **系统设计**：前端架构设计、技术选型

**好运建议**：
- 深入理解底层原理，不只是API使用
- 准备项目难点和解决方案的详细描述
- 练习白板编程和思路表达
- 保持自信，展示学习能力和技术热情

祝你二面顺利！加油！💪

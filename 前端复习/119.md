### 字节前端一面详细解答

#### 1. 自我介绍
**要点**：突出技术栈、项目经验、个人优势，2-3分钟简洁明了。

#### 2. 项目架构介绍
**示例回答**：
"项目采用微前端架构，主应用使用React + TypeScript，子应用支持Vue/React。构建工具使用Webpack 5 + Module Federation，实现应用独立开发和部署。状态管理使用Zustand，路由使用React Router v6，并接入了统一的埋点监控系统。"

#### 3. 性能优化（20分钟深入问）

**性能指标**：
- **核心Web指标**：LCP（最大内容绘制）、FID（首次输入延迟）、CLS（累积布局偏移）
- **自定义指标**：首屏时间、可交互时间、资源加载完成时间

**阶段优化方案**：

```javascript
// 1. 加载阶段优化
// 代码分割 + 懒加载
const LazyComponent = lazy(() => import('./components/HeavyComponent'));

// 资源预加载
<link rel="preload" href="critical-font.woff2" as="font" crossorigin>

// 2. 运行时优化
// 虚拟列表
import { FixedSizeList as List } from 'react-window';

// 防抖节流
const debouncedSearch = useCallback(debounce(searchAPI, 300), []);

// 3. 缓存策略
// Service Worker缓存
self.addEventListener('fetch', event => {
  event.respondWith(caches.match(event.request));
});
```

#### 4. JSBridge通信原理
```javascript
// 1. URL Scheme方式
function invokeNative(method, params) {
  const url = `jsbridge://${method}?${JSON.stringify(params)}`;
  const iframe = document.createElement('iframe');
  iframe.src = url;
  document.body.appendChild(iframe);
  setTimeout(() => iframe.remove(), 100);
}

// 2. 注入API方式
window.NativeBridge = {
  callMethod: (method, params) => {
    // 客户端注入的方法
  }
};

// 3. 消息队列方式
window.addEventListener('message', (event) => {
  if (event.data.type === 'nativeCallback') {
    // 处理客户端回调
  }
});
```

#### 5. TypeScript高级特性
```typescript
// keyof - 获取接口的键集合
interface User {
  id: number;
  name: string;
}
type UserKeys = keyof User; // "id" | "name"

// typeof - 获取类型
const user = { id: 1, name: 'Alice' };
type UserType = typeof user; // { id: number; name: string }

// 泛型约束
function getProperty<T, K extends keyof T>(obj: T, key: K) {
  return obj[key];
}

// 装饰器
function Log(target: any, methodName: string, descriptor: PropertyDescriptor) {
  const original = descriptor.value;
  descriptor.value = function(...args: any[]) {
    console.log(`Calling ${methodName} with`, args);
    return original.apply(this, args);
  };
}
```

#### 6. 判断数组的5种方法
```javascript
const arr = [1, 2, 3];

// 1. Array.isArray (推荐)
Array.isArray(arr); // true

// 2. instanceof
arr instanceof Array; // true

// 3. constructor
arr.constructor === Array; // true

// 4. Object.prototype.toString
Object.prototype.toString.call(arr) === '[object Array]'; // true

// 5. Array.prototype.isPrototypeOf
Array.prototype.isPrototypeOf(arr); // true
```

#### 7. 移动端视觉还原方案
```css
/* 1. 使用viewport */
<meta name="viewport" content="width=device-width, initial-scale=1.0">

/* 2. REM适配 */
html {
  font-size: calc(100vw / 3.75); /* 设计稿375px */
}
.element {
  width: 1rem; /* 37.5px */
}

/* 3. 弹性布局 */
.container {
  display: flex;
  justify-content: space-between;
}

/* 4. 图片适配 */
.img {
  max-width: 100%;
  height: auto;
}
```

#### 8. 图片模糊问题解决
```css
/* 1. 使用2倍/3倍图 */
.logo {
  background-image: url('logo@2x.png');
  background-size: contain;
}

/* 2. 使用SVG替代位图 */
.icon {
  background-image: url('icon.svg');
}

/* 3. 设置合适的图片尺寸 */
.avatar {
  width: 88px;  /* 避免非整数像素 */
  height: 88px;
}

/* 4. 使用canvas绘制清晰图像 */
const canvas = document.createElement('canvas');
canvas.width = width * devicePixelRatio;
canvas.height = height * devicePixelRatio;
ctx.scale(devicePixelRatio, devicePixelRatio);
```

#### 9. 动画优化方案
```javascript
// 1. 使用CSS动画（GPU加速）
.element {
  transform: translateZ(0);
  transition: transform 0.3s ease;
}

// 2. 使用requestAnimationFrame
function animate() {
  element.style.transform = `translateX(${progress}px)`;
  if (progress < 100) {
    requestAnimationFrame(animate);
  }
}

// 3. 避免布局抖动
// 不良做法
function resizeElements() {
  for (let i = 0; i < elements.length; i++) {
    elements[i].style.width = elements[0].offsetWidth + 'px';
  }
}

// 优化做法
function resizeElementsOptimized() {
  const width = elements[0].offsetWidth;
  for (let i = 0; i < elements.length; i++) {
    elements[i].style.width = width + 'px';
  }
}
```

#### 10. React Hooks与版本对比
```jsx
// React 18新特性
import { createRoot } from 'react-dom/client';
import { useTransition, useDeferredValue } from 'react';

// 并发特性
function SearchBox() {
  const [isPending, startTransition] = useTransition();
  const deferredQuery = useDeferredValue(query);
  
  return (
    <div>
      <input onChange={(e) => {
        startTransition(() => setQuery(e.target.value));
      }} />
      {isPending && <Spinner />}
    </div>
  );
}

// React 18 vs 17
// - 新的根API: createRoot vs ReactDOM.render
// - 自动批处理优化
// - 并发特性支持
```

#### 11. HTTP协议演进对比
| 版本 | 特性 | 队头阻塞解决方案 |
|------|------|------------------|
| **HTTP/1.0** | 短连接，无host头 | 无 |
| **HTTP/1.1** | 持久连接，管道化 | 域名分片 |
| **HTTP/2** | 多路复用，头部压缩 | 流优先级 |
| **HTTP/3** | QUIC协议，0-RTT | 基于UDP避免队头阻塞 |

#### 12. 加密方式
```javascript
// 对称加密 AES
const crypto = require('crypto');
const cipher = crypto.createCipher('aes-256-gcm', key);
let encrypted = cipher.update(data, 'utf8', 'hex');

// 非对称加密 RSA
const { publicEncrypt, privateDecrypt } = require('crypto');
const encrypted = publicEncrypt(publicKey, Buffer.from(data));
const decrypted = privateDecrypt(privateKey, encrypted);
```

#### 13. 手写题

**26.1 数组flat方法**
```javascript
function myFlat(arr, depth = 1) {
  if (depth < 0) return arr;
  
  return arr.reduce((result, item) => {
    if (Array.isArray(item) && depth > 0) {
      return result.concat(myFlat(item, depth - 1));
    }
    return result.concat(item);
  }, []);
}

// 测试
console.log(myFlat([1, [2, [3]]], 1)); // [1, 2, [3]]
```

**26.2 Promise.all**
```javascript
function myPromiseAll(promises) {
  return new Promise((resolve, reject) => {
    if (!Array.isArray(promises)) {
      return reject(new TypeError('Arguments must be an array'));
    }
    
    const results = [];
    let completed = 0;
    
    if (promises.length === 0) {
      return resolve(results);
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(value => {
        results[index] = value;
        completed++;
        
        if (completed === promises.length) {
          resolve(results);
        }
      }).catch(reject);
    });
  });
}

// 其他Promise方法
Promise.race = function(promises) {
  return new Promise((resolve, reject) => {
    promises.forEach(promise => {
      Promise.resolve(promise).then(resolve).catch(reject);
    });
  });
};

Promise.allSettled = function(promises) {
  return Promise.all(promises.map(promise => 
    promise.then(value => ({ status: 'fulfilled', value }))
           .catch(reason => ({ status: 'rejected', reason }))
  ));
};
```

### 挂科原因分析与改进建议

**可能原因**：
1. **深度不够**：回答虽然正确但缺乏深度思考
2. **项目亮点不足**：项目复杂度或技术深度不够
3. **系统设计能力**：缺乏架构层面的思考
4. **沟通表达**：技术表达不够清晰有条理

**改进建议**：
1. **深入原理**：不只是会用，要理解底层实现
2. **项目重构**：增加技术难点和创新点
3. **系统设计练习**：学习大型前端架构设计
4. **模拟面试**：提高表达能力和临场应变

**学习资源推荐**：
- 深入理解React源码
- 浏览器渲染原理深度剖析
- 网络协议底层实现
- 大型项目性能优化实战

即使挂了也不要气馁，每次面试都是宝贵的学习机会！继续加油！💪

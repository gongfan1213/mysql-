好的，这是一份非常经典的字节前端二面题目，涵盖了项目、八股和手写。我们来逐一详细解答。

---

### **面试题目记录**

**面试公司/轮次：** 字节跳动，前端开发二面

**第一部分：JavaScript 基础 & 八股**
1.  什么是防抖和节流？两者的区别是什么？
2.  防抖和节流的实现原理是什么？分别有哪些应用场景？
3.  **手写防抖**
4.  为什么会有跨域？
5.  一般跨域的手段都有哪些？

**第二部分：框架（Vue & React）**
6.  **分析结果题：** 已知 picture A（元素含图片URL，对应渲染S1、S2、S3）和 picture B（元素含图片URL+唯一key值，对应渲染S1、S2、S3），删除两者中对应S2的中间项后重新渲染，picture A 和 picture B 分别渲染出几张图片、是哪几张？原理是什么？（核心关联 Vue 2 数组 diff 逻辑）
7.  原生 React 父子组件中，能促使组件重新渲染的因素有哪些？
8.  使用 React Hooks 时，用 useCallback、useMemo 避免重新渲染的整体原理是什么？
9.  useMemo 跟 useCallback 一般应用于什么场景？

**第三部分：工程化**
10. 大文件断点续传、断点上传的技术实现方案。

**第四部分：手写代码**
11. **手写：** 实现 `append` 函数：将任意多的项添加到目标数组中，过滤空值（`undefined`, `null`）并返回新数组，需处理 `arr` 不是数组、`arr` 为 `undefined/null` 的情况。

---

### **详细解答**

#### **第一部分：JavaScript 基础 & 八股**

**1. 防抖和节流的区别**

*   **防抖：** 在事件被触发 n 秒后执行回调，如果在这 n 秒内事件又被触发，则重新计时。
    *   **核心思想：** 等待用户“停下来”后再执行。例如搜索框输入。
    *   **比喻：** 电梯门。有人进电梯后，电梯门不会立刻关闭，而是等待一段时间，如果这段时间内又有人进来，就重新等待。
*   **节流：** 在规定的时间间隔内，只执行一次回调函数，即使在这段时间内事件被多次触发。
    *   **核心思想：** 保证在一定时间内只执行一次。例如滚动事件、窗口 resize。
    *   **比喻：** 水龙头。即使你把阀门拧得很大，水流也是匀速流出的。

**核心区别：** 防抖是**重置计时**，节流是**固定频率**。

**2. 实现原理与应用场景**

*   **防抖原理：** 利用 `setTimeout` 延迟执行。每次触发事件时，都清除之前的定时器并设置一个新的。
    *   **应用场景：** 搜索框联想、窗口 `resize`（只需在调整结束后计算最终布局）、文本编辑器实时保存。
*   **节流原理：** 利用时间戳或定时器，判断上次执行时间与当前时间的间隔是否大于设定的阈值。
    *   **应用场景：** 页面滚动加载更多、按钮频繁点击（防止重复提交）、鼠标移动事件。

**3. 手写防抖**

```javascript
/**
 * 防抖函数
 * @param {Function} func 要执行的函数
 * @param {number} wait 延迟的毫秒数
 * @param {boolean} immediate 是否立即执行（true表示先立即执行，再等待停止触发后才可再次执行）
 * @return {Function} 返回防抖后的函数
 */
function debounce(func, wait, immediate = false) {
    let timeoutId = null;

    return function (...args) {
        const context = this;

        // 如果已经存在定时器，清除它
        if (timeoutId) {
            clearTimeout(timeoutId);
        }

        // 立即执行模式
        if (immediate && !timeoutId) {
            // 如果之前没有定时器，说明是首次触发或等待期已过，立即执行
            func.apply(context, args);
            // 设置一个定时器，在 wait 时间后把 timeoutId 设为 null，允许下次立即执行
            timeoutId = setTimeout(() => {
                timeoutId = null;
            }, wait);
        } else {
            // 延迟执行模式
            timeoutId = setTimeout(() => {
                func.apply(context, args);
                timeoutId = null; // 执行完毕后重置
            }, wait);
        }
    };
}

// 测试用例
const logInput = (e) => console.log('Search:', e.target.value);
const inputEl = document.getElementById('search-input');
inputEl.addEventListener('input', debounce(logInput, 500));
```

**4. 为什么会有跨域？**

跨域是由浏览器的**同源策略**引起的。同源策略是一种重要的安全机制，它限制了从一个源加载的文档或脚本如何与另一个源的资源进行交互。

*   **同源定义：** 协议（protocol）、域名（host）、端口（port）三者完全相同。
*   **目的：** 为了防止恶意网站通过脚本窃取其他网站的敏感数据（如 Cookie、DOM 信息等）。如果没有同源策略，你访问一个恶意网站时，它可以在后台悄悄访问你的银行页面并执行操作。

**5. 一般跨域的手段都有哪些？**

*   **CORS（跨域资源共享）：** 最主流、最标准的方案。由服务端设置 `Access-Control-Allow-Origin` 等响应头来告诉浏览器允许哪些源的请求。
*   **JSONP：** 利用 `<script>` 标签没有跨域限制的特性。只能用于 GET 请求，且需要服务器端配合返回一段可执行的 JavaScript 代码。
*   **WebSocket：** 本身不受同源策略限制。
*   **代理：**
    *   **开发环境：** 使用 webpack-dev-server 或 Vite 的代理功能，将 API 请求转发到目标服务器。
    *   **生产环境：** 使用 Nginx 反向代理，让同源的请求由 Nginx 转发到不同源的后端服务。
*   **PostMessage：** 用于不同窗口/iframe 之间的通信。

---

#### **第二部分：框架（Vue & React）**

**6. 分析结果题（Vue 2 数组 Diff）**

*   **Picture A（无 key）：** 只包含图片 URL。
    *   **渲染结果：** 2 张图片（S1 和 S3）。
    *   **原理：** Vue 2 在更新 v-for 列表时，默认使用“就地复用”策略。当数据项的顺序改变时，Vue 不会移动 DOM 元素，而是就地更新每个元素的内容。删除中间项 S2 后，数组变为 `[S1, S3]`。Vue 会对比新旧虚拟 DOM：
        1.  第一个元素（原 S1）的 URL 没变，直接复用其 DOM 节点。
        2.  第二个元素（原 S2）的 URL 变成了 S3 的 URL，于是 Vue 会**就地更新**这个 DOM 节点的 `src` 属性，从 S2 的 URL 改为 S3 的 URL。
        3.  第三个元素（原 S3）被删除，对应的 DOM 节点被移除。
    *   **最终效果：** 用户可能会看到**第二张图片从 S2 闪烁一下变成了 S3**，因为 DOM 节点被复用了。

*   **Picture B（有 key）：** 包含图片 URL 和唯一 key。
    *   **渲染结果：** 2 张图片（S1 和 S3），且**渲染过程更高效**。
    *   **原理：** 为每个列表项提供了唯一的 `key` 属性后，Vue 就可以精确地跟踪每个节点的身份。Diff 算法会基于 key 的变化来重新排列元素顺序。
        1.  它发现 key 为 S1 的节点还在，直接复用。
        2.  它发现 key 为 S2 的节点不见了，会直接销毁对应的 DOM 节点。
        3.  它发现 key 为 S3 的节点还在，但位置从第三变成了第二，于是会**移动**这个 DOM 节点到新的位置。
    *   **最终效果：** S2 的图片节点被直接删除，S3 的图片节点被移动上来。**没有不必要的 DOM 更新，性能更好，且无闪烁。**

**7. React 父子组件重新渲染的因素**

*   **父组件重新渲染：** 默认情况下，父组件重新渲染会导致所有子组件也重新渲染。
*   **组件自身的状态（State）变化：** 调用 `setState` 或 `useState` 的 setter 函数。
*   **组件接收的属性（Props）变化：** 父组件传入的 props 值发生改变。
*   **上下文（Context）变化：** 组件消费的 Context 的 Value 发生改变。
*   **强制重新渲染：** 使用 `forceUpdate()` 方法（不推荐）。

**8. useCallback / useMemo 避免重新渲染的原理**

它们的原理都是**缓存**，通过依赖数组来决定是否更新缓存值，从而避免子组件不必要的重复渲染。

*   **useMemo：** 缓存**计算结果**。如果依赖项没变，就返回上一次计算的结果，避免重复执行高开销的计算。
*   **useCallback：** 缓存**函数本身**。如果依赖项没变，就返回上一次缓存的函数。

**避免重新渲染的链条：**
1.  父组件将用 `useCallback` 包裹的函数作为 prop 传递给子组件。
2.  子组件用 `React.memo` 包裹。
3.  当父组件重新渲染时，由于 `useCallback` 返回的是缓存的同一个函数（依赖未变），子组件的 props 在浅比较（`React.memo` 的行为）时被认为是相等的，因此子组件不会重新渲染。

**9. useMemo 和 useCallback 的应用场景**

*   **useMemo 场景：**
    1.  **昂贵的计算：** 如过滤、排序大型列表，复杂的数学计算。
    2.  创建引用类型的值（如对象、数组）时，避免因每次渲染都创建新引用导致子组件不必要的渲染。
*   **useCallback 场景：**
    1.  将函数作为 prop 传递给被 `React.memo` 优化的子组件。
    2.  函数是其他 Hook 的依赖项（如 `useEffect`）。

---

#### **第三部分：工程化**

**10. 大文件断点续传/上传方案**

1.  **文件分片：** 使用 `Blob.prototype.slice` 方法将大文件切割成固定大小（如 1MB）的小切片。
2.  **生成唯一标识：** 根据文件内容（如计算 MD5/SHA hash）或 `文件名+大小+最后修改时间` 生成一个唯一标识，用于标识同一个文件。
3.  **记录上传进度：**
    *   **前端：** 维护一个对象或数组，记录每个切片的上传状态（未上传、上传中、上传成功、上传失败）。
    *   **服务端：** 提供一个接口，让前端查询某个文件标识下哪些切片已经上传成功。
4.  **并发上传：** 使用 `Promise.all` 或并发控制库（如 `p-limit`）同时上传多个切片，提高速度。
5.  **断点续传：**
    *   **续传：** 上传前，先调用服务端的“查询已上传切片”接口，然后只上传未成功或服务器没有的切片。
    *   **断点：** 网络中断或页面关闭后，再次上传时，从步骤3开始，继续上传未完成的切片。
6.  **切片合并：** 所有切片上传完成后，前端通知服务端进行合并。服务端按切片索引顺序将所有切片文件合并成最终文件。
7.  **完整性校验：** 合并后，服务端可计算整个文件的 hash 值，与前端最初传来的文件 hash 进行比对，确保文件无误。

---

#### **第四部分：手写代码**

**11. 手写 append 函数**

```javascript
/**
 * 将任意多的项添加到目标数组中，过滤空值并返回新数组
 * @param {Array} arr 目标数组
 * @param {...any} items 要添加的项
 * @return {Array} 新数组
 */
function append(arr, ...items) {
    // 1. 处理 arr 为 null 或 undefined 的情况，初始化为空数组
    if (arr == null) { // 同时判断 null 和 undefined
        arr = [];
    }

    // 2. 处理 arr 不是数组的情况，可以抛出错误或将其转为单元素数组（根据需求，这里选择转为数组）
    if (!Array.isArray(arr)) {
        // 可以选择抛出错误
        // throw new TypeError('The first argument must be an array');
        // 或者根据题目“需处理arr不是数组”，将其包装成数组
        arr = [arr];
    }

    // 3. 过滤 items 中的空值 (undefined, null)
    const validItems = items.filter(item => item != null); // 过滤掉 null 和 undefined

    // 4. 创建新数组（避免修改原数组，符合函数式编程思想）
    const newArray = [...arr, ...validItems];

    return newArray;
}

// 测试用例
console.log(append([1, 2], 3, 4)); // [1, 2, 3, 4]
console.log(append([1, 2], 3, null, 4, undefined, 5)); // [1, 2, 3, 4, 5]
console.log(append(null, 1, 2)); // [1, 2]
console.log(append(undefined, 'a')); // ['a']
console.log(append(5, 1, 2)); // [5, 1, 2] (将数字5包装成数组)
console.log(append('hello', 'world')); // ['hello', 'world']
console.log(append([], null, undefined)); // [] (原数组为空，添加项全被过滤)
```

这道手写题考察了**参数处理、空值过滤、数组操作和边界情况处理**，是很好的基础能力测试。

---

这份面经的质量非常高，涉及的知识点很全面。把这些题目理解透彻，对于应对大厂前端面试非常有帮助。祝你面试顺利！

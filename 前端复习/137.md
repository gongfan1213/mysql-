好的，我们来详细梳理和解答这份字节跳动商业化广告前端的面经。这份面经非常典型，涵盖了前端基础、框架、TypeScript、React Hooks、异步编程和编程能力等多个维度。

---

### **一面**

#### 1. 自我介绍 + 最近一年比较有深度的项目
**考察点**：沟通表达能力、项目复盘和深度思考能力。
- **自我介绍**：简洁明了，突出技术栈、工作经验和亮点项目。
- **有深度的项目**：这是重头戏。不要只讲项目背景，要深入技术细节。
    - **背景与目标**：项目要解决什么业务/技术问题？（例如：提升广告加载性能、优化投放效率、搭建可视化配置平台等）
    - **技术方案与选型**：为什么选择这个技术栈？遇到了什么技术挑战？（例如：用Web Workers处理大量数据计算、用微前端架构隔离不同广告业务、用IndexedDB做本地缓存等）
    - **你的角色与贡献**：你具体负责了哪些模块？设计了什么方案？
    - **难点与解决方案**：详细描述一个技术难点，以及你是如何分析、排查和解决的。（例如：内存泄漏的排查与修复、复杂组件库的抽象与封装、首屏加载时间的优化手段）
    - **结果与量化**：项目最终取得了什么效果？最好用数据说话。（例如：首屏加载时间减少30%，CPM提升5%，开发效率提升50%等）

#### 2. 用过vue吗？
**考察点**：技术广度。虽然岗位可能主要用React，但Vue作为主流框架，了解其核心思想是加分项。
- **回答思路**：如果用过，可以简要说明使用经验和版本（如Vue 2/3）。如果没用过，可以诚实回答，但可以补充说明你对其核心概念（如响应式原理、组合式API）的理解，展现学习能力。

#### 3. Promise的回调函数，Promise.all和Promise.allSettled有什么区别？会用在什么场景？
**考察点**：异步编程的核心API理解与应用能力。

- **Promise.all**
    - **特点**：接收一个Promise数组，全部成功时返回一个成功结果数组；如果有一个失败，则立即 reject，返回第一个失败的错误。
    - **场景**：多个异步任务**强依赖**，必须全部成功才能进行下一步。
        - 例如：在页面初始化时，需要同时获取用户信息、配置信息、广告列表，三者缺一不可。

- **Promise.allSettled**
    - **特点**：接收一个Promise数组，无论成功或失败，都会等到所有Promise都完成（settled）。返回一个数组，每个元素是一个对象，描述对应Promise的结果`{status: "fulfilled", value: result}` 或 `{status: "rejected", reason: error}`。
    - **场景**：多个异步任务彼此独立，你想知道每个的最终结果，无论成败。
        - 例如：同时发送多个独立的广告曝光/点击日志，你希望即使某个日志发送失败，也不影响其他日志的发送，并且最后能知道哪些成功哪些失败。

#### 4. 设计一个全局捕捉JS运行错误的方案
**考察点**：错误监控与工程化能力。

一个完整的全局错误监控方案包括：
1.  **捕获错误**：
    - **全局捕获**：`window.onerror` 或 `window.addEventListener('error')`。可以捕获大多数运行时错误（包括JS错误、资源加载失败）。
    - **Promise错误**：`window.addEventListener('unhandledrejection')`。专门捕获未被catch的Promise rejection。
    - **框架错误**：如React的 `Error Boundary`，Vue的 `errorCaptured` 生命周期钩子。
    - **跨域脚本**：对于跨域脚本，需要在`<script>`标签上添加`crossorigin`属性，并且服务器返回正确的CORS头，才能捕获到详细的错误信息。

2.  **处理错误信息**：
    - 从错误事件中提取关键信息：错误消息、错误堆栈、文件名、行号、列号。
    - 添加上下文信息：用户UA、URL、用户ID、时间戳、上一个操作等。

3.  **上报错误**：
    - **上报方式**：使用 `new Image().src` 或 `navigator.sendBeacon()` 进行上报，避免阻塞页面卸载。
    - **上报目标**：将格式化后的错误数据发送到日志收集服务器。

**示例代码**：
```javascript
// 监听常规JS错误
window.addEventListener('error', (event) => {
  const errorLog = {
    type: 'JS_ERROR',
    message: event.message,
    file: event.filename,
    line: event.lineno,
    column: event.colno,
    stack: event.error?.stack,
    timestamp: Date.now(),
    url: window.location.href,
    userAgent: navigator.userAgent
  };
  // 上报错误
  reportToServer(errorLog);
});

// 监听Promise错误
window.addEventListener('unhandledrejection', (event) => {
  const errorLog = {
    type: 'PROMISE_REJECTION',
    reason: event.reason,
    timestamp: Date.now(),
    url: window.location.href,
  };
  reportToServer(errorLog);
});

function reportToServer(data) {
  // 使用 sendBeacon，在页面卸载时也能可靠上报
  const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
  navigator.sendBeacon('/api/collect-error', blob);
}
```

#### 5. Error boundary能捕获到异步错误吗？为什么？如果要做的话有什么方案？
**考察点**：对React Error Boundary机制的深入理解。

- **答案**：**默认不能**。
- **原因**：Error Boundary 的本质是 `try...catch` 机制在React组件树中的实现。它只能在React的**生命周期方法和渲染方法** 的同步执行过程中捕获错误。而异步操作（如 `setTimeout`、`fetch` 的 `then/catch`、事件处理器）的执行栈已经脱离了React的渲染流程，因此无法被捕获。

- **解决方案**：
    1.  **在异步代码内部处理**：在 `setTimeout`、Promise 的 `.catch` 中手动处理错误，或者将错误状态设置到组件的state中，从而触发重新渲染，让Error Boundary在渲染阶段捕获这个由state导致的错误。
    2.  **使用状态管理**：在异步操作中，通过Redux、Zustand等状态管理库派发一个错误action。在一个顶层、与UI无关的监听器中捕获这个action并进行上报。
    3.  **将异步错误转化为可捕获的错误**：
        ```jsx
        class MyComponent extends React.Component {
          state = { error: null };
        
          componentDidMount() {
            // 在异步操作中捕获错误，并设置state
            fetchData().catch(error => this.setState({ error }));
          }
        
          render() {
            if (this.state.error) {
              // 这里抛出的错误可以被Error Boundary捕获
              throw this.state.error;
            }
            return ...;
          }
        }
        ```

#### 6. 说说原型继承
**考察点**：JavaScript核心概念。

1.  **构造函数、原型、实例的关系**：
    - 每个构造函数都有一个 `prototype` 属性，指向它的原型对象。
    - 原型对象有一个 `constructor` 属性，指回构造函数。
    - 通过 `new` 关键字创建的实例，其内部 `__proto__` 属性（`Object.getPrototypeOf`）指向构造函数的原型对象。

2.  **原型链**：当访问一个对象的属性时，如果对象自身没有，就会通过 `__proto__` 去它的原型上找，如果原型上也没有，就去原型的原型上找，直到找到 `Object.prototype` 为止，如果还没找到就返回 `undefined`。这条链路就是原型链。

3.  **继承的实现**：
    - **组合继承**（最常用）：
      ```javascript
      function Parent(name) { this.name = name; }
      Parent.prototype.sayName = function() { console.log(this.name); };
      
      function Child(name, age) {
        Parent.call(this, name); // 1. 继承属性
        this.age = age;
      }
      Child.prototype = Object.create(Parent.prototype); // 2. 继承方法
      Child.prototype.constructor = Child; // 3. 修复constructor指向
      ```

#### 7. any, unknown, never的区别
**考察点**：TypeScript类型系统。

- **`any`**：
    - **“逃狱”类型**。关闭了所有类型检查。可以将任何值赋给 `any` 类型变量，也可以将 `any` 类型变量赋给任何其他类型。
    - **使用场景**：应急方案，应尽量避免。

- **`unknown`**：
    - **“安全”的any**。表示一个未知的类型。可以将任何值赋给 `unknown` 类型变量。
    - **但是**，不能将 `unknown` 类型变量赋给其他类型（除了 `any` 和 `unknown` 自身），也不能直接访问其属性、调用其方法。
    - **使用前必须进行类型检查（类型收窄）**。
    ```typescript
    let value: unknown = "hello world";
    // console.log(value.toUpperCase()); // Error
    if (typeof value === 'string') {
      console.log(value.toUpperCase()); // OK
    }
    ```

- **`never`**：
    - **“绝不可能”的类型**。表示那些永远不会有返回值的函数的返回类型，或者总是抛出错误的函数。
    - 是任何类型的子类型，可以赋给任何类型；但没有任何类型是 `never` 的子类型（除了 `never` 自身）。
    - **使用场景**：
        - 函数抛出错误：`function fail(msg: string): never { throw new Error(msg); }`
        - 无限循环：`function infiniteLoop(): never { while(true) {} }`
        - 在联合类型中，用于排除不可能的类型（常用于条件类型）。

#### 8. keyof和typeof的区别
**考察点**：TypeScript类型操作符。

- **`typeof`（TypeScript中的）**：用于在**类型上下文**中获取变量或属性的**类型**。
    ```typescript
    const person = { name: 'Alice', age: 20 };
    type Person = typeof person; 
    // 等价于 type Person = { name: string; age: number; }

    function f() { return { x: 10, y: 3 }; }
    type P = ReturnType<typeof f>; // type P = { x: number; y: number }
    ```

- **`keyof`**：用于获取某种**类型**的所有键，其返回类型是这些键的**联合类型**。
    ```typescript
    interface Person {
      name: string;
      age: number;
    }
    type K = keyof Person; // type K = "name" | "age"
    
    // 结合使用
    const person: Person = { name: 'Bob', age: 25 };
    function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
      return obj[key];
    }
    const name = getProperty(person, 'name'); // name: string
    ```

#### 9. useEffect和useLayoutEffect的区别？
**考察点**：React Hooks的底层执行时机。

| 特性 | `useEffect` | `useLayoutEffect` |
| :--- | :--- | :--- |
| **执行时机** | 在浏览器**完成绘制（paint）之后异步执行** | 在DOM更新之后，但浏览器**绘制之前同步执行** |
| **对用户的影响** | 不会阻塞浏览器绘制，可能会看到闪烁（如状态更新导致的样式变化） | 会阻塞浏览器绘制，适合执行**同步的、会直接影响DOM样式的操作**，可以避免闪烁 |
| **使用场景** | 数据获取、订阅、手动操作非React控制的DOM（非紧急） | 测量DOM元素、同步修改DOM样式（紧急） |
| **服务端渲染** | 在服务端和客户端都会执行 | 在服务端渲染时，React会警告。应在`useEffect`中替代或条件执行。 |

**简单记法**：`useLayoutEffect` 的时机和 `componentDidMount`、`componentDidUpdate` 更接近。

#### 10. 事件循环是什么？为什么有事件循环？
**考察点**：浏览器运行机制的核心。

- **是什么**：事件循环是JavaScript实现异步编程的机制。它是一个持续运行的循环，负责监听调用栈（Call Stack）和任务队列（Task Queue）。
    - **调用栈**：执行同步代码的地方。
    - **任务队列**：存放异步任务完成后的回调函数（如 `setTimeout`, `setInterval`, I/O, UI渲染）。
    - **微任务队列**：存放优先级更高的异步回调（如 `Promise.then/catch/finally`, `process.nextTick`, `MutationObserver`）。

- **运行机制**：
    1.  执行同步代码（调用栈）。
    2.  调用栈清空后，事件循环会先检查**微任务队列**，并依次执行所有微任务，直到微任务队列清空。
    3.  然后检查**任务队列**，取出一个任务（如一个`setTimeout`回调）放到调用栈执行。
    4.  重复步骤1-3。

- **为什么要有事件循环**：
    - **解决单线程阻塞问题**：JavaScript是单线程的，如果没有异步机制，一个耗时的操作（如网络请求）就会阻塞整个页面，导致用户无法交互。
    - **实现非阻塞式高并发**：通过事件循环，JavaScript可以将耗时的I/O操作交给浏览器其他线程（或操作系统）去处理，自己只负责处理回调，从而高效地处理大量并发任务。

#### 11. 题目：EventEmitter 二选一
**考察点**：设计模式（发布-订阅模式）和编码实现能力。

这是非常经典的前端手写题。实现一个简单的 `EventEmitter` 类，包含 `on`, `emit`, `off` 方法。

```javascript
class EventEmitter {
  constructor() {
    this.events = {};
  }

  // 订阅事件
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(callback);
    // 返回一个取消订阅的函数，方便使用
    return () => this.off(eventName, callback);
  }

  // 发布事件
  emit(eventName, ...args) {
    const callbacks = this.events[eventName];
    if (callbacks) {
      // 浅拷贝一份，防止在回调函数内取消订阅导致遍历出错
      callbacks.slice().forEach(cb => cb.apply(null, args));
    }
  }

  // 取消订阅
  off(eventName, callback) {
    const callbacks = this.events[eventName];
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index > -1) {
        callbacks.splice(index, 1);
      }
      // 如果该事件没有回调了，删除这个事件键
      if (callbacks.length === 0) {
        delete this.events[eventName];
      }
    }
  }

  // 可选：一次性订阅
  once(eventName, callback) {
    const onceWrapper = (...args) => {
      callback.apply(null, args);
      this.off(eventName, onceWrapper);
    };
    this.on(eventName, onceWrapper);
    return () => this.off(eventName, onceWrapper);
  }
}

// 使用示例
const emitter = new EventEmitter();
const unsubscribe = emitter.on('data', (msg) => console.log('Received:', msg));
emitter.emit('data', 'Hello World'); // Received: Hello World
unsubscribe(); // 取消订阅
emitter.emit('data', 'This will not be logged'); // 无输出
```

---

### **总结与建议**

这份面经非常具有代表性，考察点全面。准备字节跳动的前端面试，需要：
1.  **夯实基础**：JS原型、异步、事件循环是必考题。
2.  **深入框架**：不仅要会用React/Vue，更要理解其设计原理和边界情况（如Error Boundary）。
3.  **掌握TypeScript**：高级类型和类型编程已成为大厂前端标配。
4.  **具备工程化思维**：能从监控、性能、架构等角度思考问题。
5.  **熟练手写代码**：像EventEmitter、Promise、深浅拷贝这类基础工具要能信手拈来。

祝你面试顺利！

好的，我们继续深入分析这份字节跳动商业化广告前端的二面、三面和四面面经。这些问题更加侧重于工程实践、缓存机制、JavaScript底层原理和复杂编程能力。

---

### **二面**

#### 1. 项目 & 业务中关注的业务指标和技术指标
**考察点**：技术如何驱动业务，以及量化思维。对于商业化广告团队尤为重要。

- **业务指标**：
    - **收入相关**：eCPM（千次展示收入）、CPC（每次点击成本）、RPM（千次展示收入）、广告填充率、ARPU（每用户平均收入）。
    - **效果相关**：点击率（CTR）、转化率（CVR）、ROI（投资回报率）。
    - **用户体验**：广告对核心业务指标（如用户留存、使用时长）的影响。

- **技术指标**：
    - **性能**：
        - **首屏时间**：广告容器或广告内容首次渲染的时间。
        - **可交互时间**：广告加载对页面整体可交互性的影响。
        - **FCP/LCP**：首次内容绘制/最大内容绘制。
    - **稳定性**：
        - **JS错误率**：广告SDK或相关代码的错误率。
        - **请求成功率**：广告请求、素材加载的成功率。
        - **崩溃率**：对App内嵌H5广告而言。
    - **加载成功率**：从发起请求到成功展示的完整链条成功率。

#### 2. 常用的http header
**考察点**：对HTTP协议的理解，这是网络知识的基础。

- **请求头**：
    - `Authorization`：认证信息，如 Bearer Token。
    - `Content-Type`：请求体的类型，如 `application/json`。
    - `User-Agent`：客户端标识。
    - `Cookie`：携带Cookie。
    - `Cache-Control`：控制缓存行为。
    - `Accept` / `Accept-Encoding` / `Accept-Language`：告知服务器客户端能处理的内容类型、编码和语言。

- **响应头**：
    - `Content-Type`：响应体的类型。
    - `Cache-Control` / `Expires`：控制客户端缓存。
    - `Set-Cookie`：服务器设置Cookie。
    - `Access-Control-Allow-Origin`：CORS跨域相关。
    - `Last-Modified` / `ETag`：协商缓存相关。

#### 3. 简单请求 & 复杂请求
**考察点**：CORS跨域方案的细节。

- **简单请求**：
    - **方法**：GET, HEAD, POST。
    - **Header**：仅限于 `Accept`, `Accept-Language`, `Content-Language`, `Content-Type`（值仅限于 `application/x-www-form-urlencoded`, `multipart/form-data`, `text/plain`）。
    - **行为**：浏览器直接发出请求，并在请求头中自动添加 `Origin`。如果服务器返回的 `Access-Control-Allow-Origin` 包含该Origin，则请求成功。

- **复杂请求**：
    - **不满足简单请求条件的都是复杂请求**。例如，使用了 `PUT`, `DELETE` 方法，或 `Content-Type` 为 `application/json`。
    - **行为**：在发送实际请求之前，会先发送一个 **预检请求**。预检请求使用 `OPTIONS` 方法，携带 `Access-Control-Request-Method` 和 `Access-Control-Request-Headers`，询问服务器是否允许实际请求。服务器响应通过后，浏览器才会发送真正的请求。

#### 4. 强缓存 & 协商缓存
**考察点**：浏览器缓存机制，性能优化核心。

- **强缓存**：浏览器不向服务器发送请求，直接使用本地缓存。
    - **实现**：`Cache-Control`（优先级高，如 `max-age=3600`）和 `Expires`。
    - **状态码**：200 (from memory/disk cache)。

- **协商缓存**：浏览器向服务器发送请求，服务器根据请求头判断资源是否未修改。如果未修改，则返回304，浏览器使用缓存。
    - **实现**：
        - `Last-Modified`（响应头） 和 `If-Modified-Since`（请求头）。
        - `ETag`（响应头，资源的唯一标识） 和 `If-None-Match`（请求头）。`ETag` 优先级更高，能解决文件频繁修改但内容不变，或修改时间不精确的问题。

#### 5. 说运行结果（三道JavaScript题目）
**考察点**：对 `this`、原型链、`new` 操作符的深刻理解。

**题目一**：
```javascript
var a = function () { this.b = 3; } // 构造函数a
var b = 7; // 全局变量b
 
a.prototype.b = 1; // 原型上设置属性b
const c = new a(); // 执行构造函数，c.b = 3
 
console.log(b); // 关键在这里：浏览器中，构造函数a内部的this指向新对象c。但在Node.js中，顶级作用域的this指向module.exports。如果直接调用a()，浏览器中this是window，会覆盖全局b；Node中this是module.exports，不影响全局b。但这里是用new调用，所以this指向新对象，不影响外部b。原答案可能有误。正确答案应为 7。
console.log(c.b); // 3，实例自身属性，覆盖原型属性。
```
*修正*：`console.log(b)` 输出 **7**。因为 `new a()` 中的 `this` 指向新创建的对象 `c`，并不会修改外部的全局变量 `b`。

**题目二**：
```javascript
var a = function () { this.cc = 3; } // 构造函数a，设置实例属性cc
var b = 7; // 全局变量b
 
a.prototype.b = 1; // 原型上设置属性b
const c = new a(); // c自身有cc属性，没有b属性
 
console.log(b); // 7，全局变量b
console.log(c.b); // 1，c自身没有b，沿原型链找到 a.prototype.b
```

**题目三**：
```javascript
var a = function () { this.cc = 3; } // 构造函数a
var b = 7; // 全局变量b
 
const c = new a(); // 此时，c.__proto__ 指向最初的原型对象（假设为oldProto）
a.prototype = { b: 3 }; // 将a的prototype指向一个全新的对象
 
console.log(b); // 7
console.log(c.b); // undefined。因为c的原型链指向的是oldProto，而oldProto上没有b属性。新的原型对象 {b:3} 与c无关。
```

#### 6. 并发Promise
**考察点**：异步控制，通常指实现一个控制并发数量的函数。

题目通常是：实现一个函数，能并发执行多个异步任务，但同时执行的任务数不超过一个上限。

```javascript
function concurrentLimit(tasks, limit) {
  return new Promise((resolve) => {
    const results = [];
    let index = 0; // 当前要执行的任务索引
    let running = 0; // 正在运行的任务数
    let completed = 0; // 已完成的任务数

    function run() {
      // 当所有任务都已启动或并发数已达上限，则返回
      while (running < limit && index < tasks.length) {
        const currentIndex = index++;
        running++;
        
        tasks[currentIndex]()
          .then(result => {
            results[currentIndex] = result;
          })
          .catch(error => {
            results[currentIndex] = error;
          })
          .finally(() => {
            running--;
            completed++;
            // 只要还有任务没执行完，就继续启动新任务
            if (completed === tasks.length) {
              resolve(results);
            } else {
              run();
            }
          });
      }
    }

    run();
  });
}

// 使用示例
const tasks = [
  () => fetch('/api/1'),
  () => fetch('/api/2'),
  // ... 更多任务
];
concurrentLimit(tasks, 3).then(results => console.log(results));
```

---

### **三面**

#### 1. 深挖项目
**考察点**：与一面类似，但会挖得更深，可能涉及系统设计、技术选型权衡、遇到的最大挑战和解决方案的合理性。

#### 2. 算法题：给定一个数n如23121，给定一组数字a如[2, 4, 9]，求由a中元素组成的小于n的最大数
**考察点**：回溯算法、贪心思想，考验思维缜密度和代码实现能力。

**思路**：这是一个经典的“数位DP”或回溯问题。我们可以使用DFS（深度优先搜索）来构造数字。

1.  **排序**：先将数组 `a` 排序，方便按顺序选择数字。
2.  **DFS回溯**：
    - 从最高位开始，尝试在每一位上放置数字。
    - 目标是构造一个尽可能接近 `n` 但不超过 `n` 的数字。
    - **状态**：当前构造的数字 `current`，当前位 `pos`，是否已经小于 `n` 的前缀（`isLimit`），是否已经开始了数字（`started` 避免前导0）。
3.  **策略**：
    - 如果前面几位已经小于 `n` 的对应位（`isLimit` 为 `false`），那么后面的位可以随意选择数组中最大的数字。
    - 如果前面几位都等于 `n` 的对应位（`isLimit` 为 `true`），那么当前位只能选择小于等于 `n` 当前位的最大数字。
    - 尝试从大到小选择数字，这样一旦找到一个解，就是该位置下的最大可能解。

**代码实现**：
```javascript
function maxNumberLessThanN(n, digits) {
  const nStr = n.toString();
  const sortedDigits = [...digits].sort((a, b) => a - b);
  let result = -1;

  const dfs = (pos, isLimit, started, current) => {
    if (pos === nStr.length) {
      if (started) {
        result = Math.max(result, current);
      }
      return;
    }

    if (!started) {
      // 跳过当前位，继续递归（选择更少的位数）
      dfs(pos + 1, false, false, current);
    }

    const upperLimit = isLimit ? parseInt(nStr[pos]) : 9;
    // 从大到小尝试数字，以便尽早找到最大的
    for (let i = sortedDigits.length - 1; i >= 0; i--) {
      const d = sortedDigits[i];
      if (d > upperLimit) continue;
      dfs(
        pos + 1,
        isLimit && (d === upperLimit),
        true,
        current * 10 + d
      );
      // 如果找到一个解，由于是从大到小遍历，可以直接返回？不，需要尝试所有可能，但这里我们取最大值，所以DFS会自然找到最大的。
    }
  };

  dfs(0, true, false, 0);
  return result === -1 ? -1 : result; // 如果没找到，返回-1
}

// 测试
console.log(maxNumberLessThanN(23121, [2, 4, 9])); // 输出 22999
```

---

### **四面**

#### LRU + 超过x秒也需要清除没有get/set的缓存
**考察点**：数据结构设计能力和对缓存淘汰策略的扩展思考。

**思路**：这要求在标准LRU（最近最少使用）的基础上，增加一个**基于时间的过期淘汰**策略。

1.  **数据结构**：
    - 依然使用 `Map` 来存储键值对，以保持O(1)的访问和插入。
    - 需要存储每个节点的**最后访问时间**。

2.  **淘汰策略**：
    - **LRU淘汰**：当缓存达到容量上限时，淘汰最久未使用的节点。
    - **时间过期淘汰**：提供一个方法（如 `expireCheck`），在 `get` 或 `set` 时调用，遍历所有节点，删除那些最后访问时间距离现在超过 `maxAge` 的节点。为了性能，不必每次 `get/set` 都全量扫描，可以设置一个定时器或概率性触发。

3.  **实现**：

```javascript
class LRUCacheWithTTL {
  constructor(capacity, maxAge) {
    this.capacity = capacity;
    this.maxAge = maxAge; // 单位：毫秒
    this.cache = new Map(); // Map的迭代顺序就是插入顺序，最新的在最后
  }

  get(key) {
    this.expireCheck(); // 每次get时检查过期
    if (!this.cache.has(key)) return -1;

    const node = this.cache.get(key);
    // 删除并重新插入，使其成为最新的
    this.cache.delete(key);
    this.cache.set(key, { value: node.value, lastAccess: Date.now() });
    return node.value;
  }

  put(key, value) {
    this.expireCheck(); // 每次put时检查过期
    if (this.cache.has(key)) {
      // 如果key已存在，删除旧的
      this.cache.delete(key);
    } else if (this.cache.size >= this.capacity) {
      // 如果容量已满，淘汰最久未使用的（即Map的第一个元素）
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    // 插入新节点
    this.cache.set(key, { value, lastAccess: Date.now() });
  }

  expireCheck() {
    const now = Date.now();
    // 遍历所有键，删除过期的
    for (const [key, node] of this.cache.entries()) {
      if (now - node.lastAccess > this.maxAge) {
        this.cache.delete(key);
      } else {
        // 因为Map是有序的，一旦遇到一个未过期的，后面的也都未过期（按访问时间排序？不，是按插入顺序）。所以不能提前break。
        // 但我们的Map顺序是访问顺序，不是时间顺序，所以必须全部遍历。
      }
    }
  }
}
```

**注意**：在生产环境中，全量遍历 `expireCheck` 可能性能不佳。更优化的方案是使用一个按过期时间排序的**最小堆**来辅助，或者使用两个Map（一个存活跃数据，一个存即将过期的数据）来减少扫描范围。

---

### **总结**

从二面到四面，面试官考察的重点从广度和基础，转向了深度、系统设计和解决复杂问题的能力。尤其是：
- **工程化思维**（指标、缓存、HTTP）。
- **JavaScript底层原理**（原型链、`this`、作用域）。
- **复杂的异步控制**。
- **高级算法与数据结构**（回溯、LRU变种）。

准备这些内容，需要不仅有扎实的基础，还要有将知识融会贯通，解决实际问题的能力。

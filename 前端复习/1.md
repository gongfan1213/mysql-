好的，收到你的面经！我们先来抄一遍题目，然后我会为你提供一份非常详细、适合面试官视角的参考答案。

---

### **面试题目记录**

**面试公司/部门/时间：** 2025年9月5日，抖音电商，前端开发二面（45分钟）

**面试形式：** 八股文 + 手撕代码

**第一部分：八股文**
1.  Vue中虚拟DOM的优缺点。
2.  CSS中的定位方式。
3.  HTTP的Header中有什么常见的关键字。
4.  浏览器缓存中的关键字，怎么用的。
5.  开发时网页白屏怎么排查问题。
6.  变量的作用域怎么确定。
7.  this怎么判断。

**第二部分：手撕代码**
1.  **算法题：** 二叉树的右视图。
2.  **作用域题：** 求输出。
    ```javascript
    var a = 10;
    (function () {
      console.log(a);     // ①
      a = 5;              // ②
      console.log(window.a); // ③
    })();
    console.log(a);       // ④
    var a = 20;
    console.log(a);       // ⑤
    ```
3.  **this题：** 求输出。
    ```javascript
    window.name = 'ByteDance';

    function A() {
      this.name = 125;
    }

    A.prototype.getA = function () {
      console.log(this);
      return this.name;
    };
    ```

---

### **详细解答**

作为面试官，我希望听到的回答不仅准确，还能体现出候选人的深度和广度。以下是每个问题的参考答案。

#### **第一部分：八股文**

**1. Vue中虚拟DOM的优缺点**

*   **优点：**
    1.  **跨平台与抽象能力：** 虚拟DOM是对真实DOM的抽象，使得Vue可以脱离浏览器环境，在Node.js（SSR）、小程序、原生应用（如Weex/React Native）中运行。
    2.  **性能优化（非极致速度，而是优化心智模型）：** 它提供了一个相对高效的diff/patch算法。直接操作DOM的成本很高，频繁操作会导致页面重排重绘。虚拟DOM通过批量、差异化的更新，将多次DOM操作合并为一次，减少了不必要的性能损耗。对于大多数应用来说，这提供了“足够好”的性能，且开发者无需手动优化。
    3.  **声明式编程与开发效率：** 开发者只需关心数据状态（`data`），而无需关心DOM如何变化（命令式）。这大大降低了代码复杂度和维护成本，提升了开发体验。

*   **缺点：**
    1.  **内存占用：** 需要在JavaScript内存中维护一套虚拟DOM树，会占用额外的内存。
    2.  **运行时开销：** Diff算法本身需要消耗CPU资源。对于性能极致要求的场景（如频繁更新大量数据），手动进行精细的DOM操作（或使用Vue的编译器优化，如Vue 3的静态提升）可能比虚拟DOM的Diff+Patch更快。
    3.  **并非最快：** 虚拟DOM的价值不在于它比手动操作DOM更快，而在于它在**可维护性**和**性能**之间取得了很好的平衡。在特定场景下，基于模板的预编译（如Svelte）可能生成更高效的代码。

**2. CSS中的定位方式**

*   `static`（静态定位）：默认值。元素处于正常的文档流中，`top`, `right`, `bottom`, `left`, `z-index` 属性无效。
*   `relative`（相对定位）：元素相对于其正常位置进行定位。不会脱离文档流，其原位置会被保留。
*   `absolute`（绝对定位）：元素相对于最近一个**非** `static` 定位的祖先元素进行定位。如果找不到，则相对于初始包含块（通常是`<html>`）。会脱离文档流。
*   `fixed`（固定定位）：元素相对于浏览器视口（viewport）进行定位。即使页面滚动，它也会停留在相同的位置。会脱离文档流。
*   `sticky`（粘性定位）：元素在跨越特定阈值前为相对定位，之后变为固定定位。是`relative`和`fixed`的混合。常用于滚动吸顶效果。

**3. HTTP的Header中有什么常见的关键字**

*   **通用头（General Headers）：** 适用于请求和响应消息。
    *   `Cache-Control`：控制缓存机制。
    *   `Connection`：控制网络连接（如 `keep-alive`）。
*   **请求头（Request Headers）：** 客户端发送给服务器的信息。
    *   `User-Agent`：客户端浏览器标识。
    *   `Accept`：声明可接收的媒体类型（如 `application/json`）。
    *   `Authorization`：包含认证凭证（如Bearer Token）。
    *   `Cookie`：将Cookie发送给服务器。
*   **响应头（Response Headers）：** 服务器返回给客户端的信息。
    *   `Content-Type`：响应体的媒体类型（如 `text/html; charset=utf-8`）。
    *   `Set-Cookie`：服务器向客户端设置Cookie。
    *   `Location`：在重定向响应中，指定新的URL。
*   **实体头（Entity Headers）：** 描述消息体内容。
    *   `Content-Length`：消息体的大小。
    *   `Last-Modified`：资源最后修改时间。

**4. 浏览器缓存中的关键字，怎么用的**

浏览器缓存主要分为**强缓存**和**协商缓存**。

*   **强缓存（无需向服务器发起请求）：**
    *   `Cache-Control`（HTTP/1.1优先级更高）：
        *   `max-age=3600`：资源在3600秒内有效。
        *   `no-cache`：**不使用强缓存**，直接进入协商缓存。
        *   `no-store`：完全不使用任何缓存。
        *   `public`：响应可以被任何中间节点（如CDN）缓存。
        *   `private`：响应只能被客户端浏览器缓存。
    *   `Expires`（HTTP/1.0，已被`Cache-Control`取代）：指定一个绝对的过期时间。

*   **协商缓存（强缓存失效后，需向服务器验证）：**
    *   `Last-Modified`（响应头） / `If-Modified-Since`（请求头）：基于文件的修改时间。
    *   `ETag`（响应头） / `If-None-Match`（请求头）：基于文件内容的哈希值，比`Last-Modified`更精确。

**5. 开发时网页白屏怎么排查问题**

这是一个考察综合调试能力的问题，可以从简单到复杂、从前端到后端进行排查。

1.  **检查网络请求：** 打开开发者工具（F12）的Network面板，查看关键资源（HTML、JS、CSS）是否加载成功（Status 200）。常见的404、500错误会导致白屏。
2.  **检查Console控制台：** 查看是否有JavaScript报错（如语法错误、变量未定义、模块加载失败）。这是最常见的原因。
3.  **检查Elements面板：** 查看DOM树是否正常生成。如果只有`<html>`或`<body>`标签，而没有页面内容，可能是根组件挂载失败或JS执行被阻塞。
4.  **检查Sources面板：** 在可能出错的JS代码处设置断点，进行单步调试。
5.  **检查资源内容：** 确认加载的JS、CSS文件内容是否正确，是否被篡改或损坏。
6.  **性能问题：** 如果页面逻辑非常复杂，JS执行时间过长，也会导致长时间白屏。可使用Performance面板分析。
7.  **兼容性问题：** 检查代码中是否使用了某些浏览器不支持的API。
8.  **路由问题：** 在单页面应用（SPA）中，检查路由配置是否正确，当前URL是否匹配到了有效的组件。

**6. 变量的作用域怎么确定**

在JavaScript中，作用域决定了变量的可访问性。主要由**词法作用域（静态作用域）** 决定，即作用域在代码编写时就确定了。

*   **全局作用域：** 在最外层声明的变量拥有全局作用域。
*   **函数作用域：** 在函数内部声明的变量（使用`var`）拥有函数作用域。
*   **块级作用域：** 由`{}`包围，使用 `let` 和 `const` 声明的变量拥有块级作用域（如 `if`, `for`, `while` 语句内部）。
*   **作用域链：** 当访问一个变量时，JS引擎会从当前作用域开始查找，如果找不到，就向上级作用域查找，直到全局作用域。如果全局作用域也没有，则报错（ReferenceError）。

**7. this怎么判断**

`this`的指向是在**函数被调用时**确定的，遵循一定的规则，优先级从高到低如下：

1.  **new 绑定：** 使用 `new` 关键字调用函数（构造函数）时，`this` 指向新创建的对象实例。
    *   `const obj = new Foo();` // `this` -> `obj`
2.  **显式绑定：** 使用 `call`, `apply`, `bind` 方法直接指定 `this`。
    *   `foo.call(obj);` // `this` -> `obj`
3.  **隐式绑定：** 函数作为对象的方法被调用时，`this` 指向调用它的那个对象。
    *   `obj.foo();` // `this` -> `obj`
4.  **默认绑定：** 在严格模式（`'use strict'`）下，`this` 为 `undefined`。在非严格模式下，`this` 指向全局对象（浏览器中为 `window`）。
    *   `foo();` // 非严格模式：`this` -> `window`
5.  **箭头函数：** 箭头函数没有自己的 `this`，它的 `this` 继承自定义它时所处的**外层作用域**的 `this` 值。这个绑定无法被修改（`call`, `apply`, `bind` 无效）。

---

#### **第二部分：手撕代码**

**1. 二叉树的右视图**

**思路：** 使用**层序遍历（BFS）**。在遍历每一层时，只记录该层最后一个节点的值。

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var rightSideView = function(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root]; // BFS队列
    
    while (queue.length > 0) {
        const levelSize = queue.length; // 当前层的节点数
        
        for (let i = 0; i < levelSize; i++) {
            const currentNode = queue.shift(); // 出队
            
            // 如果是当前层的最后一个节点，加入结果
            if (i === levelSize - 1) {
                result.push(currentNode.val);
            }
            
            // 将子节点入队
            if (currentNode.left) queue.push(currentNode.left);
            if (currentNode.right) queue.push(currentNode.right);
        }
    }
    
    return result;
};
```

**2. 变量作用域题**

**关键点：** 变量提升（Hoisting）和立即执行函数（IIFE）的作用域。

```javascript
var a = 10; // 全局变量 a 被赋值为 10
(function () {
  console.log(a);     // ① 输出：undefined
  // 原因：函数作用域内，由于 `var a` 的变量提升，局部变量 a 被声明（但未赋值），覆盖了全局的 a。
  // 此时局部变量 a 的值为 undefined。

  a = 5;              // ② 这里赋值的是局部变量 a，将其从 undefined 改为 5。
  console.log(window.a); // ③ 输出：10
  // 原因：显式地访问全局对象 window 上的 a，它的值仍然是 10。
  var a; // 变量提升到函数顶部
})();
console.log(a);       // ④ 输出：10
// 原因：IIFE 内部操作的是自己的局部变量 a，全局变量 a 从未被修改。

var a = 20;           // 重新声明并赋值全局变量 a（这里也有提升，但被之前的赋值覆盖了）
console.log(a);       // ⑤ 输出：20
```

**最终输出：**
```
undefined
10
10
20
```

**3. this题**

**关键点：** 函数的调用方式决定了`this`。

```javascript
window.name = 'ByteDance';

function A() {
  this.name = 125; // 如果作为构造函数，this 指向新实例
}

A.prototype.getA = function () {
  console.log(this); // 这个函数的 this 取决于调用方式
  return this.name;
};

// 题目没有给出调用代码，这是考察点。面试官可能会问以下几种情况：

// 情况1：直接调用方法（默认绑定）
const getAFn = A.prototype.getA;
console.log(getAFn()); 
// 输出：Window对象 (或全局对象) -> "ByteDance"
// 原因：getAFn是直接调用的，非严格模式下this指向window。

// 情况2：作为构造函数实例的方法调用（隐式绑定）
const instance = new A();
console.log(instance.getA()); 
// 输出：A { name: 125 } -> 125
// 原因：getA是作为instance的方法调用的，this指向instance。

// 情况3：使用call/apply改变this（显式绑定）
console.log(A.prototype.getA.call({ name: 'Hello' })); 
// 输出：{ name: 'Hello' } -> "Hello"
// 原因：使用call将this显式绑定到新对象上。
```

通常，面试官会给出具体的调用代码让你分析。核心就是运用上面提到的`this`绑定规则。

---

希望这份超详细的解答能帮你更好地准备！继续日更，大力出奇迹，祝你面试顺利，offer多多！

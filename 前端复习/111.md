非常棒的一份字节前端凉经，问题覆盖面广且非常深入，拷打了一个多小时确实强度很大。我们来逐一拆解和回答这些问题，这对于准备高级前端面试非常有帮助。

---

### **1. 自我介绍**
*   **思路：** 突出技术栈（Vue/React、TS、工程化）、项目亮点（智慧大屏、AI会话等）、解决问题的能力，以及你对前端的热情。控制在1-2分钟内。

### **2. 智慧大屏数据同步渲染还是异步渲染？**
*   **答：** **异步渲染。**
*   **理由：** 智慧大屏数据量可能很大，如果同步渲染，会阻塞页面的首次绘制和交互，导致长时间白屏，体验极差。异步渲染（例如，使用 `Promise`、`setTimeout`、`requestAnimationFrame` 或将数据获取与渲染分离）可以将数据加载和复杂的渲染计算放到下一个事件循环或空闲时段执行，保证页面的流畅性和可交互性。

### **3. AI会话很多很长，如何保证加载不卡顿？提示可以考虑缓存**
*   **答：**
    1.  **分页/虚拟列表：** 核心方案。不一次性渲染所有对话，只渲染可视区域及附近的部分对话。随着滚动动态加载和销毁DOM元素。
    2.  **缓存：** 对已加载的对话内容在内存或本地存储（如 `localStorage`）中进行缓存。当用户来回翻看时，可以直接从缓存读取，避免重复请求网络。
    3.  **懒加载：** 初始只加载最新或最重要的部分对话，用户有需要时（如点击“加载更多”）再加载历史记录。

### **4. 需要记录每一句对话的时间戳吗，如何记录，是需要每隔一段时间记录还是每一句都要记录？**
*   **答：** **每一句都要记录。**
*   **理由：** AI对话的上下文和顺序至关重要。记录每一句话的精确时间戳可以用于：
    *   **排序和显示：** 确保对话按正确顺序展示。
    *   **调试与分析：** 分析用户与AI的交互模式、响应时间等。
    *   **恢复上下文：** 刷新页面后能准确还原对话状态。
*   **如何记录：** 在客户端发送用户消息和接收AI回复时，立即生成时间戳，并随对话内容一起存储。服务端也应记录时间戳以保证一致性。

### **5. 音乐播放器歌词如何实现每一句的高亮？每一个字的高亮呢？**
*   **每一句高亮：**
    1.  将歌词解析为 `{ time: 开始时间（秒）, text: ‘歌词文本’ }` 的数组。
    2.  监听音频的 `timeupdate` 事件，获取当前播放时间 `currentTime`。
    3.  遍历歌词数组，找到满足 `currentTime >= 当前句.time && currentTime < 下一句.time` 的那一句。
    4.  通过CSS类（如 `.active`）为这一句应用高亮样式。
*   **每一个字的高亮（逐字染色）：**
    1.  需要更精细的数据，知道每个字的开始时间（通常需要特定格式的歌词文件，如逐字Lyric）。
    2.  将一句歌词的每个字用 `<span>` 包裹，并为每个 `span` 设置 `data-start-time` 属性。
    3.  在 `timeupdate` 事件中，不仅找到当前句，还要遍历这句里的所有 `span`，找到当前时间对应的那个字，并为其添加高亮类。同时可以计算已过时间与字时长的比例，实现渐变效果。

### **6. 聊聊屏幕适配，pxtorem如何解决浏览器限制最小尺寸不能小于12px，现有技术如何解决？答scale缩小，他说会跑偏**
*   **问题：** 当根元素（`<html>`）的 `font-size` 设置得过小（如小于12px）时，某些浏览器会忽略这个设置，仍然以12px渲染，导致适配失效。
*   **解决方案：**
    1.  **使用 `transform: scale()`：** 这是可行的方案。但面试官说“会跑偏”，指的是缩放是以元素中心为基准的，可能导致布局错位。可以通过 `transform-origin: 0 0;` 将缩放基准点设置为左上角，并结合精确的宽高计算来避免“跑偏”。
    2.  **使用 `vw` / `vh` 单位直接适配：** 绕过 `rem`，直接使用相对于视口宽度的 `vw` 单位。例如，设计稿宽度750px，那么 `1px = (1 / 750) * 100 vw`。可以使用 PostCSS 插件自动转换。
    3.  **媒体查询精细控制：** 在极小尺寸的屏幕上，通过媒体查询直接覆盖样式，避免字体过小。

### **7. 公共组件如何做稳定性监控？怎样线上监控组件异常？**
*   **答：**
    1.  **Vue 错误捕获：** 使用 `Vue.config.errorHandler` 全局错误处理函数捕获组件渲染函数和观察器的未捕获错误。
    2.  **React 错误边界：** 使用 `componentDidCatch` 生命周期或 `static getDerivedStateFromError` 的 `ErrorBoundary` 组件包裹公共组件，捕获其子组件树的JavaScript错误。
    3.  **`window.onerror` 和 `window.addEventListener(‘error’)`：** 捕获全局的JavaScript运行时错误。
    4.  **`window.addEventListener(‘unhandledrejection’)`：** 捕获未处理的Promise拒绝。
    5.  **上报：** 在捕获到错误后，将错误信息（message, stack, componentStack等）、用户信息、设备信息等通过 `navigator.sendBeacon` 或 `img.src` 的方式上报到监控平台。

### **8. js有哪些报错？哪些异常类型？**
*   **常见错误类型（构造函数）：**
    1.  `SyntaxError`： 语法错误。
    2.  `ReferenceError`： 引用不存在的变量。
    3.  `TypeError`： 值不是预期类型，如 `null.toString()`。
    4.  `RangeError`： 数值超出有效范围，如 `new Array(-1)`。
    5.  `URIError`： URI处理函数使用不当。
    6.  `EvalError`： `eval()` 函数使用异常（现已很少见）。
    7.  `AggregateError`： 多个错误的集合。
    *   所有错误都继承自 `Error` 对象。

### **9. js如何开启第二条线程？提示web worker**
*   **答：** 使用 **Web Worker**。
*   **步骤：**
    1.  创建一个单独的JS文件作为Worker脚本（`worker.js`）。
    2.  在主线程中：`const myWorker = new Worker(‘worker.js’);`
    3.  通过 `postMessage` 通信：主线程 `myWorker.postMessage(data)`，Worker线程内 `onmessage = (e) => { … }`。
    4.   Worker线程处理完任务后，同样用 `postMessage` 将结果发回主线程。

### **10. js如何捕获异步任务异常？除了then catch呢？**
*   **答：**
    1.  **`async/await` + `try...catch`：** 这是最直观和现代的方式。
        ```javascript
        async function fetchData() {
          try {
            const result = await someAsyncFunction();
          } catch (error) {
            // 捕获异常
          }
        }
        ```
    2.  **Promise的 `.catch()` 方法。**
    3.  **全局捕获：** `window.addEventListener(‘unhandledrejection’, event => { … })`，用于捕获未被处理的Promise拒绝。

### **11. 讲讲promise all的理解**
*   **作用：** `Promise.all(iterable)` 接收一个可迭代的Promise对象集合，返回一个新的Promise。
*   **行为：**
    *   **全部成功：** 当所有输入的Promise都成功解决（fulfilled）时，返回的Promise才成功，结果是一个包含所有成功结果的数组，**顺序与输入一致**。
    *   **有一个失败：** 如果其中任何一个Promise失败（rejected），则返回的Promise会立即失败，原因是第一个失败的Promise的原因（“快速失败”机制）。
*   **使用场景：** 并行执行多个独立的异步操作，并且需要等待所有操作都完成才能继续，例如同时请求多个接口数据。

### **12. 哪些类型允许解构？对象为什么允许解构？解构为什么丢失响应式？**
*   **允许解构的类型：** **任何可迭代对象（Iterable）** 和 **对象**。
    *   数组、字符串、Map、Set等是可迭代的，允许数组模式解构。
    *   对象允许对象模式解构。
*   **对象为什么允许解构：** 解构是一种语法糖，它依赖于对象的属性枚举特性。引擎会根据你提供的模式（如 `{ a, b }`）去对象上查找相应的属性并赋值给变量。
*   **解构为什么丢失响应式（以Vue为例）：** Vue 3的响应式（如 `reactive`）是通过 **Proxy** 拦截对象的 **get** 和 **set** 操作实现的。当你解构一个响应式对象时，例如 `const { a, b } = reactiveObj`，你实际上是将属性 `a` 和 `b` 的**当前值**复制给了两个新的普通变量 `a` 和 `b`。它们与原始的 `reactiveObj` 失去了引用关系，因此对 `a` 或 `b` 的赋值不会触发 `reactiveObj` 的 `set` 拦截。解决方案是使用 `toRefs`：`const { a, b } = toRefs(reactiveObj)`，这样解构出来的是两个响应式的 `Ref` 对象。

### **13. js为什么计时不准确？**
*   **核心原因：** JavaScript是单线程的，计时器（`setTimeout`/`setInterval`）的回调函数需要等主线程和任务队列中的其他任务执行完毕后才能运行。
*   **具体因素：**
    1.  **事件循环机制：** 计时器设定的延迟只是“最少延迟时间”，而非“精确执行时间”。
    2.  **主线程阻塞：** 如果主线程有长时间运行的同步代码（如复杂计算），计时器回调会被阻塞。
    3.  **标签页非激活状态：** 为了节省资源，后台标签页中的计时器最小延迟会被延长（如至少1秒）。
    4.  **系统负载：** 操作系统本身的调度也会带来微小延迟。

### **14. 如何相对准确计时？**
*   **使用 `performance.now()`：** 这个方法返回一个高精度的时间戳（精确到微秒），且不受系统时间调整的影响。适合测量时间间隔。
    ```javascript
    const start = performance.now();
    // ... 做一些操作
    const end = performance.now();
    console.log(`耗时：${end - start} 毫秒`);
    ```
*   **Web Worker：** 将精确计时的逻辑放到Worker中，避免受主线程阻塞的影响。
*   **`requestAnimationFrame`：** 对于动画相关的计时，使用 `rAF` 可以获得与屏幕刷新率同步的、相对平滑的计时。

### **15. ts的any unknown null什么区别**
*   **`any`：** 最高等级的类型，相当于放弃了类型检查。可以对 `any` 类型的变量进行任何操作（访问属性、调用方法）而不会引起编译错误。**不安全**。
*   **`unknown`：** 顶级类型，但比 `any` 安全。你不能对 `unknown` 类型的变量进行任意操作（如直接调用方法），必须先进行类型检查（类型收窄）后才能使用。
    ```typescript
    let value: unknown;
    value = ‘hello’;
    // (value as string).toUpperCase(); // 需要类型断言
    if (typeof value === ‘string’) { // 类型收窄
        value.toUpperCase();
    }
    ```
*   **`null`：** 是一个具体的字面量类型，表示“空值”。它是所有其他类型的子类型（在 `strictNullChecks` 关闭时）。

### **16. ts如何处理any？**
*   **目标：** 在项目中尽量避免使用 `any`，以充分发挥TypeScript的优势。
*   **处理方法：**
    1.  **显式定义类型：** 优先为变量、函数参数和返回值定义明确的接口或类型别名。
    2.  **类型推断：** 充分利用TS的类型推断，不写不必要的类型注解。
    3.  **类型断言（`as`）：** 当你比TS更清楚值的类型时，使用断言，但需谨慎。
    4.  **使用 `unknown` 替代 `any`：** 当你确实无法确定类型时，先用 `unknown`，然后通过类型守卫来安全地使用它。
    5.  **使用泛型：** 编写可复用的通用代码时，使用泛型来保持类型信息。
    6.  **启用严格模式：** 开启 `noImplicitAny` 等严格选项，强制要求显式类型。

### **17. interface和type区别**
| 特性 | `interface` | `type` (类型别名) |
| :--- | :--- | :--- |
| **扩展** | 使用 `extends`： `interface A extends B {}` | 使用 `&`（交叉类型）： `type A = B & C` |
| **实现** | 可以被类 `implements` | 不能被类 `implements` |
| **合并** | **声明合并**：同名的 `interface` 会自动合并。 | 同名的 `type` 会报错。 |
| **适用性** | 主要用于定义**对象的结构**。 | 更通用，可以定义任何类型，包括联合类型、元组、原始类型等。例如 `type MyUnion = A | B`。 |

### **18. setup代替了vue2的哪些功能？**
*   `setup` 函数是Vue 3组合式API的入口，它替代了Vue 2选项式API中的：
    1.  `data`： 使用 `ref` 或 `reactive` 声明。
    2.  `methods`： 在 `setup` 中直接声明函数。
    3.  `computed`： 使用 `computed` 函数。
    4.  `watch`： 使用 `watch` 或 `watchEffect` 函数。
    5.  `生命周期钩子`： 使用 `onMounted`、`onUpdated` 等函数。
    *   它将这些基于**选项**的组织方式，转变为基于**逻辑关注点**的、更灵活的代码组织方式。

### **19. 为什么vue3使用ref，reactive就可以声明一个引用类型，但是在vue2里就要写在data里？**
*   **Vue 2 的机制：** Vue 2 使用 `Object.defineProperty` 来拦截数据的 getter/setter。它只能在**初始化时**递归遍历 `data` 函数返回的对象，为其属性添加响应式。因此，你必须将所有需要响应式的数据预先声明在 `data` 中，否则后续添加的新属性不会是响应式的（除非使用 `Vue.set`）。
*   **Vue 3 的机制：** Vue 3 使用 `Proxy` 进行响应式代理。`Proxy` 可以拦截整个对象的各种操作，包括**动态添加或删除属性**。因此，无论是用 `reactive` 包装一个对象，还是用 `ref` 包装一个值（`ref` 的内部值如果是对象，实际上也是用 `reactive` 处理的），都能提供深度的、动态的响应式能力，无需预先声明所有属性。

### **20. 如何捕获组件异常，比如crash的情况？**
*   同第7题。使用 **Vue的 `errorHandler`** 或 **React的 `Error Boundary`**。

### **21. 如何实现模板引擎？参考vue聊聊思路**
*   **核心思路：** 将模板字符串编译成可执行的JavaScript代码（渲染函数）。
*   **参考Vue的简化步骤：**
    1.  **解析：** 使用正则表达式或状态机将模板字符串解析成**抽象语法树**。这个过程会识别出模板中的静态文本、动态绑定（`{{}}`）、指令（`v-if`， `v-for`）、标签等。
    2.  **转换/优化：** 对AST进行遍历和处理。Vue会在此阶段标记静态节点，以便在后续更新中跳过它们，优化性能。
    3.  **代码生成：** 将AST递归地拼接成字符串形式的JavaScript函数代码。这个函数通常叫 `render` 函数，它返回一个虚拟DOM树。
        *   例如，`<div>{{ name }}</div>` 可能被编译成：`_c(‘div’, [_v(_s(name))])`（其中 `_c` 是 `createElement`， `_v` 是创建文本节点， `_s` 是 `toString`）。
    4.  **执行：** 使用 `new Function` 将生成的代码字符串转换成真正的JS函数。当组件渲染时，调用这个 `render` 函数，传入数据（响应式数据），函数会执行并返回一个描述页面结构的虚拟DOM对象。
    5.  **挂载与更新：** 将虚拟DOM与真实DOM进行对比（Diff算法），并最小化地更新真实DOM。

---

**总结：** 这份面试题考察了前端工程师的**深度（Vue/TS原理）**、**广度（适配、监控、Worker）** 和**解决实际问题的能力（AI对话、歌词、大屏）**。虽然结果是“凉经”，但能回答出这些问题中的大部分，已经是非常优秀的候选人了。继续查漏补缺，尤其是原理和设计思路方面，下次一定能成功！

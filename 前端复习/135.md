好的，这些都是很经典的面试题，我来为你详细解答。

## 1. TS 泛型用法

TypeScript 泛型让组件可以支持多种类型，提高代码复用性和类型安全。

```typescript
// 基础泛型
function identity<T>(arg: T): T {
    return arg;
}

// 使用
const output1 = identity<string>("hello"); // 显式指定类型
const output2 = identity("hello"); // 类型推断

// 泛型约束
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length); // 现在可以访问length属性
    return arg;
}

// 泛型接口
interface GenericIdentityFn<T> {
    (arg: T): T;
}

// 泛型类
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

// 在React中的使用
interface ListProps<T> {
    items: T[];
    renderItem: (item: T) => React.ReactNode;
}

function List<T>({ items, renderItem }: ListProps<T>) {
    return (
        <div>
            {items.map((item, index) => (
                <div key={index}>{renderItem(item)}</div>
            ))}
        </div>
    );
}

// 使用
<List<{ id: number; name: string }>
    items={[{ id: 1, name: 'John' }]}
    renderItem={(item) => <span>{item.name}</span>}
/>
```

## 2. 数组方法及手写reduce

### 常用数组方法
```javascript
const arr = [1, 2, 3, 4, 5];

// 1. map - 映射新数组
const doubled = arr.map(x => x * 2); // [2, 4, 6, 8, 10]

// 2. filter - 过滤
const evens = arr.filter(x => x % 2 === 0); // [2, 4]

// 3. find - 查找元素
const found = arr.find(x => x > 3); // 4

// 4. findIndex - 查找索引
const index = arr.findIndex(x => x > 3); // 3

// 5. some - 是否有满足条件的
const hasEven = arr.some(x => x % 2 === 0); // true

// 6. every - 是否都满足条件
const allPositive = arr.every(x => x > 0); // true

// 7. includes - 是否包含
const hasThree = arr.includes(3); // true

// 8. slice - 切片（不改变原数组）
const part = arr.slice(1, 3); // [2, 3]

// 9. splice - 删除/添加（改变原数组）
const removed = arr.splice(1, 2); // 返回被删除的 [2, 3]

// 10. reduce - 累加器
const sum = arr.reduce((acc, cur) => acc + cur, 0); // 15
```

### 手写实现reduce
```javascript
// 手写Array.prototype.reduce
Array.prototype.myReduce = function(callback, initialValue) {
    if (this == null) {
        throw new TypeError('Array.prototype.myReduce called on null or undefined');
    }
    
    if (typeof callback !== 'function') {
        throw new TypeError(callback + ' is not a function');
    }
    
    const array = Object(this);
    const length = array.length >>> 0; // 转换为无符号32位整数
    
    let accumulator;
    let startIndex = 0;
    
    // 处理初始值
    if (arguments.length >= 2) {
        accumulator = initialValue;
    } else {
        // 没有初始值，取第一个元素作为初始值
        if (length === 0) {
            throw new TypeError('Reduce of empty array with no initial value');
        }
        
        let found = false;
        for (let i = 0; i < length; i++) {
            if (i in array) {
                accumulator = array[i];
                startIndex = i + 1;
                found = true;
                break;
            }
        }
        if (!found) {
            throw new TypeError('Reduce of empty array with no initial value');
        }
    }
    
    // 遍历执行回调
    for (let i = startIndex; i < length; i++) {
        if (i in array) {
            accumulator = callback(accumulator, array[i], i, array);
        }
    }
    
    return accumulator;
};

// 测试
const arr = [1, 2, 3, 4, 5];
const sum = arr.myReduce((acc, cur) => acc + cur, 0); // 15
const max = arr.myReduce((acc, cur) => Math.max(acc, cur), -Infinity); // 5

// 复杂使用：数组转对象
const people = [
    { id: 1, name: 'Alice' },
    { id: 2, name: 'Bob' },
    { id: 3, name: 'Charlie' }
];

const peopleMap = people.myReduce((acc, person) => {
    acc[person.id] = person;
    return acc;
}, {});
// {1: {id: 1, name: 'Alice'}, 2: {...}, 3: {...}}
```

## 3. this指向

JavaScript中this的指向取决于函数的调用方式。

```javascript
// 1. 全局环境下的this
console.log(this); // 浏览器中指向window，Node.js中指向global

// 2. 函数调用
function normalFunc() {
    console.log(this); // 严格模式下undefined，非严格模式指向window/global
}

// 3. 方法调用
const obj = {
    name: 'Alice',
    sayName() {
        console.log(this.name); // this指向obj
    }
};
obj.sayName(); // 'Alice'

// 4. 构造函数
function Person(name) {
    this.name = name; // this指向新创建的对象
}
const person = new Person('Bob');

// 5. 箭头函数
const arrowObj = {
    name: 'Charlie',
    sayName: () => {
        console.log(this.name); // this指向外层作用域的this
    },
    delayedSayName() {
        setTimeout(() => {
            console.log(this.name); // this指向arrowObj
        }, 100);
    }
};

// 6. 改变this指向的方法
function introduce(greeting) {
    console.log(`${greeting}, I'm ${this.name}`);
}

const user = { name: 'David' };

// call - 立即执行，参数逐个传递
introduce.call(user, 'Hello'); // Hello, I'm David

// apply - 立即执行，参数数组传递
introduce.apply(user, ['Hi']); // Hi, I'm David

// bind - 返回新函数，延迟执行
const boundIntroduce = introduce.bind(user, 'Hey');
boundIntroduce(); // Hey, I'm David

// 7. 实际应用场景
class Button {
    constructor(text) {
        this.text = text;
        this.element = document.createElement('button');
        this.element.textContent = text;
        
        // 错误：this指向button元素，不是Button实例
        // this.element.addEventListener('click', this.handleClick);
        
        // 正确：使用bind或箭头函数
        this.element.addEventListener('click', this.handleClick.bind(this));
        // 或
        this.element.addEventListener('click', () => this.handleClick());
    }
    
    handleClick() {
        console.log(`Button ${this.text} clicked`);
    }
}
```

## 4. 二叉树每层最大节点

```javascript
class TreeNode {
    constructor(val = 0, left = null, right = null) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}

// 方法1：BFS广度优先搜索（层序遍历）
function largestValuesBFS(root) {
    if (!root) return [];
    
    const result = [];
    const queue = [root];
    
    while (queue.length > 0) {
        const levelSize = queue.length;
        let maxVal = -Infinity;
        
        // 遍历当前层的所有节点
        for (let i = 0; i < levelSize; i++) {
            const node = queue.shift();
            maxVal = Math.max(maxVal, node.val);
            
            // 将下一层节点加入队列
            if (node.left) queue.push(node.left);
            if (node.right) queue.push(node.right);
        }
        
        result.push(maxVal);
    }
    
    return result;
}

// 方法2：DFS深度优先搜索
function largestValuesDFS(root) {
    const result = [];
    
    function dfs(node, level) {
        if (!node) return;
        
        // 如果是当前层的第一个节点，直接添加
        if (level === result.length) {
            result.push(node.val);
        } else {
            // 否则比较并更新最大值
            result[level] = Math.max(result[level], node.val);
        }
        
        // 递归遍历左右子树
        dfs(node.left, level + 1);
        dfs(node.right, level + 1);
    }
    
    dfs(root, 0);
    return result;
}

// 测试用例
const root = new TreeNode(1);
root.left = new TreeNode(3);
root.right = new TreeNode(2);
root.left.left = new TreeNode(5);
root.left.right = new TreeNode(3);
root.right.right = new TreeNode(9);

/*
       1
      / \
     3   2
    / \   \
   5   3   9
*/

console.log(largestValuesBFS(root)); // [1, 3, 9]
console.log(largestValuesDFS(root)); // [1, 3, 9]

// 更复杂的测试用例
const complexRoot = new TreeNode(10);
complexRoot.left = new TreeNode(5);
complexRoot.right = new TreeNode(15);
complexRoot.left.left = new TreeNode(3);
complexRoot.left.right = new TreeNode(7);
complexRoot.right.left = new TreeNode(12);
complexRoot.right.right = new TreeNode(20);
complexRoot.left.left.left = new TreeNode(1);

/*
          10
        /    \
       5      15
      / \    /  \
     3   7  12  20
    /
   1
*/

console.log(largestValuesBFS(complexRoot)); // [10, 15, 20, 1]

// 性能对比和选择建议：
// - BFS使用队列，适合获取每层完整信息
// - DFS使用递归栈，代码简洁，适合深度较大的树
// - 时间复杂度都是O(n)，空间复杂度最坏情况都是O(n)
```

这些题目涵盖了TypeScript、JavaScript核心概念和算法思维，都是前端面试中的高频考点。理解这些概念并能够手写实现，会大大提升你的面试成功率！

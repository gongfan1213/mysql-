https://javaguide.cn/high-availability/limit-request.html

# 服务限流详解
## 一、服务限流的核心定义与价值
### 1. 基本概念
限流是对软件系统的请求速率进行限制，避免瞬时大量请求超出系统处理能力，导致系统宕机。由于软件系统处理能力有限，限流需在“用户请求处理”与“系统稳定性”间权衡——可能导致部分请求无法处理或延迟处理，但这是保障系统高可用的最优解。

### 2. 生活场景类比
现实中排队买票、景区限流等场景，本质是通过控制“请求进入速率”避免服务提供方（售票员、景区设施）过载，与软件系统限流逻辑一致。


## 二、常见限流算法
### 1. 固定窗口计数器算法
#### 原理
将时间划分为**固定大小的窗口**（如1分钟），通过计数器`counter`记录窗口内请求数量，当请求数达到阈值时拒绝后续请求，窗口结束后重置计数器。  
示例：限制某接口1分钟最多处理33次请求——1分钟窗口内`counter`每处理1次请求+1，`counter=33`时拒绝新请求，1分钟后`counter`重置为0。

#### 优缺点
- **优点**：实现简单、易于理解。  
- **缺点**：  
  - 限流不平滑：若前30秒用完30次请求额度，后30秒无请求可处理，用户体验差；  
  - 无法应对突发流量：如1分钟限1000次请求，前55秒无请求，后1秒涌入1000次请求，瞬时过载会击垮系统。


### 2. 滑动窗口计数器算法
#### 原理
固定窗口算法的升级版，核心是将时间窗口**按比例分片**（如1分钟划分为60个1秒子窗口），窗口每隔1个分片时间“滑动”一次，统计当前窗口内所有子窗口的请求总数，超过阈值则限流。  
示例：1分钟限60次请求→划分为60个1秒子窗口，每个子窗口最多处理1次请求，滑动时实时统计总请求数。

#### 关键特性
- 子窗口划分越多，窗口滚动越平滑，限流统计越精确。

#### 优缺点
- **优点**：相比固定窗口，能应对突发流量，限流颗粒度更细、控制更精确。  
- **缺点**：仍存在限流不平滑问题，且实现与理解难度高于固定窗口。


### 3. 漏桶算法
#### 原理
类比“注水到漏桶”：请求（水）以任意速率流入桶中，系统以**固定速率**从桶中取出请求处理；若桶满（请求超出桶容量），多余请求直接丢弃，确保处理速率稳定。  
实现方式：用队列存储请求，定期从队列中取出请求执行（与消息队列削峰/限流逻辑一致）。

#### 优缺点
- **优点**：实现简单，能稳定控制处理速率，避免网络拥塞。  
- **缺点**：无法应对突发流量（只能固定速率处理），资源利用率低；若请求流入速率持续大于处理速率，桶会一直满，大量请求被丢弃，服务质量下降。  
- **应用现状**：实际业务中极少使用。


### 4. 令牌桶算法
#### 原理
桶中存储“令牌”，系统按**固定速率**向桶中添加令牌（桶满则不再添加）；请求需先从桶中获取1个令牌才能被处理，处理后令牌丢弃。若桶中无令牌，请求需等待或被拒绝。

#### 优缺点
- **优点**：既能限制平均处理速率，又能应对突发流量（桶中积累的令牌可快速处理短期激增请求）；支持动态调整令牌生成速率。  
- **缺点**：令牌生成速率与桶容量需合理配置，否则可能导致大量请求丢弃或系统过载；实现与理解难度高于前两种算法。


## 三、限流对象选择（针对什么限流？）
实际项目需根据业务场景确定限流对象，常见类型如下：

| 限流对象       | 核心逻辑                                                                 | 注意事项                                                                 |
|----------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|
| IP地址         | 按请求来源IP限制速率，适用面广、实现简单                                 | 需正确获取用户真实IP（常用`X-Forwarded-For`或TCP Options字段，`X-Forwarded-For`可能被伪造） |
| 业务ID         | 按唯一业务标识（如用户ID、订单ID）限流，针对性更强                       | 需确保业务ID唯一，避免重复或冲突                                         |
| 个性化策略     | 按用户属性（如VIP用户不限流、普通用户限流）或系统指标（QPS、负载）动态调整 | 需结合业务分层逻辑，避免过度限制核心用户                                 |
| 进阶维度（Sentinel） | 基于调用关系（调用方、调用链入口、关联流量）或热点参数（实时统计高频参数并限流） | 需依赖专业框架（如Sentinel），适合复杂分布式场景                         |

**备注**：可多种限流对象搭配使用，满足复杂业务需求。


## 四、单机限流实现（单体架构）
单机限流针对单体应用，核心是利用成熟工具类或框架快速落地，常见方案如下：

### 1. Google Guava RateLimiter
#### 核心特性
- 基于令牌桶算法，支持“平滑突发限流”和“平滑预热限流”两种模式。  
- 依赖简单：仅需引入Guava依赖，开箱即用。

#### 依赖引入
```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>31.0.1-jre</version>
</dependency>
```

#### 代码示例
- **平滑突发限流**：按固定速率生成令牌，无预热期。
  ```java
  import com.google.common.util.concurrent.RateLimiter;

  public class RateLimiterDemo {
      public static void main(String[] args) {
          // 1秒生成5个令牌（即0.2秒生成1个）
          RateLimiter rateLimiter = RateLimiter.create(5);
          for (int i = 0; i < 10; i++) {
              // 获取1个令牌，返回等待时间（秒）
              double sleepingTime = rateLimiter.acquire(1);
              System.out.printf("get 1 tokens: %ss%n", sleepingTime);
          }
      }
  }
  ```
  输出（等待时间接近0.2秒，体现固定速率）：
  ```
  get 1 tokens: 0.0s
  get 1 tokens: 0.188413s
  get 1 tokens: 0.197811s
  ...
  ```

- **平滑预热限流**：设置预热期，令牌生成速率逐渐提升至目标速率。
  ```java
  import com.google.common.util.concurrent.RateLimiter;
  import java.util.concurrent.TimeUnit;

  public class RateLimiterDemo {
      public static void main(String[] args) {
          // 1秒生成5个令牌，预热期3秒（前3秒速率逐步提升至目标）
          RateLimiter rateLimiter = RateLimiter.create(5, 3, TimeUnit.SECONDS);
          for (int i = 0; i < 20; i++) {
              double sleepingTime = rateLimiter.acquire(1);
              System.out.printf("get 1 tokens: %sds%n", sleepingTime);
          }
      }
  }
  ```
  输出（前几次等待时间长，逐步缩短至0.2秒）：
  ```
  get 1 tokens: 0.0s
  get 1 tokens: 0.561919s
  get 1 tokens: 0.516931s
  ...
  get 1 tokens: 0.198359s
  ```


### 2. 其他单机限流工具
- **Bucket4j**：基于令牌桶/漏桶算法，支持单机/分布式限流，可集成Prometheus+Grafana监控，功能比Guava更全面。  
- **Resilience4j**：轻量级容错框架（替代Hystrix），支持限流、熔断、重试等功能，生态完善（如适配Spring Cloud Gateway），适合需同时实现限流与熔断的场景。  
- **选择建议**：简单场景用Guava，复杂场景（需监控、容错）用Resilience4j或Bucket4j。


## 五、分布式限流实现（分布式/微服务架构）
分布式架构下，服务多实例部署，单机限流失效，需通过“中间件协同”或“网关统一控制”实现全局限流，常见方案如下：

### 1. 基于中间件限流
#### （1）Redis+Lua实现
- **核心优势**：  
  - 减少网络开销：Lua脚本批量执行Redis命令，降低客户端与Redis的通信次数；  
  - 保证原子性：Lua脚本作为单个命令执行，避免并发场景下的计数误差。  
- **实践参考**：Apache ShenYu网关的RateLimiter插件，基于Redis+Lua实现了令牌桶、漏桶、滑动窗口等算法，可直接参考其脚本逻辑。

#### （2）Redisson RRateLimiter
- **核心特性**：Redisson（Java Redis客户端）内置的分布式限流器，底层基于Lua+令牌桶算法，支持单机/集群/哨兵模式，开箱即用。  
- **代码示例**：
  ```java
  import org.redisson.Redisson;
  import org.redisson.api.RRateLimiter;
  import org.redisson.api.RateIntervalUnit;
  import org.redisson.api.RateType;
  import org.redisson.api.RedissonClient;

  public class RedissonRateLimiterDemo {
      public static void main(String[] args) {
          // 创建Redisson客户端
          RedissonClient redissonClient = Redisson.create();
          // 获取限流器（名称唯一，全局限流标识）
          RRateLimiter rateLimiter = redissonClient.getRateLimiter("javaguide.limiter");
          // 设置限流规则：全局限流，每小时100次请求
          rateLimiter.trySetRate(RateType.OVERALL, 100, 1, RateIntervalUnit.HOURS);

          // 方式1：阻塞等待获取1个令牌
          rateLimiter.acquire(1);
          // 方式2：5秒内尝试获取1个令牌，成功返回true，失败返回false
          boolean success = rateLimiter.tryAcquire(1, 5, java.util.concurrent.TimeUnit.SECONDS);
      }
  }
  ```


### 2. 网关层限流
#### 核心逻辑
在网关（如Spring Cloud Gateway、APISIX）统一拦截所有请求，通过集成中间件或框架实现限流，避免限流逻辑散落在各服务中。  
#### 实践案例
- **Spring Cloud Gateway + RedisRateLimiter**：基于Redis+Lua实现分布式限流，内置`RedisRateLimiter`组件，可直接配置使用。  
- **Spring Cloud Gateway + Sentinel**：集成Sentinel网关限流模块，支持按IP、路径、参数等维度限流，且提供监控面板。


## 六、总结
服务限流是保障系统高可用的核心手段，需结合架构类型（单体/分布式）选择合适方案：  
1. **算法选择**：简单场景用固定/滑动窗口，需应对突发流量用令牌桶（避免用漏桶）；  
2. **单机限流**：优先用Guava（简单）或Resilience4j（复杂容错）；  
3. **分布式限流**：优先用Redis+Lua（灵活）或Redisson（开箱即用），或通过网关层统一控制；  
4. **限流对象**：根据业务需求选择IP、业务ID或个性化策略，复杂场景可结合Sentinel的进阶维度。


## 七、参考资料
1. 服务治理之轻量级熔断框架 Resilience4j：[https://xie.infoq.cn/article/14786e571c1a4143ad1ef8f19](https://xie.infoq.cn/article/14786e571c1a4143ad1ef8f19)  
2. 超详细的 Guava RateLimiter 限流原理解析：[https://cloud.tencent.com/developer/article/1408819](https://cloud.tencent.com/developer/article/1408819)  
3. 实战 Spring Cloud Gateway 之限流篇：[https://www.aneasystone.com/archives/2020/08/spring-cloud-gateway-current-limiting.html](https://www.aneasystone.com/archives/2020/08/spring-cloud-gateway-current-limiting.html)  
4. 详解 Redisson 分布式限流的实现原理：[https://juejin.cn/post/7199882882138898489](https://juejin.cn/post/7199882882138898489)  
5. 一文详解 Java 限流接口实现 - 阿里云开发者：[https://mp.weixin.qq.com/s/A5VYjstIDeVvizNK2HkrTQ](https://mp.weixin.qq.com/s/A5VYjstIDeVvizNK2HkrTQ)  
6. 分布式限流方案的探索与实践 - 腾讯云开发者：[https://mp.weixin.qq.com/s/MJbEQROGlThrHSwCjYB_4Q](https://mp.weixin.qq.com/s/MJbEQROGlThrHSwCjYB_4Q)

https://www.cnblogs.com/crazymakercircle/p/10225159.html

# Java NIO底层原理网页总结
## 一、Java IO读写核心原理
### （一）核心缓冲区机制
1. **两类缓冲区**：操作系统有**内核缓冲区**，每个进程有独立的**进程缓冲区**，二者分工明确。
2. **缓冲区作用**：减少频繁系统IO调用，降低进程数据/状态保存与恢复的性能损耗，待缓冲区数据达一定量再进行实际IO操作，提升效率。
3. **系统调用本质**：read系统调用是将数据从内核缓冲区复制到进程缓冲区，write系统调用是将数据从进程缓冲区复制到内核缓冲区，均不负责内核缓冲区与磁盘间的数据交换，该交换由操作系统kernel内核完成。

### （二）Java IO读写底层流程（以服务端处理网络请求为例）
1. 客户端请求：Linux通过网卡读取客户端请求数据，存入内核缓冲区。
2. 获取请求数据：服务器将内核缓冲区数据读取到Java进程缓冲区。
3. 业务处理：Java服务端在用户空间处理客户端请求。
4. 准备返回数据：Java服务端将构建好的响应从用户缓冲区写入系统（内核）缓冲区。
5. 发送响应：Linux内核通过网络IO，将内核缓冲区数据写入网卡，网卡按底层通讯协议发送给客户端。

## 二、四种核心IO模型
|模型名称|核心特点|关键流程|优缺点|适用场景|
|----|----|----|----|----|
|**同步阻塞IO（BIO）**|用户空间程序需等待内核IO操作彻底完成才返回，用户线程在IO两阶段（数据准备、数据复制）均阻塞；默认Java socket为阻塞模式|1. 用户线程调用read，内核等待数据准备；2. 数据就绪后，内核将数据从内核缓冲区复制到用户缓冲区；3. 内核返回结果，用户线程解除阻塞|优点：程序简单，阻塞时用户线程基本不占CPU资源<br>缺点：高并发下需大量线程维护连接，内存、线程切换开销大|并发量小的场景|
|**同步非阻塞IO（NIO）**|用户程序无需等待内核IO操作完成，内核立即返回状态值；需将socket设为NONBLOCK模式|1. 内核数据未准备时，用户线程调用IO立即返回失败；2. 内核数据就绪后，用户线程调用IO会阻塞，内核复制数据；3. 复制完成，用户线程解除阻塞|优点：用户线程不阻塞，实时性较好<br>缺点：需不断轮询发起IO系统调用，占用大量CPU时间，资源利用率低|极少直接使用，多作为其他IO模型的特性支撑|
|**IO多路复用模型**|通过select/epoll系统调用，单个线程可监视多个文件描述符，内核通知就绪连接；Java NIO（New IO）基于此模型，Linux下用epoll|1. 将目标连接注册到select/epoll可查询列表，调用select/epoll查询就绪连接，用户线程阻塞；2. 获就绪连接后，调用read，用户线程阻塞，内核复制数据；3. 复制完成，用户线程解除阻塞|优点：可同时处理成千上万个连接，无需创建/维护大量线程，系统开销小<br>缺点：select/epoll属同步IO，读写过程仍阻塞|高并发网络编程（如Java NIO应用）|
|**异步IO（AIO）**|用户线程告知内核启动IO操作后即返回，内核完成数据准备与复制后通知用户线程；又称信号驱动IO|1. 用户线程调用read后去做其他事，不阻塞；2. 内核等待数据准备，就绪后复制到用户缓冲区；3. 内核发信号/回调通知用户线程，用户线程处理数据|优点：用户线程在IO两阶段均不阻塞，效率理论最优<br>缺点：需底层OS大量支持，Linux 2.6后才引入且不完善|Windows下高并发场景（Linux下少用）|

## 三、关键总结与补充
1. **模型效率对比**：理论上，四种模型阻塞程度依次降低，效率依次提升；前三种属同步IO（读写操作阻塞线程），仅AIO是真正异步IO。
2. **Java NIO澄清**：Java NIO（New IO）并非同步非阻塞NIO模型，而是基于IO多路复用模型实现。
3. **文档补充信息**：本文为“疯狂创客圈”高并发实战基础篇，后续有分布式协调、分布式网关等系列文章；提供《尼恩Java面试宝典》《Java高并发核心编程》等多本免费学习资源，可从语雀、码云获取更新版。

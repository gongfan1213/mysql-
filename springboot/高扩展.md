好的，我们来深入解析 Redis 高可用与高扩展的三大核心架构：主从复制、哨兵模式 和 Redis Cluster。这是面试中考察你对 Redis 理解深度的关键环节。

---

### 一、 主从复制

主从复制是 Redis 实现高可用的基础，它解决了**数据备份**和**读请求负载均衡**的问题。

#### 核心概念
- **主节点**：负责接收所有写请求。
- **从节点**：是主节点的数据副本，负责接收读请求。一个主节点可以有多个从节点。

#### 复制原理（核心面试题）

Redis 主从复制主要分为两个阶段：**全量同步** 和 **增量同步**。

**1. 建立连接与身份验证**
- 从节点启动后，通过 `replicaof <masterip> <masterport>` 命令与主节点建立连接。
- 如果主节点设置了密码，从节点需要发送认证信息。

**2. 全量同步**
这个过程发生在从节点第一次连接主节点，或者从节点落后的数据太多时。
1.  **从节点请求同步**。
2.  **主节点执行 `bgsave`**：在后台生成当前数据的 RDB 快照文件。
3.  **主节点缓存写命令**：在生成 RDB 文件期间，主节点依然会接收新的写命令，并将其缓存到内存的 **复制缓冲区** 中。
4.  **发送 RDB 文件**：RDB 文件生成后，主节点将其发送给从节点。
5.  **从节点清空旧数据并加载 RDB**：从节点先清空自身数据，然后加载主节点传送来的 RDB 文件，使自身状态基本与主节点一致。
6.  **发送缓冲区的写命令**：主节点将复制缓冲区中积压的写命令发送给从节点。
7.  **从节点执行这些命令**：从节点执行这些命令，最终达到与主数据库完全同步的状态。

**3. 增量同步**
全量同步完成后，就进入了增量同步阶段。
- 主节点每执行一个写命令，都会异步地将其发送给所有从节点。
- 从节点接收并执行这些命令，从而保持与主节点的实时同步。

**复制偏移量与复制缓冲区**
- **复制偏移量**：主从节点都会维护一个偏移量（offset）。主节点每次传播 N 个字节的数据，偏移量就增加 N。从节点每次收到 N 个字节，偏移量也增加 N。通过对比偏移量，可以判断主从数据是否一致。
- **复制缓冲区**：一个环形的内存缓冲区，用于存储主节点最近传播的写命令。当从节点短暂断线重连后，如果它要求的偏移量之后的数据还在缓冲区中，主节点就会只发送这部分增量数据，避免了全量同步的巨大开销。如果缓冲区已满（被新命令覆盖），则只能触发全量同步。

---

### 二、 哨兵模式

主从复制模式下，如果主节点宕机，需要**手动**将一个从节点提升为主节点，并修改应用配置，这无法实现真正的高可用。**哨兵模式就是为了解决自动故障转移而生的**。

#### 核心概念
**Redis Sentinel** 是一个分布式系统，由一个或多个 Sentinel 实例组成，用于监控 Redis 主从服务器的健康状态。当主节点发生故障时，它能**自动完成故障发现和故障转移**，并通知客户端新的主节点地址。

#### 工作原理

**1. 监控**
- 每个 Sentinel 节点会定期（每秒一次）向所有被监控的主节点、从节点和其他 Sentinel 节点发送 PING 命令。
- 如果某个实例在配置的毫秒数内没有有效回复，它就会被 Sentinel **主观下线**。

**2. 判定主节点客观下线**
- 当一个 Sentinel 将一个主节点判断为主观下线后，它会向其他 Sentinel 节点发送命令，询问它们是否也认为该主节点下线了。
- 如果达到一定数量（通常由 quorum 参数配置，如 2/3 多数）的 Sentinel 都报告主节点主观下线，则该主节点被标记为 **客观下线**。这是触发自动故障转移的前提。

**3. 选举 Leader Sentinel**
- 确认主节点客观下线后，所有 Sentinel 节点会通过 **Raft 算法** 选举出一个 **Leader Sentinel** 来负责本次故障转移。这保证了只有一个 Sentinel 来执行故障转移。

**4. 故障转移**
由 Leader Sentinel 执行：
1.  **筛选新主节点**：它会从原主节点的从节点列表中，选择一个数据最完整（复制偏移量最大）、运行稳定的从节点。
    > **筛选规则**：优先考虑 `slave-priority` 配置低的、复制偏移量大的、Run ID 小的。
2.  **提升新主**：向选中的从节点发送 `slaveof no one` 命令，使其提升为主节点。
3.  **让其他从节点指向新主**：向其他所有从节点发送 `slaveof <new_master_ip> <new_master_port>` 命令，让它们成为新主节点的从节点。
4.  **通知客户端**：Sentinel 会将原主节点标记为从节点（待其恢复后，会命令它成为新主的从节点），并**向客户端发布新的主节点地址**。

**5. 客户端连接**
- 客户端不是直接连接 Redis 节点，而是连接 Sentinel 集群。
- 客户端通过 Sentinel 询问当前的主节点地址，并在发生故障转移后，从 Sentinel 获取到新的主节点地址，实现自动切换。

---

### 三、 Redis Cluster 分片

当数据量巨大或写请求压力远超单机能力时，哨兵模式（主从+读写分离）也无能为力。**Redis Cluster 的核心目标是实现数据分片和水平扩展**。

#### 核心概念
Redis Cluster 是一个去中心化的集群，数据被**自动分片**到多个节点上。每个节点都持有部分数据，并且节点之间通过 **Gossip 协议** 进行通信。

#### 数据分片与哈希槽

- **哈希槽**：Redis Cluster 没有使用一致性哈希，而是引入了 **哈希槽** 的概念。整个集群有 **16384** 个槽。
- **数据映射**：对每个 Key，通过 `CRC16(key) mod 16384` 计算它应该属于哪个槽。
- **槽的分配**：管理员可以将这 16384 个槽分配给集群中的任意主节点。例如，一个 3 主节点的集群，可以这样分配：
    - 节点 A： 0 - 5500 槽
    - 节点 B： 5501 - 11000 槽
    - 节点 C： 11001 - 16383 槽
- **优点**：这种设计使得**添加或移除节点非常方便**，只需要将部分哈希槽从一个节点移动到另一个节点即可，而不需要将整个数据集重新哈希。

#### 集群节点与请求路由

**1. 节点角色**
- 每个节点都保存着整个集群的元数据：`集群状态`、`每个节点负责的哈希槽`、`所有节点的信息`。
- 客户端可以连接集群中的任意节点来发起请求。

**2. 请求路由**
- **直连正确节点**：如果客户端向节点 A 请求一个 Key，且该 Key 的槽正好由 A 负责，则 A 直接处理。
- **重定向**：如果客户端向节点 A 请求了一个不属于它的 Key（例如，Key 的槽在节点 B 上），节点 A 会向客户端返回一个 **MOVED** 错误，并告知正确的节点 B 的地址。
    - 智能客户端（如 JedisCluster、Lettuce）会缓存这个 `槽 -> 节点` 的映射关系，下次请求相同槽的 Key 时，会直接发往正确的节点。

#### 高可用与故障转移

Redis Cluster 内置了类似 Sentinel 的故障发现和转移能力。

- **主从模式**：集群中每个主节点都应该有一个或多个从节点。
- **故障发现**：节点间通过 Gossip 协议互相发送 PING/PONG 消息检测健康状态。当某个主节点被大多数主节点认为失联时，它被标记为 **FAIL** 状态。
- **故障转移**：当主节点被标记为 FAIL 后，它的一个从节点会被集群自动提升为新的主节点（选举过程类似于 Sentinel，基于配置纪元、偏移量等）。
- **集群可用性**：只要**每个主节点和它的从节点不同时宕机**，并且**大多数主节点都正常运行**，集群就是可用的。

### 总结与对比

| 特性 | 主从复制 | 哨兵模式 | Redis Cluster |
| :--- | :--- | :--- | :--- |
| **核心目标** | 数据备份、读写分离 | **高可用**、自动故障转移 | **水平扩展**、高可用、数据分片 |
| **数据模式** | 全量数据副本 | 全量数据副本 | 数据分片，每个节点存部分数据 |
| **写能力** | 单机写，有瓶颈 | 单机写，有瓶颈 | 多机并行写，水平扩展 |
| **故障转移** | 手动 | **自动** | **自动** |
| **复杂度** | 低 | 中 | 高 |

**面试回答建议**：
- 从简单到复杂，清晰地阐述三种架构的演进关系。
- 重点描述 **主从复制的全量/增量同步过程**、**哨兵的客观下线和故障转移流程**、**Cluster 的哈希槽分片和重定向机制**。
- 明确说出它们的适用场景：主从用于基础备份和读扩展，哨兵用于高可用，Cluster 用于大数据量和写扩展。

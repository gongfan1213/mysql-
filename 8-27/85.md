# MySQL 分页有什么性能问题？怎么优化？
大家好，我是小林。

最近有同学面试字节三面的时候，被问到：“**MySQL 分页有什么性能问题？怎么优化？** ”

今天就主要围绕这个问题跟大家说一下 MySQL 分页问题和优化的思路。

> 原文地址：[字节三面：MySQL 分页怎么优化啊？(opens new window)]() 

我们刷网站的时候，经常会遇到需要分页查询的场景，比如网页中的翻页功能（此处原文有图片展示翻页功能）。这类需求很容易用 MySQL 实现，假设建表 SQL 如下（此处原文有建表 SQL 截图），核心信息是**id 是主键，且在 user_name 字段上建立了非主键索引**，其他字段细节无需关注。

为实现分页，常见的 SQL 语句格式为：
```text
select * from page order by id limit offset, size;
```
比如一页展示 10 条数据（此处原文有分页示例图片），第一页的 SQL 为：
```text
select * from page order by id limit 0, 10;
```
第一百页的 SQL 为：
```text
select * from page order by id limit 990, 10;
```

这里就有一个关键问题：**同样都是获取 10 条数据，查询第一页和第一百页的速度是否一样？为什么？**


## 两种 limit 的执行过程
上述查询对应 `limit offset, size` 和 `limit size` 两种方式，其中 `limit size` 等价于 `limit 0, size`，二者的核心区别在于 `offset` 是否为 0。要理解性能差异，需先明确 MySQL 内部分层结构：**server 层**（包含执行器、优化器等组件）和**存储引擎层**（常用 InnoDB），执行器通过调用存储引擎接口获取数据，符合条件的数据会放入结果集，最终返回给客户端（此处原文有 MySQL 执行逻辑示意图）。


### 基于主键索引的 limit 执行过程
以主键索引（id 字段）为例，先对以下 SQL 执行 `explain` 分析：
```text
explain select * from page order by id limit 0, 10;
```
从 `explain` 结果可知，`key` 字段显示为 `PRIMARY`，即查询走**主键索引**。  

主键索引的本质是 B+ 树，其叶子节点存储完整的行数据，且叶子节点数据按主键 id 有序排列。结合两种分页场景分析执行过程：
1. **`limit 0, 10`（第一页）**：执行器调用 InnoDB 接口，通过主键索引直接定位到 id 最小的起始位置，连续读取 10 条完整行数据，返回给 server 层后直接放入结果集，无需额外处理。
2. **`limit 6000000, 10`（大 offset 场景）**：执行器仍通过主键索引查询，但需先从起始位置连续读取 `6000000 + 10` 条数据，返回给 server 层后，**抛弃前 6000000 条数据**，仅保留最后 10 条放入结果集。  

可见，大 `offset` 场景下，虽然最终只返回 10 条数据，但 InnoDB 需读取大量无用数据，且 server 层需额外处理“抛弃数据”的逻辑，导致性能显著下降。

针对这种情况，可通过子查询优化：
```text
select * from page where id >= (select id from page order by id limit 6000000, 1) order by id limit 10;
```
优化逻辑：子查询 `select id from page order by id limit 6000000, 1` 仅需读取 `6000000 + 1` 条数据的 **id 字段**（无需读取完整行数据，减少数据传输开销），得到第 6000001 条数据的 id；主查询通过 `id >= 该值` 直接定位到起始位置，读取后续 10 条数据，避免读取大量无用完整行。但该优化仍未解决“读取大量无用 id 数据”的问题，仅能小幅提升性能（如耗时从 3s 降至 1.5s）。


### 基于非主键索引的 limit 执行过程
以非主键索引（user_name 字段）为例，分析 SQL `select * from page order by user_name limit offset, 10` 的执行过程。  

非主键索引的 B+ 树叶子节点仅存储**主键 id**（而非完整行数据），若需获取完整行数据，需通过主键 id 再次查询主键索引，该过程称为**回表**。结合 `offset` 大小分场景分析：
1. **`offset 较小时（如 limit 0, 10）`**：执行器通过 user_name 非主键索引，读取前 10 条数据的主键 id，然后针对每个 id 回表查询主键索引，获取完整行数据，返回给 server 层后放入结果集。此场景比主键索引多了“回表”开销，但性能差异不大。
2. **`offset 极大时（如 limit 6000000, 10）`**：执行 `explain` 会发现 `type` 字段显示为 `ALL`，即**全表扫描**。原因是 server 层的优化器会判断执行代价：若通过非主键索引查询，需先读取 6000010 条数据的 id，再执行 6000010 次回表，总代价远高于“全表扫描后筛选数据”，因此优化器选择全表扫描，性能进一步恶化。

针对这种情况，可通过“子查询获取 id + 主键关联”优化：
```text
select * from page t1, (select id from page order by user_name limit 6000000, 100) t2 where t1.id = t2.id;
```
优化逻辑：子查询 `select id from page order by user_name limit 6000000, 100` 仅通过非主键索引读取 6000100 条数据的 id（无需回表），抛弃前 6000000 条后保留 100 个 id；主查询通过 `t1.id = t2.id` 关联，走主键索引查询完整行数据，避免 6000000 次无效回表。但同样未解决“读取大量无用 id 数据”的核心问题。


## 深度分页问题
当 `offset` 达到百万、千万量级时，上述性能问题会急剧恶化，这就是 MySQL 中的**深度分页问题**。需明确的是，深度分页问题**无解**，只能通过“规避需求”或“减缓问题”的思路优化，核心是反思需求合理性——为什么会产生深度分页？


### 如果你是想取出全表的数据
若需求是将 MySQL 表数据异构到 ES、Hive 等系统，直接用 `select * from page` 会因数据量过大导致超时报错，此时若用 `limit offset, size` 分批获取，会引发深度分页问题。  

优化方案：**基于主键 id 分批获取**，伪代码逻辑如下：
1. 初始化 `last_id = 0`，`batch_size = 100`；
2. 执行 `select * from page where id > last_id order by id limit batch_size`，获取一批数据；
3. 更新 `last_id` 为当前批次最大 id；
4. 重复步骤 2-3，直到无数据返回。  

该方案利用主键索引的有序性，每次通过 `id > last_id` 直接定位到起始位置，无需读取无用数据，查询性能稳定，且避免深度分页问题。


### 如果是给用户做分页展示
若需求是用户端的分页展示（如商品列表），需先和产品经理沟通需求合理性——用户几乎不会翻到 10 页以后，更不会翻到百万级页数。此时可通过“限制最大页数”或“调整分页交互”优化：
1. **限制最大返回结果数**：若用 MySQL 实现，限制查询结果不超过 1000 条（如仅支持前 100 页，每页 10 条）；若数据量较大，建议改用 ES 存储分页数据，同时限制结果数在 1 万以内，避免深度分页。
2. **调整分页交互**：不支持“跳页”（如直接跳转到第 100 页），仅支持“上一页/下一页”，结合主键 id 实现：
   - 第一页执行 `select * from page order by id limit 10`，记录当前批次最大 id 为 `max_id`；
   - 下一页执行 `select * from page where id > max_id order by id limit 10`，更新 `max_id`；
   - 上一页执行 `select * from page where id < min_id order by id desc limit 10`，再逆序排列（`min_id` 为当前批次最小 id）。  

这种交互方式避免用户直接输入大页码，从根源上杜绝深度分页问题，且查询性能稳定。


### 总结
1. `limit offset, size` 比 `limit size` 慢，且 `offset` 越大，性能越差——因为大 `offset` 会导致 InnoDB 读取大量无用数据，server 层需抛弃无用数据。
2. 深度分页问题无解，只能通过“规避需求”或“优化方案”减缓：
   - 全表数据异构：用主键 id 分批获取，避免 `offset` 过大；
   - 用户端分页展示：限制最大页数、调整交互为“仅支持上下页”，或改用 ES 存储数据。
3. 若数据量小（如 1000 条以内，且长期无大幅增长），直接用 `limit offset, size` 即可，无需过度优化。

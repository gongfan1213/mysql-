# 百度爱企查java后端实习一面面经
问了几个底层问题，主要是集合那里，然后自己介绍项目和实习经历。最后是一道手撕算法题和一道sql结尾
百度的面试时间是一小时整
先自我介绍
问八种基本数据类型
项目自己完整复述一遍所用技术栈和难点亮点等，几乎无提问
数据库事务隔离级别
说一下数据库优化的方法
提问集合类型
hashmap底层
currenthashmap了解吗
并发编程了解多少
最后手撕一道算法加一道sql
n节楼梯一次上一截或者两节问有几种方法能上楼
查询每个用户最新订单

作者：Bravo520
链接：https://www.nowcoder.com/feed/main/detail/d847ab76708c43e988dd48819c2f1944?sourceSSR=users
来源：牛客网

好的，没问题。作为专业的Java开发工程师，我会为你系统地梳理这场面试的考察点，并用面试中“讲故事”的方式，深入浅出地为你解析每个知识点，并提供高质量的代码答案。

### 面试思路总览 (Mermaid MindMap)

这场面试是典型的“基础-项目-数据库-集合-并发-手撕”结构，我们可以用以下思维导图来勾勒出完整的知识体系：

```mermaid
mindmap
  root(百度爱企查Java后端实习一面)
    (自我介绍)
      (1-2分钟)
      (技术栈亮点)
    (Java基础)
      (八种基本数据类型)
        byte, short, int, long
        float, double
        char
        boolean
      (包装类与缓存机制)
    (项目与实习)
      (技术栈: Spring, MySQL, Redis...)
      (难点: 数据库设计, 性能优化...)
      (亮点: 解决了XX问题, 达到了XX效果)
    (数据库)
      (事务隔离级别)
        READ_UNCOMMITTED
        READ_COMMITTED
        REPEATABLE_READ
        SERIALIZABLE
      (优化方法)
        (SQL优化: 索引, 避免SELECT *)
        (结构优化: 分库分表)
        (架构优化: 读写分离, 缓存)
    (Java集合)
      (HashMap)
        (底层结构: 数组+链表/红黑树)
        (核心机制: hash计算, 扩容, 树化)
      (ConcurrentHashMap)
        (演进: JDK7 Segment锁 -> JDK8 CAS+synchronized)
        (高效并发原理)
    (并发编程)
      (线程基础: 状态, 创建方式)
      (JUC包: Atomic, Lock, 线程池)
      (内存模型: JMM, volatile, synchronized)
    (手撕代码)
      (算法: 爬楼梯 (DP / 斐波那契))
        (思路: 动态规划, 状态转移方程)
        (代码: 空间优化)
      (SQL: 查询用户最新订单)
        (思路: 分组排序, 窗口函数 vs 子查询)
        (代码: ROW_NUMBER() 或 关联子查询)
```

---

### 一、自我介绍 (1-2分钟)

**面试话术：**
“面试官您好，我叫[你的名字]，目前是[你的学校][你的专业]的一名大[几]的学生。我对Java后端开发有非常浓厚的兴趣，系统学习过Java基础、Spring全家桶、MySQL、Redis等技术。

我之前在[某公司]有过一段实习经历，主要负责[简要说明工作，如：用户中心的开发与迭代]，在这个过程中，我不仅熟练使用了Spring Boot、MyBatis等框架，还实际处理了诸如[提一个亮点，如：接口性能优化、数据库分表]等问题，让我对后端开发有了更实际的理解。

业余时间我喜欢在技术社区比如GitHub、牛客网上学习和交流，也自己动手做过一些个人项目，比如[你的项目名]。我非常渴望能加入百度这样技术驱动型的公司，得到进一步的锻炼和成长。谢谢！”

**要点：** 学校背景 + 技术栈 + 项目/实习亮点 + 个人积极性 + 对公司的向往。

---

### 二、八种基本数据类型

**详细回答：**
“Java的八种基本数据类型是Java语言的基础，它们可以分为四类八种：
1.  **整型 (4种)**：`byte`（1字节）、`short`（2字节）、`int`（4字节，默认类型）、`long`（8字节，后缀用L表示）。
2.  **浮点型 (2种)**：`float`（4字节，单精度，后缀用F表示）、`double`（8字节，双精度，默认类型）。
3.  **字符型 (1种)**：`char`（2字节，采用Unicode编码，可以存储一个中文字符）。
4.  **布尔型 (1种)**：`boolean`（大小未精确定义，只有`true`和`false`两个值）。

**扩展广度 & 面试深度：**
*   **为什么要有包装类？**
    *   答：Java是面向对象的语言，基本数据类型不具备对象的特性（比如不能调用方法、不能放入集合`Collection`中）。包装类将它们包装成对象，并提供了丰富的API（如`Integer.parseInt()`）。同时也引入了**自动装箱（Autoboxing）和拆箱（Unboxing）** 的概念，简化了 coding。
*   **Integer的缓存机制了解吗？**
    *   答：这是Java5引入的一个优化。`Integer` 类内部有一个静态的`IntegerCache`类，默认会缓存`-128`到`127`之间的`Integer`对象。当我们使用`Integer.valueOf(int i)`（自动装箱默认调用此方法）时，如果值在这个范围内，会直接返回缓存中的对象，而不是新建一个。这可以节省内存，提高性能。但需要注意的是，使用`==`比较时，在这个范围内是`true`，范围外是`false`，所以**包装类的比较一定要用`equals()`方法**。

---

### 三、数据库事务隔离级别 & 优化方法

**1. 事务隔离级别：**
“数据库事务的隔离级别是为了解决多个事务并发执行时可能引发的**脏读、不可重复读、幻读**这些问题而定义的。标准SQL定义了四种级别，由低到高，并发性能由高到低分别是：
1.  **读未提交 (Read Uncommitted)**：一个事务能读到另一个事务未提交的修改。这会引发**脏读**。基本不用。
2.  **读已提交 (Read Committed)**：一个事务只能读到另一个事务已经提交的修改。这是Oracle等很多数据库的默认级别。它解决了脏读，但可能出现**不可重复读**（同一个事务内两次读取同一数据，结果不一致）。
3.  **可重复读 (Repeatable Read)**：保证在同一个事务中，多次读取同一数据的结果是一致的。这是**MySQL InnoDB引擎的默认级别**。它解决了脏读和不可重复读，但理论上可能出现**幻读**（同一事务内两次查询返回的记录数不一致）。不过InnoDB通过**MVCC（多版本并发控制）和间隙锁（Gap Lock）** 在很大程度上解决了幻读问题。
4.  **串行化 (Serializable)**：最高级别，所有事务逐个执行，完全避免并发问题，但性能损耗极大，很少使用。

**2. 数据库优化方法：**
“数据库优化是一个系统工程，我通常从以下几个层面来考虑：
*   **SQL语句优化**：
    *   **核心是索引**：使用`EXPLAIN`命令分析慢SQL，确保查询能命中索引。避免在索引列上使用函数、计算或`!=`、`NOT IN`等操作。
    *   **写法优化**：避免使用`SELECT *`，只取需要的字段；用`UNION ALL`代替`UNION`（如果确定不需要去重）；多表连接时，小表驱动大表。
*   **数据库结构优化**：
    *   **合适的字段类型**：比如`IP地址`用`INT`而非`VARCHAR`存储；字段宽度尽可能小。
    *   **范式与反范式**：适当的反范式设计（如数据冗余）可以减少表关联，用空间换时间。
*   **架构优化**：
    *   **读写分离**：主库负责写，多个从库负责读，分散压力。
    *   **分库分表**：当单表数据量过大时，进行水平拆分或垂直拆分。这是应对海量数据和高并发的终极方案之一。
*   **硬件与配置优化**：
    *   根据服务器硬件调整InnoDB的`buffer_pool_size`等参数。
*   **引入缓存**：
    *   在应用和数据库之间加入**Redis**或**Memcached**等缓存中间件，减轻数据库的读压力。”

---

### 四、集合类型：HashMap & ConcurrentHashMap

**1. HashMap底层原理：**
“好的，HashMap是面试必考点。它的底层在JDK1.8之后是`数组 + 链表 + 红黑树`的结构。
*   **put过程**：
    1.  首先对key进行hash计算（`(h = key.hashCode()) ^ (h >>> 16)`，高16位异或低16位，是为了让hash值的高位也参与路由运算，减少哈希冲突）。
    2.  根据`(n - 1) & hash`（n是数组长度）计算出这个key应该存放在数组的哪个桶（bucket）中。
    3.  如果该位置为空，直接放入Node节点。
    4.  如果不为空，则遍历链表或红黑树：
        *   如果key的hash和equals都相同，则覆盖value。
        *   如果不同，则插入到链表末尾（尾插法，JDK1.8改成了尾插，解决了1.7头插法在多线程下可能造成的死循环问题）。
    5.  插入后，如果链表长度超过8**并且**数组总长度大于64，则将链表转换为红黑树，以提高查询效率（O(n) -> O(log n)）。
*   **扩容机制**：
    *   当元素数量超过`容量 * 负载因子(默认0.75)`时，数组会扩容为原来的2倍。
    *   扩容后，会重新计算每个元素的位置。因为是2倍扩容，所以元素的新位置**要么是原位置，要么是原位置+旧容量**，非常高效。

**2. ConcurrentHashMap：**
“HashMap是线程不安全的。在并发场景下，我们使用ConcurrentHashMap。
*   **JDK1.7**：采用**分段锁（Segment）** 机制。它内部维护了一个Segment数组，每个Segment守护一个HashEntry数组。写操作只锁住对应的Segment段，其他段不受影响，实现了锁分离，提高了并发度。
*   **JDK1.8及以后**：发生了巨大变化，摒弃了分段锁，采用了 **`synchronized` + `CAS`** 的实现，粒度更细，锁的是数组的每个桶的头节点。
    *   **put过程**：
        1.  如果桶为空，使用**CAS**无锁操作插入新节点，效率极高。
        2.  如果桶不为空，则`synchronized`锁住这个桶的头节点，再进行链表或红黑树的插入操作。
    *   **优点**：锁粒度更小，并发性能更高。并且在扩容时，支持多线程协同扩容，效率更高。”

---

### 五、并发编程了解多少

**面试话术：**
“我对并发编程的理解主要围绕**Java内存模型(JMM)、线程创建与管理、以及JUC工具包**这几个方面。
*   **Java内存模型(JMM)**：它定义了线程和主内存之间的抽象关系，规定了线程间的共享变量存储在主内存，每个线程有自己的工作内存。这就引出了**可见性、原子性、有序性**这三大问题。`volatile`关键字可以保证可见性和有序性（通过内存屏障），但不保证原子性。`synchronized`和`Lock`可以保证三者。
*   **线程创建**：三种方式，继承`Thread`类、实现`Runnable`接口、实现`Callable`接口（可以获取返回值）。
*   **线程池（重点）**：这是管理和复用线程的最佳实践。核心参数有`corePoolSize`、`maximumPoolSize`、`workQueue`、`ThreadFactory`、`RejectedExecutionHandler`。处理流程是：核心池 -> 任务队列 -> 非核心池 -> 拒绝策略。常用的是`Executors`工具类提供的线程池，但阿里规范推荐手动`new ThreadPoolExecutor`，以便更精确地控制参数。
*   **JUC包**：提供了大量实用的并发工具类。
    *   `AtomicXXX`：原子类，通过CAS实现无锁的原子操作，性能高。
    *   `Lock`：显式锁，比`synchronized`更灵活，支持尝试获取锁、超时中断等。
    *   `ConcurrentHashMap`、`CopyOnWriteArrayList`等线程安全集合。
    *   `CountDownLatch`、`CyclicBarrier`、`Semaphore`等同步工具。”

---

### 六、手撕代码

#### 1. 算法题：爬楼梯 (LeetCode 70)

**题目：** 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**思路：**
“这是一道非常经典的动态规划问题。我们定义`dp[i]`为爬到第`i`阶楼梯的方法总数。
*   **状态转移方程**：要想到达第`i`阶，只能从第`i-1`阶爬1步上来，或者从第`i-2`阶爬2步上来。所以`dp[i] = dp[i-1] + dp[i-2]`。
*   **初始状态**：`dp[1] = 1`（爬1阶），`dp[2] = 2`（两次1步 或 一次2步）。
*   **空间优化**：我们发现，`dp[i]`只依赖于前两个状态，所以可以用两个变量来滚动记录，将空间复杂度从O(n)优化到O(1)。”

**最优代码 (Java) - 动态规划 + 空间优化：**

```java
class Solution {
    public int climbStairs(int n) {
        // 如果n为1或2，直接返回结果，避免后续计算
        if (n == 1) return 1;
        if (n == 2) return 2;

        // 初始化：dp[1] 和 dp[2]
        int prev = 1;   // 代表dp[i-2]，初始为dp[1] = 1
        int curr = 2;   // 代表dp[i-1]，初始为dp[2] = 2
        // 从第3阶开始计算，直到第n阶
        for (int i = 3; i <= n; i++) {
            // 计算当前阶数i的方法数：dp[i] = dp[i-1] + dp[i-2]
            int sum = prev + curr;
            // 更新状态，为下一次循环做准备：prev和curr分别向后移动一位
            prev = curr;
            curr = sum;
        }
        // 循环结束后，curr中存储的就是dp[n]的值
        return curr;
    }
}
```

#### 2. SQL题：查询每个用户的最新订单

**题目：** 有一张订单表`orders`，包含字段`order_id`（订单ID），`user_id`（用户ID），`order_date`（订单日期）。请查询出**每个用户**的**最新一条订单**的所有信息。

**思路：**
“这道题的关键是如何为每个用户分组，然后按时间排序取第一条。有两种主流方法：
1.  **窗口函数（现代SQL写法，高效直观）**：使用`ROW_NUMBER()` OVER (PARTITION BY user_id ORDER BY order_date DESC)`
2.  **子查询关联（经典写法）**：先子查询查出每个用户的最大日期，再用原表去关联。”

**方法一：使用窗口函数（推荐）**

```sql
SELECT *
FROM (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY user_id ORDER BY order_date DESC) as rn
    FROM orders
) AS tmp
WHERE tmp.rn = 1;
```
**代码解释：**
*   `ROW_NUMBER() OVER (...) as rn`：为每一行数据生成一个行号。
*   `PARTITION BY user_id`：按`user_id`进行分组，在每个用户内部进行单独排序。
*   `ORDER BY order_date DESC`：在每个组内，按订单日期降序排列，最新的日期排第一。
*   外层查询`WHERE rn = 1`：只取每组中排名为1的那条记录，即每个用户的最新订单。

**方法二：使用子查询关联**

```sql
SELECT o.*
FROM orders o
INNER JOIN (
    SELECT user_id, MAX(order_date) as latest_date
    FROM orders
    GROUP BY user_id
) AS latest_orders
ON o.user_id = latest_orders.user_id AND o.order_date = latest_orders.latest_date;
```
**代码解释：**
*   子查询`latest_orders`：找出每个用户(`GROUP BY user_id`)的最新的订单日期(`MAX(order_date)`)。
*   主查询：将原表`orders`与子查询结果进行关联，条件是`用户ID相同`且`订单日期等于该用户的最大日期`，从而筛选出每条最新订单的完整信息。

**注意：** 如果某个用户在同一天有多个订单，方法二会查出多条记录，而方法一仍然只会有一条（因为`ROW_NUMBER()`的排名不同）。根据业务需求选择合适的方法。通常方法一更符合“最新一条”的语义。

---

希望这份超详细的梳理和解答能帮助你充分准备！祝你面试顺利，一举成功！

好的，这是一场非常典型的后端开发面试，涉及项目、Java并发基础、集合框架、网络和算法。我们来对这些问题进行逐一分析和解答，希望能帮助你更好地准备。

---

### **4. 线程池添加一个任务是怎么运行的？**

当一个任务被提交给线程池（例如通过 `execute(Runnable command)` 方法），其运行流程如下：

1.  **核心线程是否已满？**
    *   如果当前运行的线程数小于核心线程数（`poolSize < corePoolSize`），线程池会**立即创建一个新的核心线程**来执行这个任务，即使其他核心线程是空闲的。
2.  **任务入队**
    *   如果核心线程已满，线程池会尝试将任务**放入工作队列**（BlockingQueue，如 `LinkedBlockingQueue`）。
    *   如果入队成功，任务会等待空闲的线程来获取并执行。
3.  **创建临时线程（非核心线程）**
    *   如果队列已满（对于有界队列），且当前线程数小于最大线程数（`poolSize < maximumPoolSize`），线程池会**创建一个新的非核心线程（临时线程）** 来立即执行这个任务。
4.  **拒绝策略**
    *   如果以上三步都失败了（即线程数已达最大值，且队列已满），线程池将根据指定的**拒绝策略（RejectedExecutionHandler）** 来处理这个新任务。常见的策略有：抛出异常、直接调用者线程执行、丢弃任务等。

**简单记忆口诀：核心线程未满 -> 创建核心线程；核心已满 -> 任务入队；队列已满 -> 创建临时线程；线程已满 -> 执行拒绝策略。**

---

### **5. 临时线程什么时候过期？怎么执行过期？**

*   **过期时机**：临时线程（非核心线程）在**空闲时间超过 `keepAliveTime`** 后就会被回收销毁。
*   **如何执行过期**：
    1.  线程池内部有一个**工作线程（Worker）** 会不断地从工作队列中获取任务（通过 `workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)` 方法）。
    2.  这个方法会**阻塞等待**一段时间为 `keepAliveTime`。
    3.  如果在 `keepAliveTime` 时间内获取到了新任务，则该线程继续执行任务。
    4.  如果**超时后仍未获取到任务**，`poll` 方法返回 `null`。此时，这个 Worker 线程会认为自己已经空闲太久，于是它**会结束自己的运行，并被操作系统回收**。这样，线程池中的线程数量就减少了。

**注意**：核心线程默认不会过期，除非设置了 `allowCoreThreadTimeOut(true)`。

---

### **6. 线程池的等待队列底层什么样的？**

线程池的等待队列是一个 **`BlockingQueue`（阻塞队列）**。具体实现有多种选择，常见的有：

*   **`LinkedBlockingQueue`**：基于链表的无界（除非构造时指定容量）队列。FIFO（先进先出）。`Executors.newFixedThreadPool` 使用它。**如果使用无界队列，将永远不会触发创建临时线程的机制，最大线程数参数会失效。**
*   **`ArrayBlockingQueue`**：基于数组的有界队列。FIFO。
*   **`SynchronousQueue`**：一个不存储元素的阻塞队列。每个插入操作必须等待另一个线程的对应移除操作。`Executors.newCachedThreadPool` 使用它。**这种队列会直接将任务交给线程处理，如果无空闲线程则立即创建新的临时线程，适用于任务量巨大但执行短暂的场景。**
*   **`PriorityBlockingQueue`**：具有优先级的无界队列。

---

### **7. List, 数组, Map 的特征与差别**

| 特性 | 数组 | List（接口） | Map（接口） |
| :--- | :--- | :--- | :--- |
| **数据结构** | 连续的、定长的内存空间 | 动态的、可扩展的序列 | 键值对（Key-Value）集合 |
| **元素访问** | 通过下标索引，速度快 `arr[0]` | 通过下标索引 `list.get(0)` | 通过键（Key）访问值 `map.get(key)` |
| **元素顺序** | 有序 | **有序**（插入顺序） | **不一定有序**（如HashMap无序，LinkedHashMap按插入顺序，TreeMap按Key排序） |
| **元素唯一性** | 可重复 | 可重复 | **Key唯一，Value可重复** |
| **常用实现** | `int[]`, `String[]` | `ArrayList`（数组实现，查询快），`LinkedList`（链表实现，增删快） | `HashMap`（哈希表），`TreeMap`（红黑树），`LinkedHashMap`（链表+哈希表） |
| **核心区别** | **长度固定**的基础数据结构 | **长度可变**的对象容器，**单列数据** | **键值对**映射关系的对象容器，**双列数据** |

---

### **8 & 9. ConcurrentHashMap 相关的拷打 & 会不会出现线程不安全问题？**

这是一个深度问题，可以从以下几个方面回答：

**1. 演进与结构（JDK7 vs JDK8）**
*   **JDK7**：采用 **分段锁（Segment）** 机制。整个数组由多个 Segment 组成，每个 Segment 是一个小的 HashMap。写操作只锁住对应的 Segment，不同 Segment 的写操作可以并发进行。**get操作通常无锁。**
*   **JDK8及以后**：摒弃了分段锁，改用 **`Node数组 + 链表 + 红黑树`** 的结构，并发控制使用 **`synchronized` 同步代码块 + CAS（Compare-And-Swap）操作**。只锁住数组中的单个桶（bucket，即链表或红黑树的头节点），粒度更细，并发度更高。

**2. 保证线程安全的手段（以JDK8为例）**
*   **CAS**：用于初始化数组、在链表头无锁插入节点等无竞争场景，性能高。
*   **`synchronized`**：用于对桶的头节点加锁，保证对同一个桶的写操作是互斥的。
*   **volatile**：`Node` 的 `value` 和 `next` 指针用 `volatile` 修饰，保证线程间的可见性。

**3. 会不会出现线程不安全问题？**
**`ConcurrentHashMap` 本身提供的原子方法是线程安全的**，例如 `put`, `get`, `remove`。但如果你**组合使用多个方法**，而没有在外部进行同步，就可能出现线程不安全问题。

**经典例子：**
```java
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
// 线程A
if (!map.containsKey("key")) {
    // 在线程A执行完containsKey后，但还未执行put前，线程B可能已经插入了 "key"
    map.put("key", 1); 
}
// 线程B
if (!map.containsKey("key")) {
    map.put("key", 2); // 可能导致线程A放入的值被覆盖
}
```
**结论**：`ConcurrentHashMap` 的**单个方法是线程安全的**，但**复合操作（检查再行动）不是原子的**。对于需要复合操作的场景，应该使用它提供的**原子方法**，如 `putIfAbsent()`, `compute()`, `computeIfAbsent()` 等。

---

### **10. 了解 SubList 吗？**

*   **是什么**：`ArrayList` 的 `subList(fromIndex, toIndex)` 方法返回一个 `List` 的**视图**（View），**不是独立的 ArrayList 副本**。
*   **特性与风险**：
    1.  **视图**：对原 `List` 或返回的 `SubList` 进行的**非结构性修改**（如 `set` 方法），会相互影响。
    2.  **结构性修改**：如果在生成子列表后，直接对**原 `ArrayList`** 进行了结构性修改（如 `add`, `remove`），再操作 `SubList` 会抛出 `ConcurrentModificationException` 异常。
    3.  **独立副本**：如果你需要一个完全独立的子列表，应该 `new ArrayList<>(list.subList(...))`。

---

### **11. Redis 怎么解决可用性问题？（高可用方案）**

1.  **主从复制（Replication）**：
    *   一个主节点（Master）负责写，多个从节点（Slave）负责读和备份。
    *   主节点将数据异步同步到从节点。**提高了读吞吐量和数据可靠性，但主节点宕机后需要手动干预，无法自动故障恢复。**

2.  **哨兵模式（Sentinel）**：
    *   哨兵是一个独立的进程，用于**监控**Redis主从节点。
    *   当主节点宕机时，哨兵能**自动进行故障转移**：将一个从节点提升为主节点，并让其他从节点指向新的主节点。客户端通过询问哨兵来获取当前的主节点地址。
    *   **解决了高可用和自动故障转移问题。**

3.  **Redis Cluster（集群模式）**：
    *   官方推出的**分布式方案**。将数据**分片（Sharding）** 存储在多个节点上（每个节点负责一部分数据槽 slot）。
    *   具备**故障转移**能力（类似哨兵，但集成在集群中）。
    *   **同时解决了高可用和高并发写/大数据量存储的问题**，是生产环境最彻底的解决方案。

---

### **12. OSI七层模型，TCP和IP在哪层？**

*   **OSI七层模型**：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
*   **TCP** 位于**传输层**（第四层）。
*   **IP** 位于**网络层**（第三层）。

---

### **13. TCP和HTTP什么关系？**

*   **TCP（传输控制协议）**：是**传输层**协议，提供可靠的、面向连接的、基于字节流的通信服务。它负责建立连接、保证数据包按序且不丢失地传输，但**不关心数据内容**。
*   **HTTP（超文本传输协议）**：是**应用层**协议，定义了客户端（如浏览器）和服务器之间交换信息的**格式和规则**（如请求方法GET/POST、状态码200/404等）。
*   **关系**：HTTP 协议是**建立在 TCP 协议之上的**。一个 HTTP 请求/响应的过程，首先需要由 TCP 来建立一条可靠的连接（三次握手），然后 HTTP 消息作为数据载荷，通过这条 TCP 连接进行传输，传输完毕后可能关闭 TCP 连接（四次挥手）。可以简单理解为：**TCP 是“高速公路”，HTTP 是公路上跑的“货车”，货车上装的才是具体的“网页内容”。**

---

### **14. GET 和 POST 区别？POST 是否可以替代 GET？意义在哪？**

**区别：**

| 特性 | GET | POST |
| :--- | :--- | :--- |
| **语义** | **获取**资源（查） | **提交/处理**数据（增/改） |
| **参数位置** | 附在 URL 之后（Query String） | 放在**请求体（Body）** 中 |
| **数据长度** | 受 URL 长度限制（浏览器不同，一般2KB-8KB） | 理论上无限制 |
| **安全性** | 参数明文在URL中，不安全，会被浏览器历史记录 | 相对安全（Body不可见，但仍是明文，需HTTPS加密） |
| **幂等性** | **幂等**（多次执行效果相同） | **非幂等**（多次提交可能产生不同结果） |
| **缓存** | 可被浏览器缓存 | 默认不会被缓存 |

**POST 是否可以替代 GET？**
*   **从技术上讲，可以**。你可以用 POST 实现所有 GET 的功能。
*   **但从设计和规范上讲，绝对不应该这样做。**

**意义（为什么区分它们）：**
1.  **语义化（最重要）**：遵循 RESTful 架构风格。GET 表示“读取”，POST 表示“创建/修改”。这使得 API 意图清晰，便于理解和维护。例如，一个爬虫可以安全地调用 GET 接口而不用担心会改变服务器数据。
2.  **幂等性**：GET 的幂等性使得网络操作更安全可靠。失败后可以自动重试，而不用担心重复提交订单这样的副作用。
3.  **缓存**：浏览器、代理服务器、CDN 等可以基于 GET 请求的语义和 URL 进行缓存，极大提升性能。而 POST 请求通常不会被缓存。
4.  **可 bookmark（书签）**：GET 请求的 URL 包含了所有参数，可以直接被存为书签或分享。POST 请求则不行。

**结论**：区分 GET 和 POST 是 Web 架构良好设计的基础，旨在利用它们各自的特点构建出更清晰、更安全、更高效的网络应用。

---

### **手撕代码**

**1. 爬楼梯**

```python
def climbStairs(n: int) -> int:
    if n <= 2:
        return n
    # 动态规划，dp[i] 表示爬到第 i 阶楼梯的方法数
    dp = [0] * (n + 1)
    dp[1] = 1
    dp[2] = 2
    for i in range(3, n + 1):
        dp[i] = dp[i - 1] + dp[i - 2]  # 可以从 i-1 阶爬 1 步上来，也可以从 i-2 阶爬 2 步上来
    return dp[n]

# 空间优化版（斐波那契）
def climbStairs_optimized(n: int) -> int:
    if n <= 2:
        return n
    a, b = 1, 2
    for i in range(3, n + 1):
        a, b = b, a + b
    return b
```

**2. 字符串相乘**

```python
def multiply(num1: str, num2: str) -> str:
    if num1 == "0" or num2 == "0":
        return "0"
    
    m, n = len(num1), len(num2)
    # 结果数组，最大长度为 m+n
    res = [0] * (m + n)
    
    # 从低位到高位逐位相乘
    for i in range(m - 1, -1, -1):
        for j in range(n - 1, -1, -1):
            # 当前位的乘积
            mul = (ord(num1[i]) - ord('0')) * (ord(num2[j]) - ord('0'))
            # 乘积对应的位置
            p1, p2 = i + j, i + j + 1
            # 叠加到 res 上
            total = mul + res[p2]
            res[p2] = total % 10  # 个位
            res[p1] += total // 10  # 进位（加到前一位上）
    
    # 将结果数组转换为字符串，去除前导零
    result_str = ''.join(str(x) for x in res).lstrip('0')
    return result_str if result_str else "0"

# 示例
# num1 = "123", num2 = "456"
# res 数组变化过程（略），最终得到 [0, 5, 6, 0, 8, 8] -> "56088"
```

希望这份详细的解答能对你有所帮助！

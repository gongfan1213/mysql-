这是一场偏向基础理论和场景分析的面试，问题质量很高。下面我为你提供一份详细的解答。

---

### **1. 除了ThreadLocal外，Java的弱引用还有哪些使用场景？**

你临场分析的**缓存**和**临时连接**方向是完全正确的！弱引用（`WeakReference`）的核心特点是：**当垃圾回收器开始工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。**

基于这个特点，它的主要应用场景如下：

1.  **规范化映射（Canonicalizing Mappings） / 缓存（Cache）：** 这是最经典的场景。
    *   **问题：** 实现一个内存缓存，当内存不足时，希望缓存中的条目能够被自动回收，而不是因为被缓存引用而导致OOM。
    *   **解决方案：** 使用 `WeakHashMap` 或其思想。`WeakHashMap` 的Key是弱引用指向的。当Key所指向的对象除了在`WeakHashMap`中被弱引用外，没有其他强引用时，下次GC这个Key-Value条目就会被自动清除。
    *   **例子：** 存储一些可重建的元数据缓存，如图片缓存。当图片对象不再被UI组件（强引用）使用时，缓存会自动释放它。

2.  **监听器列表（Listener Lists）的“幽灵引用”：**
    *   **问题：** 在实现观察者模式时，如果被观察者持有一份观察者的强引用列表，那么观察者即使不再被使用，也无法被回收，因为被观察者还“拉着”它。
    *   **解决方案：** 使用弱引用来持有观察者。这样，当观察者失去所有其他强引用时，它就可以被GC回收，从而自动从监听列表中“消失”，避免了内存泄漏。

3.  **临时性资源管理（如你提到的临时连接）：**
    *   **问题：** 某个对象持有一个昂贵且需要显式关闭的资源（如数据库连接、文件句柄）。我们希望当这个对象不再被主逻辑使用时，资源能被尽快释放，而不是等待一个不确定的生命周期。
    *   **解决方案：** 可以创建一个弱引用来监控这个对象。同时，注册一个 `ReferenceQueue`。当监控到对象被GC后（弱引用被加入队列），后台线程可以主动去执行清理资源（如关闭连接）的操作。这是一种兜底机制，主逻辑仍应主动关闭资源。

**总结：** 弱引用的核心价值在于构建一种 **“次级”的、不阻止GC的关联关系**，常用于构建生命周期受外部控制的缓存、辅助资源清理以及避免不必要的对象滞留。

---

### **2. 讲一讲对微服务的理解**

微服务是一种**架构风格**，它将一个大型的单体应用拆分成一组**小型、自治的服务**。

*   **核心特征：**
    1.  **单一职责：** 每个服务只关注一个特定的业务能力（如用户服务、订单服务），并可以独立开发、部署和扩展。
    2.  **自治性：**
        *   **技术异构：** 每个服务可以选择最适合自身需求的技术栈（语言、数据库）。
        *   **独立部署：** 修改一个服务只需部署该服务本身，不影响其他服务。
        *   **独立扩展：** 可以对性能瓶颈服务进行单独扩容。
    3.  **围绕业务构建：** 拆分边界是业务领域，而不是技术层（不是把Controller、Service、Dao拆成三个服务）。
    4.  **轻量级通信：** 服务之间通过明确的API（通常是HTTP/REST或RPC）进行通信。

*   **与单体架构的对比：**
    *   **单体：** 所有功能模块打包在一起，耦合紧密，修改一个小功能需要部署整个应用，技术栈单一，扩展困难。
    *   **微服务：** 解耦，灵活，易扩展，但带来了**复杂度**。

*   **带来的挑战（“硬币的另一面”）：**
    *   **分布式系统复杂性：** 网络延迟、容错（某个服务挂了怎么办？）、分布式事务、数据一致性。
    *   **运维复杂度：** 需要成熟的DevOps文化和技术栈，包括服务发现、配置中心、链路追踪、日志聚合、监控告警等。
    *   **测试和部署：** 需要一套完整的CI/CD流水线来管理多个服务的集成和部署。

**一句话总结：** 微服务通过拆分和自治提升了系统的敏捷性、可扩展性和容错性，但同时也显著增加了架构和运维的复杂度。

---

### **3. 如何实现文件传输？**

文件传输的本质是**将文件数据从源端通过网络可靠地传输到目的端**。实现方案取决于场景：

1.  **简单的单次传输（小文件）：**
    *   **HTTP PUT/POST：** 客户端通过HTTP请求的Body将文件数据发送给服务端。服务端解析Body并保存为文件。这是Web应用中最常见的方式。
    *   **FTP/SFTP：** 专为文件传输设计的协议，适合服务器之间的文件交换。

2.  **大文件或需要断点续传的场景：**
    *   **分块传输：** 将大文件切割成固定大小的块（如1MB），依次上传。服务端接收后按顺序重组。
    *   **断点续传：** 在上面的基础上，客户端和服务端都记录已成功传输的块。当传输中断后，可以从最后一个未成功的块开始继续传输，而不是重头开始。HTTP协议中的 `Range` 头部可以支持此功能。

3.  **实时流式传输：**
    *   **WebSocket：** 建立全双工连接后，可以持续地将文件数据流式地发送给对方。适合实时协作编辑等场景。

4.  **高性能或点对点传输：**
    *   **TCP Socket 自定义协议：** 自己设计协议头（包含文件名、大小、校验和等信息），然后通过TCP Socket流式传输文件数据。这是最底层、最灵活的方式，但实现复杂。

**通用优化考虑：**
*   **压缩：** 传输前对文件进行压缩。
*   **校验：** 传输完成后，对比源文件和目标文件的MD5等哈希值，确保数据完整性。
*   **加密：** 对敏感文件在传输过程中进行加密（如使用TLS/SSL）。

---

### **4. HTTP三次握手、四次挥手、TLS四次握手**

这是一个网络基础问题，需要清晰地分开讲。

**1. TCP 三次握手（建立连接）：** 目标是**同步双方的初始序列号（ISN）**，确保双方都有发送和接收的能力。
    *   **第一次：** Client -> Server。SYN=1, seq=x (Client ISN)。（Client状态：SYN-SENT）
    *   **第二次：** Server -> Client。SYN=1, ACK=1, seq=y (Server ISN), ack=x+1。（Server状态：SYN-RCVD）
    *   **第三次：** Client -> Server。ACK=1, seq=x+1, ack=y+1。（双方状态：ESTABLISHED）

**2. TCP 四次挥手（释放连接）：** 目标是**双方都确认要关闭连接**。因为TCP是全双工的，每个方向必须单独关闭。
    *   **第一次：** Client -> Server。FIN=1, seq=u。（Client状态：FIN-WAIT-1）
    *   **第二次：** Server -> Client。ACK=1, seq=v, ack=u+1。（Server状态：CLOSE-WAIT | Client状态：FIN-WAIT-2）
    *   **第三次：** Server -> Client。FIN=1, ACK=1, seq=w, ack=u+1。（Server状态：LAST-ACK）
    *   **第四次：** Client -> Server。ACK=1, seq=u+1, ack=w+1。（Client进入TIME-WAIT状态，等待2MSL后关闭）

**3. TLS 握手（建立安全连接）：** 在TCP连接建立后，进行TLS握手以加密通信。
    *   **第一次：** ClientHello。客户端向服务器发送支持的TLS版本、加密套件列表、一个随机数（Client Random）。
    *   **第二次：** ServerHello。服务器确认TLS版本和加密套件，发送自己的随机数（Server Random）和**数字证书**（包含公钥）。服务器可能要求客户端也提供证书。
    *   **第三次：** 客户端验证服务器证书。用证书中的公钥加密一个**预主密钥（Pre-Master Secret）** 发送给服务器。然后，双方根据Client Random、Server Random和Pre-Master Secret**独立计算出相同的主密钥**，进而生成会话密钥。
    *   **第四次：** 双方交换Finished消息，用会话密钥加密，验证整个握手过程是否被篡改。验证通过后，后续应用数据（HTTP）就使用会话密钥进行加密传输。

**关系：** `TCP握手 -> TLS握手 -> HTTP请求/响应`。

---

### **5. Java有GC了是否还会有内存泄漏？哪些场景？**

**会！GC只能回收那些“不可达”的对象。内存泄漏在Java中指的是：一些对象已经不再被程序使用（逻辑上已死亡），但由于疏忽或错误，仍然存在GC Roots的引用链（可达），导致GC无法回收它们。**

**常见场景：**

1.  **静态集合类引起：** 静态集合（如`static HashMap`）的生命周期与类一样长。如果向其中存放对象，并且之后没有移除，那么这些对象会一直存在，即使程序逻辑已不再需要它们。
2.  **各种连接未关闭：** 数据库连接、网络连接（Socket）、文件流等，它们底层都对应着操作系统的资源。如果只将引用置为null而没有调用`close()`方法，那么这些对象和它们占用的资源都不会被释放。
3.  **监听器与回调：** 在被观察者中注册了监听器，但在对象销毁时没有取消注册，导致观察者一直持有被观察对象的引用。
4.  **内部类持有外部类引用：** 非静态内部类会隐式持有其外部类实例的引用。如果这个内部类的对象被一个长生命周期对象（如线程池）所引用，那么即使外部类实例本身已不再需要，也无法被GC回收。
5.  **修改对象的哈希值：** 如果一个对象被放入`HashSet`（或作为`HashMap`的Key）后，修改了其参与计算`hashCode()`的字段，那么你将无法再通过`remove()`方法将其从集合中删除，导致内存泄漏。因为它在哈希桶中的位置改变了。

**诊断工具：** 使用 `jstack`, `jmap` 导出堆转储，然后用 **Eclipse Memory Analyzer (MAT)** 等工具分析，可以清晰地看到这些“泄漏”的对象是被谁引用的。

---

### **算法：三线程交替打印**

这是一个经典的并发同步问题，考察对线程间通信（`wait/notify` 或 `Lock/Condition`）的理解。这里给出使用 `synchronized` 和 `wait/notifyAll` 的解法。

**目标：** 三个线程A, B, C，交替打印A, B, C，如ABCABCABC...

**思路：** 用一个共享变量 `state` 表示当前该哪个线程打印。每个线程检查 `state`，如果不是自己就等待，如果是自己就打印，然后修改 `state` 并唤醒所有线程。

```java
public class AlternatePrint {
    private static final Object lock = new Object();
    private static int state = 0; // 0: A, 1: B, 2: C

    public static void main(String[] args) {
        Thread threadA = new Thread(() -> {
            for (int i = 0; i < 10; ) {
                synchronized (lock) {
                    while (state % 3 != 0) { // 不该A打印
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.print("A");
                    state++;
                    i++;
                    lock.notifyAll(); // 唤醒B和C
                }
            }
        });

        Thread threadB = new Thread(() -> {
            for (int i = 0; i < 10; ) {
                synchronized (lock) {
                    while (state % 3 != 1) { // 不该B打印
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.print("B");
                    state++;
                    i++;
                    lock.notifyAll();
                }
            }
        });

        Thread threadC = new Thread(() -> {
            for (int i = 0; i < 10; ) {
                synchronized (lock) {
                    while (state % 3 != 2) { // 不该C打印
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                    }
                    System.out.print("C");
                    state++;
                    i++;
                    lock.notifyAll();
                }
            }
        });

        threadA.start();
        threadB.start();
        threadC.start();
    }
}
```

**关键点：**
*   **`wait()` 要在 `while` 循环中检查条件**，不能用在 `if` 中，以防止**虚假唤醒**。
*   调用 `notifyAll()` 而不是 `notify()`，因为需要唤醒下一个特定的线程，如果只唤醒一个，可能会唤醒错误的线程导致所有线程都等待。

希望这份详细的解答能帮助你！

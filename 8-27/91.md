# 小米秋招Java开发一面题目
1. 自我介绍
2. 实习介绍
3. 实习过程中有用过大模型吗？
4. 算法题：100元红包，8个人抢，怎么设计？每个人分配的金额怎么设计？（只会在剩余金额里取随机数），你这样设计有什么问题？数学期望是多少？
5. ThreadLocal，以及remove方法，你每次操作都会remove吗？
6. java的引用类型有哪些？
7. MVCC介绍
8. MySQL的隔离级别，可重复读是什么？每种隔离级别会出现哪些问题？
9. MySQL有幻读现象吗？举个例子？怎么解决？
10. 看过哪些源码？
11. AOP项目中怎么用的？
12. AOP的底层原理？


### 1. 自我介绍（面试高频基础题，核心是“匹配岗位需求”）
自我介绍需控制在1-2分钟，结构清晰，突出与Java开发岗位相关的优势，避免流水账。推荐框架：**个人基本信息+技术栈匹配点+项目/实习亮点+岗位适配度**。  
示例：“面试官好，我是XX，XX大学计算机专业大三学生，主攻Java技术栈，熟悉Spring Boot、MyBatis等框架，能独立完成简单后端接口开发。之前在XX公司实习时，参与过用户管理模块开发，用MySQL实现了用户数据的CRUD，还通过索引优化将查询耗时从200ms降到50ms以内。了解到小米Java开发岗侧重业务逻辑实现和性能优化，我的技术储备和实习经历刚好能匹配，也很期待加入团队。”


### 2. 实习介绍（核心是“STAR法则，突出个人价值”）
避免只说“我做了XX”，要讲清“做的事+遇到的问题+怎么解决+带来的结果”，体现技术能力和思考。  
示例：“实习时我负责XX项目的订单支付模块开发（Situation）。当时遇到的问题是，支付回调接口偶尔出现重复通知，导致订单重复更新（Task）。我先通过日志定位到是回调重试机制未做幂等处理，然后设计了‘基于Redis的分布式锁+订单状态校验’的方案：回调请求先抢锁，抢到后判断订单是否已处理，未处理才执行更新（Action）。最终解决了重复更新问题，接口稳定性从95%提升到99.9%（Result）。”


### 3. 实习过程中有用过大模型吗？（核心是“诚实+体现学习/应用能力”）
无论用过与否，都要逻辑清晰，用过就讲“场景+价值”，没用过就讲“了解+学习计划”，避免空谈。  
- 用过示例：“用过，主要在两个场景：一是用ChatGPT辅助排查Bug，比如之前遇到一个Java空指针异常，日志只提示空值，但没定位到具体代码，我把异常栈和相关代码片段发给大模型，它帮我列出了3个可能的空值点，最后排查出是DTO字段未判空；二是用CodeGeeX生成简单的CRUD模板代码，节省了重复编码时间，但生成后我会逐行检查，确保符合项目编码规范。”  
- 没用过示例：“目前实习中还没直接应用到大模型，但我私下了解过一些大模型在开发中的场景，比如代码生成、文档注释自动补全、技术问题检索等。之后计划学习如何用大模型提高开发效率，比如尝试用GitHub Copilot辅助写单元测试，但会注意代码的准确性和安全性，不会直接照搬。”


### 4. 算法题：100元红包8人抢（核心是“方案设计+问题分析+数学推导”）
这道题考察“随机逻辑设计”“边界处理”和“数学思维”，需分步骤拆解。

#### （1）基础方案设计（剩余金额随机法）
核心原则：**保证每个人都能抢到钱（至少0.01元），且最后一个人能拿到剩余所有金额**，避免“前7人抢完，第8人没钱”的情况。  
具体步骤：
1. 初始化剩余金额`remainMoney = 100`（单位：元，建议转分为整数计算，避免浮点数精度问题，如100元=10000分）。
2. 初始化剩余人数`remainPeople = 8`。
3. 循环7次（前7人抢红包）：
   - 每次生成随机金额`randomMoney`，范围是`[1, remainMoney - (remainPeople - 1)*1]`（单位：分）。解释：下限1分保证有人抢，上限减去“剩余人数-1”个1分，保证后面的人至少能抢到1分。
   - 从`remainMoney`中减去`randomMoney`，`remainPeople`减1。
4. 第8人直接拿剩余的`remainMoney`。
5. 最后将所有金额转回元（除以100），输出分配结果。

#### （2）方案存在的问题
- **金额分布不均**：前几个人可能抢到极大金额（如第1人可能抢到99.93元，后面7人各1分），不符合现实中“红包金额相对均匀”的预期。
- **浮点数精度风险**：若直接用double计算（如100.0元），多次减法可能出现精度误差（如100-50.01=49.989999999999995），导致总金额不足100元。
- **随机性不可控**：无法设置“最小金额上限”（如每人至少1元），需额外加逻辑判断。

#### （3）数学期望计算
核心结论：**每个人抢到金额的数学期望都是12.5元（100元/8人）**。  
推导过程（以第k人为例，1≤k≤8）：
- 对于第1人：随机范围是`[0.01, 99.93]`（元），期望E1 = (0.01 + 99.93)/2 = 49.97？不对，实际需用“剩余金额分配的线性期望”推导。  
- 更简单的逻辑：整个过程是“将100元随机分成8份，每份≥0.01元”，本质是均匀随机分配。根据线性期望的性质，无论分配顺序如何，每个人的期望都是总金额除以人数，即100/8=12.5元。  
  举例：第1人期望E1=12.5元；第2人是在剩余87.5元中分配给7人，期望E2=87.5/7=12.5元；以此类推，第8人拿到剩余的12.5元（期望），所有人大致相等。


### 5. ThreadLocal及remove方法（核心是“原理+内存泄漏风险+最佳实践”）
#### （1）ThreadLocal是什么？
ThreadLocal是Java中用于“线程本地存储”的工具类，核心作用是**让每个线程拥有独立的变量副本**，避免多线程共享变量的并发问题（如不需要加锁，直接操作自己的副本）。  
原理：每个Thread对象内部有一个`ThreadLocalMap`，key是ThreadLocal实例，value是线程的变量副本。当线程调用`threadLocal.set(value)`时，会往自己的`ThreadLocalMap`中存值；调用`get()`时，从自己的Map中取值；调用`remove()`时，删除自己Map中的该条目。

#### （2）remove方法的作用
- 核心功能：删除当前线程`ThreadLocalMap`中该ThreadLocal对应的键值对，避免**内存泄漏**。  
- 为什么需要remove？因为`ThreadLocalMap`的key是ThreadLocal的弱引用（WeakReference），当ThreadLocal实例被回收后，key会变成null，此时value若未被删除，会变成“无主”的强引用，导致内存泄漏（尤其是线程池场景，线程复用，value一直存在）。

#### （3）每次操作都会remove吗？
**推荐“用完即删”，尤其是在线程池环境下必须remove**，普通单线程场景（如Spring MVC的请求线程，请求结束后线程销毁）可酌情，但最佳实践是统一remove。  
- 必须remove的场景：线程池（如ThreadPoolExecutor）中的线程会复用，若不remove，下次线程执行时可能拿到上一次的旧值，导致数据错误。  
- 示例代码（最佳实践）：
  ```java
  ThreadLocal<String> threadLocal = new ThreadLocal<>();
  try {
      threadLocal.set("小米秋招"); // 存值
      String value = threadLocal.get(); // 取值
      // 业务逻辑
  } finally {
      threadLocal.remove(); // 无论是否异常，都删除，避免内存泄漏
  }
  ```


### 6. Java的引用类型（核心是“4种类型+区别+应用场景”）
Java从JDK 1.2开始，将引用分为4种，按“引用强度从强到弱”排序：**强引用→软引用→弱引用→虚引用**，核心是为了让JVM更灵活地管理内存（按需回收）。

| 引用类型 | 核心特点 | 回收时机 | 应用场景 |
|----------|----------|----------|----------|
| 强引用（Strong Reference） | 最普通的引用（如`Object obj = new Object()`），JVM宁愿OOM也不回收 | 只有当引用被置为null时，才可能被回收 | 日常开发中的对象引用（如Service、DAO实例） |
| 软引用（Soft Reference） | 引用强度弱于强引用，用`SoftReference`类实现 | 当JVM内存不足时，会回收软引用指向的对象 | 内存敏感的缓存（如图片缓存，内存够时存，不够时删） |
| 弱引用（Weak Reference） | 引用强度弱于软引用，用`WeakReference`类实现 | 每次GC时，无论内存是否充足，都会回收 | ThreadLocal的key、WeakHashMap的key（避免内存泄漏） |
| 虚引用（Phantom Reference） | 最弱的引用，用`PhantomReference`类实现，**不能通过虚引用获取对象** | 任何时候都可能被回收，必须配合`ReferenceQueue`使用 | 跟踪对象的回收状态（如JVM的直接内存回收通知） |


### 7. MVCC（核心是“是什么+原理+作用”）
MVCC全称是**Multi-Version Concurrency Control（多版本并发控制）**，是InnoDB存储引擎实现“高并发读”的核心机制，作用是**在不加锁的情况下，实现“读不加锁、写不阻塞读”**，解决并发读写的冲突问题。

#### 核心原理（3个关键组件+1个流程）
1. **隐藏列**：InnoDB为每个表的每行数据添加3个隐藏列：
   - `DB_TRX_ID`：记录最后一次修改该数据的事务ID。
   - `DB_ROLL_PTR`：回滚指针，指向该数据的“undo日志”（历史版本）。
   - `DB_ROW_ID`：若表没有主键，InnoDB会自动生成该列作为主键。

2. **undo日志**：用于存储数据的历史版本。当事务修改数据时，会先将数据的旧版本存入undo日志，通过`DB_ROLL_PTR`串联成“版本链”。

3. **Read View（读视图）**：每个事务在开始读操作时，会生成一个Read View，包含4个核心参数：
   - `m_low_limit_id`：当前所有活跃事务的最小ID。
   - `m_high_limit_id`：下一个即将分配的事务ID。
   - `m_ids`：当前所有活跃事务的ID集合。
   - `m_creator_trx_id`：生成该Read View的事务ID。

4. **版本判断规则**（事务通过Read View判断哪个版本的数据可见）：
   - 若数据的`DB_TRX_ID` < `m_low_limit_id`：说明修改该数据的事务已提交，数据可见。
   - 若数据的`DB_TRX_ID` > `m_high_limit_id`：说明修改该数据的事务是后续新事务，数据不可见，需通过`DB_ROLL_PTR`找历史版本。
   - 若`m_low_limit_id` ≤ `DB_TRX_ID` ≤ `m_high_limit_id`：看`DB_TRX_ID`是否在`m_ids`中：
     - 不在：事务已提交，数据可见。
     - 在：事务未提交，数据不可见，找历史版本。


### 8. MySQL的隔离级别（核心是“4个级别+定义+问题”）
MySQL的隔离级别是为了平衡“并发性能”和“数据一致性”，基于SQL标准定义了4个级别，InnoDB默认支持**Repeatable Read（可重复读）**。

#### （1）4个隔离级别（从低到高）
| 隔离级别 | 定义 | 可能出现的问题（脏读/不可重复读/幻读） |
|----------|------|----------------------------------------|
| Read Uncommitted（读未提交） | 允许事务读取其他事务未提交的数据 | 脏读、不可重复读、幻读 |
| Read Committed（读已提交） | 只允许事务读取其他事务已提交的数据 | 不可重复读、幻读 |
| Repeatable Read（可重复读，默认） | 事务内多次读取同一数据，结果一致（无论其他事务是否修改提交） | 幻读（InnoDB通过MVCC解决了部分幻读） |
| Serializable（串行化） | 事务串行执行（加表锁），完全隔离 | 无（但并发性能极差） |

#### （2）关键概念解释
- **脏读**：读了其他事务未提交的数据（如事务A改了数据但没提交，事务B读了该数据，之后A回滚，B读的是“脏数据”）。
- **不可重复读**：同一事务内，多次读同一数据，结果不同（如事务A读了数据，事务B改了数据并提交，A再读，结果变了）。
- **幻读**：同一事务内，多次执行同一查询，返回的行数不同（如事务A查“age>20”的有3行，事务B插入1行age=25并提交，A再查，变成4行，像“幻觉”一样）。

#### （3）可重复读（Repeatable Read）详解
InnoDB的可重复读通过MVCC实现：事务开始时生成Read View，之后每次读都用同一个Read View，即使其他事务修改了数据并提交，也只会读自己Read View可见的历史版本，所以“重复读结果一致”。


### 9. MySQL的幻读（核心是“是否存在+例子+解决方法”）
#### （1）MySQL有幻读吗？
- **结论**：存在，但InnoDB在默认的“可重复读”级别下，通过**Next-Key Lock（间隙锁）** 解决了“写操作的幻读”，但“纯读操作”仍可能出现幻读。

#### （2）幻读例子（纯读操作场景）
1. 表`user`有数据：`id=1, age=20`；`id=2, age=22`（无主键，以age为查询条件）。
2. 事务A开始，执行查询：`select * from user where age>20`，返回1行（id=2）。
3. 事务B开始，执行插入：`insert into user values(3, 25)`，提交事务。
4. 事务A再次执行`select * from user where age>20`，在“可重复读”级别下，因MVCC的Read View，仍返回1行（id=2）——这是InnoDB的优化，避免了部分幻读。
5. 若事务A接着执行`update user set age=30 where age>20`，会更新2行（id=2和id=3），然后再查`select * from user where age>20`，会返回2行（id=2和id=3）——此时出现幻读（更新后读的行数变了）。

#### （3）解决幻读的方法
- **方法1：用Serializable隔离级别**：加表锁，事务串行执行，完全避免幻读，但性能极差，不推荐。
- **方法2：用Next-Key Lock（间隙锁）**：InnoDB在“可重复读”级别下，执行“范围更新/删除”时，会自动加间隙锁（锁定查询范围的间隙，如`age>20`会锁定`20到+∞`的间隙），阻止其他事务插入该范围的数据，从而解决写操作的幻读。
- **方法3：手动加行锁/表锁**：如执行`select * from user where age>20 for update`（加行锁和间隙锁），锁定范围数据，阻止插入。


### 10. 看过哪些源码？（核心是“选熟悉的源码+讲清核心逻辑+体现思考”）
不要说“看过很多源码”，要选1-2个熟悉的、与Java开发相关的源码（如Spring、JDK集合、MyBatis），讲清“看了哪个类/模块+核心逻辑+学到的设计思想”。  
示例：“我主要看了Spring的`ApplicationContext`源码和JDK的`ArrayList`源码。以`ArrayList`为例，我重点看了`add()`和`grow()`方法：`add()`方法会先判断容量是否足够，不够就调用`grow()`扩容，扩容时默认是原来的1.5倍（`newCapacity = oldCapacity + (oldCapacity >> 1)`），还会拷贝旧数组到新数组（用`Arrays.copyOf()`）。从

美团 后端开发 一面二面
很奇怪，打过来电话说是全栈开发，然后发的是后端开发的面试，面的也很水，部门是核心本地商业业务研发平台，不知道广大牛友有无了解的来解惑呢🤔

///////一面：日期9.17，第二天约二面

什么是进程和线程

什么是临界区？如何解决冲突

进程通讯有哪些方式

什么是死锁？死锁的条件是什么，怎么解决

说一下中断，什么是中断

进程调度策略有哪几种

进程同步与互斥的区别

TCP和UDP的区别

HTTP2和HTTP3的区别

浏览器输入一个网址到渲染出来的过程

TCP的三次握手

Java里的浅拷贝和深拷贝

说一下Java里的泛型以及实现原理，举一个使用场景

说一下整型的缓存，以及整型在比较的过程中要注意的问题

自动装箱机制

讲讲红黑树特性及应用场景

Java的哈希map在高并发的情况下使用不当会导致什么问题

哈希Map在扩容中会有什么问题

Array list和linked list的区别

如何复制一个数组效率最高

你觉得在开发过程有哪些比较有意思的特性或者bug

面向对象和面向过程的不同

用过哪些设计模式

讲实习项目

项目中学到了什么，如何用工具还是工具的深层

算法：最小路径和，前K小的数

///////二面：日期9.19
实习项目的作用和功能是什么

0.1+0.2==0.3是True还是false

怎么解决精度丢失的问题

假如请求头过大报错，从前端后端网关层面该怎么解决

算法：无序数组做排序，排序后，奇数统一在数组左边，偶数统一在数组右边

反问业务，觉得回答含糊不清，说活比较杂，做的用户增长方向
#美团# #美团秋招# #面经# #秋招#

作者：PlayerNO1__
链接：https://www.nowcoder.com/feed/main/detail/8c7500ee8f0b4b3ca7aff4a5887517ea?sourceSSR=users
来源：牛客网


看到你的面经，我完全理解你的困惑。这场面试的“水”和“杂”其实背后有它的逻辑。美团核心本地商业业务研发平台这个部门，听起来是做**内部中台、工具链或增长平台**的，这类团队的特点就是：

1.  **技术栈广**：需要支持各种业务线，所以问的问题从底层OS到前端HTTP协议都有涉及。
2.  **注重基础**：因为不直接面对某一具体C端业务，所以不会问很深的具体业务场景题，反而更看重候选人的**计算机基础是否扎实**，这是你未来能快速学习不同技术、支持不同业务的前提。
3.  **需要全栈视野**：内部平台经常需要和前端、网关、各种中间件打交道，所以需要你知道这些组件的边界和基本原理。

所以，面试官不是在漫无目的地瞎问，他是在系统地**测绘你的知识地图**，看你基础的牢固程度和知识的广度。

让我们来系统性地复盘一下这些问题，你会发现它们其实非常有章法。

---

### **一面深度复盘：操作系统与Java基础**

一面几乎是一个**计算机基础**的标准化测试。

#### **操作系统（OS）系列问题**
这一串问题是一条完整的线，考察你对多任务并发的理解。

1.  **进程 vs 线程**：进程是资源分配单位，线程是CPU调度单位。线程共享进程资源。
2.  **临界区**：访问共享资源的代码段。**解决冲突**：通过**互斥锁（Mutex）**、**信号量（Semaphore）** 等同步机制，保证同一时刻只有一个线程进入临界区。
3.  **进程通信（IPC）**：管道、消息队列、共享内存、信号量、Socket。
4.  **死锁**：多个进程互相等待对方持有的资源。**条件**：互斥、占有且等待、不可剥夺、循环等待。**解决**：预防、避免（银行家算法）、检测与恢复。
5.  **中断**：CPU响应外部事件的机制。中断发生时，CPU保存现场，转去执行中断处理程序，执行完后恢复现场。
6.  **进程调度策略**：先来先服务（FCFS）、短作业优先（SJF）、最高响应比优先（HRRN）、时间片轮转（RR）、多级反馈队列。
7.  **同步 vs 互斥**：
    - **互斥**：保证**一个资源**一次只被一个进程访问。
    - **同步**：在互斥的基础上，控制多个进程**按照某种先后顺序**执行。

**高分回答示例（死锁条件）**：“死锁需要同时满足四个必要条件：首先是互斥，一个资源每次只能被一个进程使用；第二是占有且等待，一个进程在等待新资源时不会释放已占有的资源；第三是不可剥夺，资源只能由占有它的进程主动释放；最后是循环等待，存在一个进程资源的环形等待链。我们破坏其中任意一个条件即可预防死锁，比如申请所有资源成功后才执行，否则就等待，这样可以破坏‘占有且等待’条件。”

#### **网络系列问题**
1.  **TCP vs UDP**：面向连接/无连接、可靠/不可靠、有序/无序、字节流/数据报、速度慢/快。
2.  **HTTP/2 vs HTTP/3**：
    - **HTTP/2**：二进制分帧、多路复用、头部压缩、服务器推送。**底层仍是TCP**。
    - **HTTP/3**：基于**QUIC协议**（运行在UDP之上），解决了HTTP/2中TCP队头阻塞的问题，连接迁移能力更强。
3.  **输入URL到渲染**：这是一个经典问题，涵盖DNS解析、TCP连接、HTTP请求、服务器处理、浏览器解析渲染（HTML/CSS/JS）等步骤。
4.  **三次握手**：SYN -> SYN-ACK -> ACK。目的是同步序列号，建立可靠连接。

#### **Java基础系列问题**
1.  **浅拷贝 vs 深拷贝**：浅拷贝复制对象本身（基本类型复制值，引用类型复制地址）。深拷贝会递归复制所有引用指向的对象。
2.  **泛型**：编译期技术，用于类型检查和安全。**原理是类型擦除**，编译后泛型信息会被擦除为原生类型（如`List<String>` -> `List`），并通过强制转型和桥方法保证类型安全。**场景**：集合类（`List<String>`）、通用工具类。
3.  **整型缓存**：Java为`-128`到`127`的`Integer`对象提供了缓存（`IntegerCache`）。`Integer a = 100; Integer b = 100;` 时，`a == b`为true；但`Integer a = 200; Integer b = 200;` 时，`a == b`为false。**比较时一定要用`equals()`**。
4.  **自动装箱**：`Integer i = 10;` 等价于 `Integer i = Integer.valueOf(10);`。
5.  **红黑树**：一种自平衡的二叉查找树。**特性**：节点红或黑；根节点黑；红色节点的子节点必须为黑；从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。**应用**：Java `HashMap`（JDK8+，链表转红黑树）、`TreeMap`。
6.  **HashMap并发问题**：
    - **扩容死链**：JDK7及之前，并发扩容时可能导致链表形成环，引起CPU 100%。
    - **数据覆盖**：并发put时可能导致数据被覆盖。
7.  **ArrayList vs LinkedList**：数组 vs 双向链表。随机访问O(1) vs O(n)；头尾插入O(1) vs O(1)；中间插入O(n) vs O(n)（但LinkedList只需改指针，实际更快）。
8.  **复制数组效率最高**：`System.arraycopy()`是native方法，效率最高。
9.  **设计模式**：单例、工厂、观察者、代理、装饰器等。能说出应用场景即可。

---

### **二面深度复盘：项目、场景与算法**

二面更偏向于应用和思维。

1.  **0.1 + 0.2 == 0.3**：
    - **答案**：`false`。
    - **原因**：浮点数精度丢失。0.1和0.2在二进制中是无限循环小数，无法精确表示。
    - **解决方案**：使用`BigDecimal`进行精确计算（注意要用`String`构造器），或者判断两数差的绝对值是否小于一个极小的误差值（如`1e-10`）。

2.  **请求头过大报错**：
    - **前端**：优化Cookie，减少不必要的字段。压缩数据。
    - **后端**：检查业务逻辑，是否在Header或Cookie中塞入了过多数据。调整Web服务器（如Nginx、Tomcat）的配置，增大`client_header_buffer_size`和`large_client_header_buffers`。
    - **网关**：在网关层对Header大小做限制和过滤，拦截异常请求，保护后端服务。

3.  **算法：奇偶分离**
    这道题是**快速排序分区思想**的变种。使用双指针，从左找偶数，从右找奇数，然后交换。
    ```java
    public void sortArrayByParity(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            // 从左往右找第一个偶数
            while (left < right && nums[left] % 2 != 0) left++;
            // 从右往左找第一个奇数
            while (left < right && nums[right] % 2 == 0) right--;
            // 交换
            if (left < right) {
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
                left++;
                right--;
            }
        }
    }
    ```

---

### **如何应对“业务含糊不清”的回答**

面试官说业务“杂”，是用户增长方向，这非常典型。

- **用户增长团队**的核心目标是：**拉新、促活、留存**。
- **做的“杂”**：意味着他们可能会做各种工具和系统来实现这个目标，例如：
    - **活动平台**：快速配置营销活动（发券、抽奖）。
    - **数据平台**：分析用户行为，找出增长点。
    - **推送平台**：实现消息Push、短信、邮件等触达手段。
    - **AB测试平台**：验证哪种方案更有效。
- **你的应对策略**：在反问环节，可以这样问：
    “听起来业务非常丰富，很有挑战。我想了解一下，团队目前最主要的业务目标是什么呢？是提升某个核心指标的转化率，还是建设一个通用的增长中台？我过去在[你的项目经验]中积累的经验，感觉和[你推测的他们的业务]非常匹配。”

### **总结与建议**

你的面试表现其实很不错！面试官问得广而基础，你大部分都答上来了，这说明你的基本功很扎实。

- **你的优势**：**基础非常好**。操作系统、网络、Java这些核心知识点掌握得很牢固。
- **给你的建议**：
    1.  **补全知识广度**：简单了解一些前端（HTTP头、浏览器）、网关（Nginx）的常识，这对全栈/平台开发很重要。
    2.  **深入项目思考**：对自己的项目，要多思考一层：“如果请求头大了怎么办？”“如果数字精度要求极高怎么办？”。体现你的技术深度和主动思考能力。
    3.  **自信沟通**：当面试官说业务“杂”时，不要慌，这往往是常态。把它理解成“技术多样性”和“高挑战性”，并表达出你愿意学习和迎接挑战的态度。

这场面试的“水”恰恰说明你的基础关过得很好，面试官没有遇到需要深入追问来探你底的点。接下来很可能会有更深入的第三轮技术面或HR面，继续加油！

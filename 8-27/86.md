这是一场非常全面的Java后端面试，涵盖了并发、JVM、集合、数据库、Redis和编码能力。下面我为你提供一份详细的解答。

---

### **1. 线程池原理，核心线程满了后会干啥？**

**线程池工作流程（以 `ThreadPoolExecutor` 为例）：**
1.  提交一个新任务。
2.  如果当前运行的线程数 < `corePoolSize`，则**创建新线程**来执行任务。
3.  如果运行的线程数 >= `corePoolSize`，则尝试将任务**放入工作队列（BlockingQueue）**。
4.  如果队列**已满**，且运行的线程数 < `maximumPoolSize`，则**创建新的非核心线程**来执行任务。
5.  如果队列已满，且运行的线程数已达 `maximumPoolSize`，则根据**拒绝策略（RejectedExecutionHandler）** 来处理这个任务（如抛出异常、直接丢弃等）。

**核心线程满了后会干啥？**
**答：** 核心线程满了之后，**新来的任务会被放入工作队列中等待**，而不会立即创建新线程。只有在队列也满了之后，才会去创建非核心线程。

---

### **2. Java泛型原理 & 3. TypeReference原理 & 4. extends & super**

*   **泛型原理：** Java泛型是**编译期的概念**，通过**类型擦除**实现。编译器在编译时将泛型类型参数擦除为其边界（如无边界则擦除为Object），并插入必要的强制类型转换。运行时JVM看不到泛型信息。
*   **何时不擦除？** 泛型信息在某些情况下会被保留在**元数据（Signature属性）** 中，供编译器和一些框架（如Fastjson、Gson）通过反射在**运行时**获取。这就是 `TypeReference` 的工作原理。
*   **`TypeReference`（Fastjson）：** 通过创建一个匿名内部类并继承 `TypeReference<T>`，在运行时可以获取到父类的泛型参数T的实际类型（通过 `getGenericSuperclass()` 和 `ParameterizedType`）。这绕过了类型擦除的限制。
*   **`<? extends T>` 与 `<? super T>`（PECS原则）：**
    *   **`extends` (Producer Extends):** 用于**读取**。表示一个容器，里面存放的是**T或其子类**。你可以安全地从里面读取元素并赋值给T的引用。
    *   **`super` (Consumer Super):** 用于**写入**。表示一个容器，里面存放的是**T或其父类**。你可以安全地向里面写入T及其子类的对象。

---

### **5. 垃圾回收器及算法 & 6. CMS & 7. G1**

| 垃圾回收器 | 目标区域 | 算法 | 特点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **Serial** | 新生代 | 复制 | 单线程，STW | 客户端，资源受限环境 |
| **Parallel Scavenge** | 新生代 | 复制 | 多线程，**吞吐量优先** | 后台运算，批处理 |
| **ParNew** | 新生代 | 复制 | Serial的多线程版，与CMS配合 | 与CMS搭配的服务器应用 |
| **Serial Old** | 老年代 | 标记-整理 | Serial的老年代版 | CMS后备方案，客户端 |
| **Parallel Old** | 老年代 | 标记-整理 | Parallel Scavenge的老年代版 | 与Parallel Scavenge搭配 |
| **CMS** | 老年代 | **标记-清除** | **低延迟**，并发收集 | B/S系统，重视响应速度 |
| **G1** | 全堆 | **标记-整理** | **可控停顿时间**，Region模型 | 大内存，低延迟要求 |
| **ZGC** | 全堆 | **标记-整理** | **超低延迟**，色彩指针 | 超大堆，极致低延迟 |

*   **CMS (Concurrent Mark-Sweep) 流程：**
    1.  **初始标记 (STW):** 标记GC Roots能**直接关联**到的对象，速度很快。
    2.  **并发标记:** 从GC Roots开始进行**可达性分析**，与用户线程并发执行。
    3.  **重新标记 (STW):** 修正并发标记期间因用户线程运行而产生变动的标记记录。
    4.  **并发清除:** 清理死亡对象，与用户线程并发执行。
    *   **缺点：** 产生内存碎片；对CPU资源敏感。**需要配合Serial Old或ParNew**使用。

*   **G1 (Garbage-First) 流程与特点：**
    *   **Region模型：** 将堆划分为多个大小相等的Region，避免全堆操作。
    *   **流程：** 也分为初始标记、并发标记、最终标记、筛选回收四个阶段，与CMS类似但更复杂。
    *   **核心：** 在筛选回收阶段，G1可以**优先回收价值最大（垃圾最多）的Region**，从而在有限时间内获得最高的收集效率（Garbage-First名字由来）。

---

### **8. Java集合 & 9. HashMap.put流程**

**Java集合主要框架：**
*   **Collection:** `List` (ArrayList, LinkedList), `Set` (HashSet, TreeSet), `Queue` (LinkedList, PriorityQueue)
*   **Map:** `HashMap`, `LinkedHashMap`, `TreeMap`, `ConcurrentHashMap`

**`HashMap.put(key, value)` 流程 (JDK8):**
1.  计算key的hash值：`(h = key.hashCode()) ^ (h >>> 16)`。
2.  如果数组(table)为空或长度为0，则进行扩容(resize)。
3.  通过 `(n - 1) & hash` 计算桶下标。
4.  如果该桶为空，直接插入新节点。
5.  如果该桶不为空：
    *   如果第一个节点的key与待插入key相同，则准备覆盖。
    *   如果第一个节点是树节点，则调用红黑树的插入方法。
    *   否则，遍历链表。如果找到key相同的节点则覆盖；如果到尾节点都未找到，则尾插法插入新节点。插入后若链表长度 >= 8，则**树化（转化为红黑树）**。
6.  插入后，如果size超过阈值(容量*负载因子0.75)，则扩容。

**红黑树的好处：** 在哈希冲突严重时，将查找时间复杂度从链表的O(n)优化为O(log n)。

**红黑树搜索：** 和二叉搜索树一样，从根节点开始，比较key的大小，小于当前节点则向左搜索，大于则向右搜索，直到找到或为null。

---

### **10. MySQL四大隔离级别 & 11. 幻读 vs 不可重复读**

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 实现原理 |
| :--- | :--- | :--- | :--- | :--- |
| **读未提交** | ❌ | ❌ | ❌ | 无锁 |
| **读已提交** | ✅ | ❌ | ❌ | MVCC（每次查询生成新ReadView） |
| **可重复读** | ✅ | ✅ | ❌ | MVCC（事务开始时生成ReadView，贯穿整个事务） + **间隙锁** |
| **串行化** | ✅ | ✅ | ✅ | 加锁读写 |

*   **不可重复读 (Non-Repeatable Read):** 同一个事务内，两次读取**同一行**数据，结果不一致（因为别的事务修改了该行数据并提交了）。
*   **幻读 (Phantom Read):** 同一个事务内，两次执行**相同的查询**，返回的记录数不一致（因为别的事务插入或删除了符合查询条件的行并提交了）。
*   **关键区别：** 不可重复读针对的是**数据的修改（Update）**；幻读针对的是**数据行的增删（Insert/Delete）**。

---

### **12. Redis数据结构 & 13. 热Key/大Key问题**

*   **核心数据结构：** String, List, Hash, Set, Sorted Set (ZSet), HyperLogLog, Geo, Streams, Bitmaps。
*   **热Key问题：** 某个Key被高频访问，导致单个Redis实例负载过高。
    *   **解决：** ① 本地缓存（如Guava Cache）；② 读写分离；③ 使用Redis集群模式，通过`monitor`命令找出热Key并将其**复制到多个节点**（客户端采用随机访问）。
*   **大Key问题：** 某个Key对应的Value非常大（如大的Hash、String），导致读写慢、网络阻塞、迁移困难。
    *   **解决：** ① 拆分（如一个大的Hash拆成多个小的Hash）；② 压缩Value；③ 使用适合的数据类型（如不用String存JSON，改用Hash）；④ 异步删除（UNLINK命令）。

---

### **14. Redis集群查询路由**

Redis Cluster采用**去中心化**的架构。客户端可以连接任意节点。
1.  客户端向某个节点发送命令。
2.  该节点计算key对应的**哈希槽（slot）**：`slot = CRC16(key) % 16384`。
3.  如果该slot由当前节点负责，则直接执行命令。
4.  如果不是，则节点向客户端返回一个 **`MOVED` 重定向错误**，并告知正确节点的地址。
5.  客户端收到`MOVED`错误后，会**更新本地缓存的路由表**，然后重新向正确的节点发起请求。
**成熟的客户端（如Lettuce、JedisCluster）会在内部缓存slot与节点的映射关系，直接路由到正确节点，无需重定向。**

---

### **15. 手撕：本地限流器**

**要求：** 实现一个本地限流器，输入IP，如果ip一秒超过10次访问输出false。

**思路：** 使用**滑动窗口算法**（更精确）或**令牌桶算法**。这里用滑动窗口实现，使用一个Map记录每个IP的请求时间戳队列。

```java
import java.util.*;

public class LocalRateLimiter {
    // Key: IP, Value: 该IP最近请求的时间戳队列（毫秒）
    private Map<String, Queue<Long>> ipRequestMap = new HashMap<>();
    private final int maxRequests; // 窗口内最大请求数，10
    private final long timeWindow; // 窗口时间长度，1000ms

    public LocalRateLimiter(int maxRequests, long timeWindow) {
        this.maxRequests = maxRequests;
        this.timeWindow = timeWindow;
    }

    public synchronized boolean allowRequest(String ip) {
        long currentTime = System.currentTimeMillis();
        Queue<Long> timestamps = ipRequestMap.computeIfAbsent(ip, k -> new LinkedList<>());

        // 1. 移除窗口之外的过期请求时间戳
        while (!timestamps.isEmpty() && currentTime - timestamps.peek() > timeWindow) {
            timestamps.poll();
        }

        // 2. 判断当前窗口内请求数是否已达上限
        if (timestamps.size() < maxRequests) {
            timestamps.offer(currentTime); // 记录本次请求时间
            return true;
        } else {
            return false;
        }
    }
}
// 使用：
// LocalRateLimiter limiter = new LocalRateLimiter(10, 1000);
// if (limiter.allowRequest("192.168.1.1")) { // do something }
```

---

### **16. 手撕：字符串解码 (LeetCode 394)**

**思路：** 使用**栈**来处理嵌套的括号。遇到数字、字母、`[` 和 `]` 有不同的操作。

```java
class Solution {
    public String decodeString(String s) {
        // 存放重复次数的栈
        Stack<Integer> countStack = new Stack<>();
        // 存放已解码字符串的栈
        Stack<StringBuilder> stringStack = new Stack<>();
        // 当前正在构建的字符串
        StringBuilder currentString = new StringBuilder();
        // 当前解析的数字
        int currentNum = 0;

        for (char c : s.toCharArray()) {
            if (Character.isDigit(c)) {
                // 构建多位数
                currentNum = currentNum * 10 + (c - '0');
            } else if (c == '[') {
                // 遇到 '['，将当前数字和字符串入栈，并重置
                countStack.push(currentNum);
                stringStack.push(currentString);
                currentNum = 0;
                currentString = new StringBuilder();
            } else if (c == ']') {
                // 遇到 ']'，出栈，进行字符串拼接
                int count = countStack.pop();
                StringBuilder decodedString = stringStack.pop();
                // 将当前字符串重复count次，并附加到出栈的字符串后面
                for (int i = 0; i < count; i++) {
                    decodedString.append(currentString);
                }
                currentString = decodedString;
            } else {
                // 遇到普通字母，直接添加到当前字符串
                currentString.append(c);
            }
        }
        return currentString.toString();
    }
}
```

**示例解析 `"3[a2[c]]"`：**
1.  遇到 `'3'`：`currentNum = 3`
2.  遇到 `'['`：`countStack = [3]`, `stringStack = [""]`, 重置 `currentNum=0`, `currentString=""`
3.  遇到 `'a'`：`currentString = "a"`
4.  遇到 `'2'`：`currentNum = 2`
5.  遇到 `'['`：`countStack = [3, 2]`, `stringStack = ["", "a"]`, 重置 `currentNum=0`, `currentString=""`
6.  遇到 `'c'`：`currentString = "c"`
7.  遇到 `']'`：`count = 2`, `decodedString = "a"`, `currentString = "a" + "c"*2 = "acc"`
8.  遇到 `']'`：`count = 3`, `decodedString = ""`, `currentString = "" + "acc"*3 = "accaccacc"`
9.  返回 `"accaccacc"`

希望这份详细的解答能帮助你！

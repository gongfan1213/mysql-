好的，作为一位专业的Java开发工程师，我来详细解答这份字节跳动的三面面试题。虽然面试官风格让你觉得像KPI，但这些问题本身都是非常经典和重要的后端基础考察点。

---

### **1. 自我介绍**

（同上一个回答，此处略作调整以更贴合字节风格）
面试官您好，我叫[你的名字]，毕业于[你的学校][你的专业]。我主要专注于后端开发，对构建高并发、高可用的分布式系统有浓厚的兴趣和实践经验。

我曾在[某公司]实习，负责[某项目]的开发，其中攻克了[某个技术难点]。此外，我个人也深入研究过[某项技术，如JVM、并发编程等]，并完成了[某个有挑战性的个人项目]。

我的技术栈深度集中在Java生态，对JUC、JVM、Spring、MySQL、Redis、Kafka等技术有扎实的掌握，并且具备良好的算法和系统设计能力。我非常向往字节跳动技术驱动的文化，渴望在这里解决更有挑战性的问题。谢谢。

---

### **2. 介绍一个挑战性的需求**

**一句话总结**：“我负责了一个在高并发场景下保证数据最终一致性的分布式任务调度模块，通过**本地消息表+异步对账补偿**的方案，在系统吞吐量提升3倍的同时，将数据不一致率从千分之五降到了万分之二以下。”

*(如果面试官追问细节，可以展开：背景是系统重构，新老系统并行需要数据双写，挑战在于如何保证在两个系统写入时出现故障的情况下数据不丢失、不错乱。我通过记录每一条操作的日志到本地数据库，并启动定时任务扫描日志对数据进行比对和补偿，最终实现了高并发下的最终一致性。)*

---

### **3. 介绍一下进程和线程**

*   **进程**： 是**资源分配的基本单位**。可以理解为一个正在运行的程序的实例。每个进程都有自己独立的虚拟地址空间、代码、数据、系统资源（如打开的文件、信号量等）。进程间相互隔离，一个进程崩溃一般不会影响其他进程。
*   **线程**： 是**CPU调度的基本单位**。一个进程可以包含多个线程，这些线程**共享**进程的地址空间和资源。每个线程有自己独立的程序计数器、栈和寄存器状态。线程间通信非常方便（直接读写共享内存），但也因此需要同步机制（如锁）来避免竞态条件。
*   **比喻**： 进程像一个工厂，拥有独立的场地、仓库（内存空间、资源）；线程像工厂里的多条生产线（线程），共享工厂的场地和资源，协同完成生产任务。

---

### **4. 死锁是什么？**

死锁是指两个或两个以上的进程（或线程）在执行过程中，因**争夺资源**而造成的一种互相等待的现象。若无外力干涉，它们都将无法推进下去。

**产生死锁的四个必要条件（缺一不可）**：
1.  **互斥条件**： 一个资源每次只能被一个进程使用。
2.  **请求与保持条件**： 一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3.  **不剥夺条件**： 进程已获得的资源，在未使用完之前，不能被强行剥夺。
4.  **循环等待条件**： 若干进程之间形成一种头尾相接的循环等待资源关系。

---

### **5. 共享锁和排他锁**

*   **排他锁（Exclusive Lock, X Lock）**： 也叫**写锁**。当一个事务给数据加上排他锁后，其他事务**不能**再对该数据加任何类型的锁（包括共享锁和排他锁）。只有持有排他锁的事务才能对数据进行读写。`SELECT ... FOR UPDATE` 会加排他锁。
*   **共享锁（Shared Lock, S Lock）**： 也叫**读锁**。当一个事务给数据加上共享锁后，其他事务可以**继续加共享锁**来读取数据，但**不能**加排他锁来修改数据。`SELECT ... LOCK IN SHARE MODE` 会加共享锁。

**关系**： **共享锁与共享锁兼容，与排他锁互斥；排他锁与任何锁都互斥。**

---

### **6. 讲一下读写锁**

读写锁（ReadWriteLock）是共享锁和排他锁在应用层面的一个具体实现，它规定了**锁的降级**策略，特别适用于**读多写少**的场景，能大幅提升并发性能。

*   **规则**：
    *   **读-读不互斥**： 多个线程可以同时持有读锁，并发读取资源。
    *   **读-写互斥**： 如果一个线程持有写锁，其他线程不能获取读锁或写锁。如果一个线程持有读锁，其他线程不能获取写锁。
    *   **写-写互斥**： 同一时间只有一个线程能持有写锁。

*   **锁的降级**： 允许从**写锁**降级为**读锁**。即一个线程持有写锁后，可以再获取读锁，然后释放写锁。这样它仍然持有读锁，可以防止其他写线程修改数据，保证了数据可见性。**锁升级（读锁→写锁）通常是不支持的**，因为容易造成死锁。

---

### **7. 用 Java 实现一个读写锁**

以下是Java中`ReadWriteLock`接口的一个简单实现思路，展示了其核心逻辑。

```java
public class SimpleReadWriteLock {
    private int readers = 0;
    private int writers = 0;
    private int writeRequests = 0; // 写请求等待数，用于防止写线程饥饿

    public synchronized void lockRead() throws InterruptedException {
        // 当有线程正在写（writers > 0）或有线程在等待写（writeRequests > 0）时，读线程需要等待
        while (writers > 0 || writeRequests > 0) {
            wait();
        }
        readers++;
    }

    public synchronized void unlockRead() {
        readers--;
        notifyAll(); // 唤醒所有等待的写线程和读线程
    }

    public synchronized void lockWrite() throws InterruptedException {
        writeRequests++; // 表明有写线程在等待
        // 当有线程正在读（readers > 0）或正在写（writers > 0）时，写线程需要等待
        while (readers > 0 || writers > 0) {
            wait();
        }
        writeRequests--;
        writers++;
    }

    public synchronized void unlockWrite() {
        writers--;
        notifyAll(); // 唤醒所有等待的写线程和读线程
    }
}
```
**注意**： 这是一个基础实现，Java标准库中的`ReentrantReadWriteLock`要复杂得多，支持重入、公平锁、锁降级等特性。

---

### **8. 计算机网络 OSI 七层模型讲一下**

从下到上：
1.  **物理层**： 传输原始比特流，定义电气、机械规格。如网线、光纤。
2.  **数据链路层**： 将比特流封装成**帧**，提供节点到节点的可靠传输。MAC地址、交换机工作在此层。
3.  **网络层**： 负责**寻址和路由**，将数据包从源主机送到目的主机。**IP协议**、路由器工作在此层。
4.  **传输层**： 提供**端到端**的可靠数据传输。**TCP（可靠）**、**UDP（不可靠）** 协议工作在此层。
5.  **会话层**： 建立、管理和终止应用程序之间的会话。
6.  **表示层**： 负责数据格式转换、加密解密、压缩解压缩。
7.  **应用层**： 为应用程序提供网络服务接口。**HTTP、HTTPS、FTP、DNS**等协议工作在此层。

**实际中常用的是TCP/IP五层模型**（将上三层合并为应用层）。

---

### **9. 浏览器输入一个 URL 的过程**

1.  **DNS解析**： 浏览器解析URL，提取域名。查询本地缓存→操作系统缓存→路由器缓存→ISP的DNS服务器，最终获取到域名对应的IP地址。
2.  **建立TCP连接**： 浏览器向服务器的IP地址发起TCP三次握手，建立连接。
3.  **发送HTTP请求**： 浏览器构建HTTP请求报文（包含请求行、请求头、请求体），通过TCP连接发送给服务器。
4.  **服务器处理请求并返回响应**： 服务器处理请求，访问数据库等，生成HTTP响应报文（状态行、响应头、响应体）。
5.  **浏览器解析渲染页面**：
    *   **解析HTML**，构建DOM树。
    *   **解析CSS**，构建CSSOM树。
    *   将DOM和CSSOM合并成**渲染树**。
    *   **布局**：计算每个节点的几何信息。
    *   **绘制**：将各个节点绘制到屏幕上。
6.  **断开连接**： TCP四次挥手，断开连接。

---

### **10. 讲一下快速排序**

快速排序是一种**分治**算法，平均时间复杂度O(n log n)，最坏O(n²)（如数组已排序）。

**步骤**：
1.  **选择基准**： 从数组中选择一个元素作为“基准”。
2.  **分区操作**： 重新排列数组，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任一边）。操作结束后，该基准就处于数列的中间位置。
3.  **递归排序**： 递归地将小于基准值的子数组和大于基准值的子数组进行快速排序。

**Java实现**：
```java
public void quickSort(int[] arr, int low, int high) {
    if (low < high) {
        int pivotIndex = partition(arr, low, high);
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

private int partition(int[] arr, int low, int high) {
    int pivot = arr[high]; // 选择最右元素作为基准
    int i = low - 1; // 指向小于pivot区域的最后一个元素
    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, high); // 将基准放到正确位置
    return i + 1;
}

private void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```

---

### **11 & 12. 压缩算法（整数数组，1-10 / 1-10000）**

核心思想：**用更少的比特位来表示一个数字**。

*   **情况一：数字范围1-10**
    *   **分析**： 10个数只需要4个比特位（2^4=16 > 10）就能表示。而一个int占32位，浪费严重。
    *   **方案**： **位压缩**。可以将多个数字打包进一个int。一个32位int可以存放 `32 / 4 = 8` 个数字。
    *   **例如**： 数组 `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`。
        *   第一个int：存放 `1, 2, 3, 4, 5, 6, 7, 8`。
        *   第二个int：存放 `9, 10` 和6个0。
    *   **压缩率**： 原始空间 `10 * 32 bit = 320 bit`。压缩后 `2 * 32 bit = 64 bit`。压缩比为 **5 : 1**。

*   **情况二：数字范围1-10000**
    *   **分析**： 10000个数需要14个比特位（2^14=16384 > 10000）。
    *   **方案**： 同样使用位压缩。一个32位int可以存放 `32 / 14 = 2` 个数字（还剩下4位浪费）。
    *   **区别**： 相比1-10的情况，每个数字占用的比特位变多了（从4位到14位），所以一个int能打包的数字变少了，压缩效率会降低，但依然有效。
    *   **压缩率**： 原始空间 `n * 32 bit`。压缩后约为 `n * 16 bit`（因为两个数字用一个int）。压缩比约为 **2 : 1**。

**结论**： **数字的范围越小，位压缩的效率越高。**

---

### **13. 手撕：给一个数字以及一个数字集合，给出用该数字集合实现不大于该数字的最大数**

**题意**： 给定一个目标数 `target`（字符串或整数形式），和一个数字集合 `digits[]`（例如 `[1, 2, 4, 9]`），要求用集合中的数字（可以重复使用）拼出一个**不大于target的最大整数**。

**思路（回溯/DFS）**：
这是一个类似**数位DP**的问题。我们需要从高位到低位去构造数字。

1.  **排序**： 先将数字集合 `digits` 排序。
2.  **DFS构造**：
    *   从target的最高位开始尝试。
    *   对于当前位，我们尝试从大到小（为了尽可能接近目标）选取集合中**小于等于**target对应位数字的数。
    *   **情况1**： 如果能找到一位数字**等于**target的当前位，那么选择它，并继续递归地构造下一位，希望后面的位也能和target匹配。
    *   **情况2**： 如果找不到相等的，就选择**小于**当前位的最大数字，选定后，**后面的所有位都可以直接选择集合中最大的数字**，因为此时已经确定数字的前面部分小于target，后面部分可以任意放大到最大。
    *   **情况3**： 如果在某一位上，没有数字小于等于target的当前位（比如当前位是’1‘，但集合最小是’2‘），说明当前分支失败，需要**回溯**到上一位。上一位不能再用相等的数字，而应该换一个更小的，然后再把后面所有位放到最大。

**示例**： `target = 23121`, `digits = [1, 2, 4, 9]`
*   第一位（万位）： target是’2‘。集合中小于等于2的有`[2, 1]`。我们先尝试选’2‘（等于）。
*   第二位（千位）： target是’3‘。集合中小于等于3的有`[2, 1]`。最大是’2‘（小于）。此时，我们已经确定前两位”22“小于”23“，所以后面三位可以直接全部用集合中最大的’9‘填充。因此结果是 `22999`。
*   如果第一位选’1‘，后面四位全选’9‘，得到 `19999`，比 `22999` 小。所以 `22999` 是答案。

**Java代码实现（DFS）**：
```java
public String maxNumber(String target, int[] digits) {
    Arrays.sort(digits); // 排序，方便从大到小选
    char[] t = target.toCharArray();
    char[] res = new char[t.length];
    // 尝试构建一个和target等长的数字
    if (dfs(t, digits, res, 0, true)) {
        return new String(res);
    }
    // 如果等长构建失败（比如第一位就找不到<=的数字），则构建一个比target少一位的最大数（全部用digits中最大数字）
    return buildMaxNumber(digits, t.length - 1);
}

// t: target字符数组, res: 结果数组, idx: 当前构造到第几位, tight: 是否受到target的约束（前几位是否和target完全一样）
private boolean dfs(char[] t, int[] digits, char[] res, int idx, boolean tight) {
    if (idx == t.length) return true; // 构造完成

    int upperBound = tight ? (t[idx] - '0') : 9; // 当前位能选择的最大值
    // 从大到小遍历数字集合
    for (int i = digits.length - 1; i >= 0; i--) {
        int d = digits[i];
        if (d > upperBound) continue;

        res[idx] = (char) (d + '0');
        boolean newTight = tight && (d == upperBound);
        if (dfs(t, digits, res, idx + 1, newTight)) {
            return true;
        }
        // 如果当前选择d导致后续无法构建，且d==upperBound，不能直接break，需要尝试更小的d？
        // 实际上，如果DFS失败，说明当前路径走不通，需要循环尝试下一个更小的数字。
    }
    return false; // 当前位没有数字可选，回溯
}

// 构建一个长度为len的、由digits中最大数字组成的数
private String buildMaxNumber(int[] digits, int len) {
    int maxDigit = digits[digits.length - 1];
    char[] chars = new char[len];
    Arrays.fill(chars, (char) (maxDigit + '0'));
    return new String(chars);
}
```

希望这份详细的解答能帮助你更好地理解这些经典问题！

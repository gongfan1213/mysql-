这是一份非常典型的美团Java后端二面面经，考察点全面，涉及Java基础、JVM、并发、框架、数据库、中间件、系统设计和实战经验。下面我将为你提供一份**高质量的回答要点梳理**，帮助你准备类似面试。

---

### 1. HashMap 和 ConcurrentHashMap 的区别
- **HashMap**：线程不安全，多线程下扩容可能导致死循环或数据丢失。JDK8后改为数组+链表/红黑树。
- **ConcurrentHashMap**：
  - JDK7：分段锁（Segment），降低锁粒度。
  - JDK8：改为 `synchronized` + `CAS` 锁单个桶（链表头/树根），并发度更高。

### 2. JVM 内存模型（注意区分“内存结构”和“内存模型”）
- **JMM** 是抽象规范，定义线程如何与内存交互。
- 核心概念：主内存 vs 工作内存、happens-before、volatile、锁的内存语义。
- 目的是解决多线程的可见性、有序性、原子性问题。

### 3. synchronized 和 ReentrantLock 的区别
| 特性 | synchronized | ReentrantLock |
|------|--------------|---------------|
| 用法 | 关键字，自动释放锁 | API 调用，需手动 lock/unlock |
| 公平锁 | 非公平 | 可选公平/非公平 |
| 条件变量 | 通过 wait/notify | 可绑定多个 Condition |
| 可中断 | 不支持显式中断 | 支持 lockInterruptibly() |
| 性能 | JDK6 后优化，接近 | 在高竞争下略优 |

### 4. Spring IOC 和 AOP 的原理
- **IOC**：控制反转，由容器管理对象生命周期和依赖关系。
  - 实现：通过 BeanFactory/ApplicationContext、BeanDefinition、反射、依赖注入（构造器/Setter）。
- **AOP**：面向切面编程，解耦横切关注点（如日志、事务）。
  - 实现：动态代理（JDK 基于接口 / CGLIB 基于子类），织入（Weaving）时机可在编译期或运行期。

### 5. 分布式事务
- **CAP/BASE 理论**为基础。
- 常见方案：
  - **2PC/3PC**：强一致性，但性能差、可用性低。
  - **TCC**：Try-Confirm-Cancel，业务侵入性强，保证最终一致性。
  - **本地消息表**：异步确保，通过消息队列+本地事务。
  - **Seata**：开源框架，支持 AT、TCC 等模式。

### 6. MySQL 索引
- **B+Tree** 结构：适合范围查询，叶子节点有序链表。
- **聚簇索引**（主键） vs **非聚簇索引**（二级索引）。
- **最左前缀原则**：复合索引需按定义顺序使用。
- **索引失效场景**：函数操作、类型隐式转换、OR 条件不当等。

### 7. Redis 的持久化机制
- **RDB**：快照方式，fork 子进程写入磁盘，恢复快但可能丢数据。
- **AOF**：追加日志，可配置每秒/每次同步，数据更安全但文件大、恢复慢。
- **混合持久化**（Redis 4.0+）：RDB 全量 + AOF 增量，兼顾速度和安全性。

### 8. 高并发场景设计题（秒杀系统）
- **核心思路**：削峰、限流、缓存、异步。
- **具体措施**：
  - 前端：静态化页面、按钮防重复点击。
  - 网关：限流（令牌桶/漏桶）。
  - 缓存：Redis 预减库存（Lua 脚本保证原子性）。
  - 消息队列：异步处理下单流程（如 RabbitMQ）。
  - 数据库：库存字段加乐观锁，防止超卖。

### 9. SpringBoot 的自动配置原理
- **核心注解**：`@SpringBootApplication` → `@EnableAutoConfiguration`。
- **流程**：
  1. 扫描 `META-INF/spring.factories` 中的 `EnableAutoConfiguration` 配置类。
  2. 根据条件注解（如 `@ConditionalOnClass`）按需加载 Bean。
  3. 通过 `spring-boot-autoconfigure` 包提供大量默认配置。

### 10. RabbitMQ 的交换机类型
- **Direct**：路由键精确匹配。
- **Topic**：路由键模糊匹配（`*` 匹配一个词，`#` 匹配多个词）。
- **Fanout**：广播到所有绑定队列。
- **Headers**：通过消息头匹配（少用）。
- **常用场景**：订单系统用 Direct/Topic，日志广播用 Fanout。

### 11. CAS 的原理，以及 MySQL 乐观锁的实现方式
- **CAS**：Compare-And-Swap，CPU 原子指令（如 `cmpxchg`），解决并发修改问题，但存在 ABA 问题（可通过版本号解决）。
- **MySQL 乐观锁**：通过版本号或时间戳字段，更新时带条件判断（如 `UPDATE table SET stock=stock-1 WHERE id=1 AND stock>0`）。

### 12. MyBatis 和 MyBatis-Plus 的区别
- **MyBatis**：ORM 框架，需手动写 SQL 和映射文件。
- **MyBatis-Plus**：增强工具，提供：
  - 通用 CRUD 方法（`BaseMapper`）。
  - 条件构造器（`QueryWrapper`）。
  - 分页插件、代码生成器等。

### 13. @Controller 和 @RestController 的区别
- **@Controller**：需配合 `@ResponseBody` 返回 JSON 数据。
- **@RestController** = `@Controller` + `@ResponseBody`，直接返回 JSON/XML。

### 14. 常见设计模式，饿汉式和懒汉式单例区别
- **饿汉式**：类加载时初始化，线程安全但可能浪费内存。
- **懒汉式**：首次使用时初始化，需加锁（DCL 双检锁优化）保证线程安全。

### 15. SpringBoot 参数配置的几种方式
1. `application.properties` / `application.yml`。
2. 命令行参数（`--key=value`）。
3. 环境变量。
4. `@ConfigurationProperties` 绑定配置类。
5. 外部配置文件（`spring.config.location`）。

### 16. 一次实际的线上问题排查经历
- **模板**：
  1. 现象：接口超时/CPU 飙升。
  2. 排查：日志 → 监控（APM）→ 线程 Dump → 内存 Dump。
  3. 原因：如死锁、慢 SQL、内存泄漏。
  4. 解决：优化代码/索引/JVM 参数。
  5. 预防：加监控、代码 Review、压测。

---

### 反问环节（展示你的思考）
- 团队业务方向和技术挑战？
- 新人培养机制和项目参与流程？
- 技术栈演进规划（如云原生、中间件选型）？

---

**总结**：美团二面注重深度和广度，尤其关注并发、分布式、数据库和系统设计。建议结合项目经验举例回答，避免纯理论背诵。如果你需要某个问题的详细版答案或模拟回答，我可以继续为你展开。

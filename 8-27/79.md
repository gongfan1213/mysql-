## 进程和线程的联系与区别？进程通信的方法

**联系：**
- 进程和线程都是操作系统进行任务调度的基本单位。
- 一个进程可以包含多个线程，这些线程共享进程的资源（如内存、文件句柄等）。

**区别：**
- **资源分配**：进程是资源分配的基本单位，拥有独立的地址空间；线程是CPU调度的基本单位，共享进程的资源。
- **开销**：进程创建、切换和销毁的开销较大；线程的上下文切换开销较小。
- **独立性**：进程间相互独立，一个进程崩溃不会影响其他进程；线程间共享资源，一个线程崩溃可能导致整个进程崩溃。
- **通信方式**：进程间通信需要IPC机制；线程间可以直接读写共享数据（但需要同步机制）。

**进程通信的方法：**
1. **管道（Pipe）**：半双工，用于父子进程或兄弟进程之间的通信。
2. **命名管道（FIFO）**：允许无亲缘关系的进程通信。
3. **消息队列**：消息的链表，允许多个进程读写。
4. **共享内存**：多个进程共享同一块内存区域，需要同步机制（如信号量）。
5. **信号量**：用于同步进程或线程对共享资源的访问。
6. **套接字（Socket）**：可用于不同主机间的进程通信。
7. **信号（Signal）**：用于通知进程某个事件已发生。

---

## 对死锁的理解？举一个项目中的例子

**死锁**是指两个或多个进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉，这些进程都无法继续执行。

**死锁产生的四个必要条件：**
1. **互斥条件**：资源每次只能被一个进程使用。
2. **请求与保持条件**：进程在请求资源时保持对已有资源的占有。
3. **不可剥夺条件**：进程已获得的资源在未使用完之前不能被强行剥夺。
4. **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

**项目中的例子（数据库表锁的死锁）：**
在事务中同时更新多张表时，如果两个事务以不同的顺序请求锁，可能发生死锁。例如：
- 事务A先锁表X，再请求锁表Y；
- 事务B先锁表Y，再请求锁表X；
此时事务A等待事务B释放Y，事务B等待事务A释放X，形成死锁。数据库系统会检测并回滚其中一个事务。

---

## 内核态和用户态的区别？OS为什么要做这样的区分？什么情况下会进入内核态？为什么内核态切换用户态成本高？

**区别：**
- **用户态**：运行用户程序，只能执行非特权指令，不能直接访问硬件资源。
- **内核态**：运行操作系统内核，可以执行特权指令，直接访问硬件资源。

**OS区分的原因：**
- **安全性**：防止用户程序直接访问硬件或内核数据，避免系统崩溃。
- **稳定性**：通过权限控制，确保系统资源被合理分配和管理。

**进入内核态的情况：**
1. 系统调用（如文件读写、网络通信）。
2. 异常事件（如除零错误、缺页异常）。
3. 外部中断（如硬件中断、时钟中断）。

**切换成本高的原因：**
- 需要保存和恢复上下文（寄存器状态、堆栈等）。
- 需要切换特权级别，进行权限检查。
- 可能触发TLB刷新和缓存失效。

---

## 讲讲计算机网络四层模型，ARP协议工作在哪一层？是用来干什么的？

**四层模型（TCP/IP模型）：**
1. **网络接口层**（对应OSI的数据链路层和物理层）：负责数据帧的传输和接收。
2. **网络层**（IP层）：负责寻址和路由（IP、ICMP、ARP）。
3. **传输层**：提供端到端的通信（TCP、UDP）。
4. **应用层**（对应OSI的会话层、表示层和应用层）：提供应用程序服务（HTTP、FTP、DNS）。

**ARP协议：**
- 工作在网络层（但通常被认为在数据链路层和网络层之间）。
- 功能：通过IP地址查询对应的MAC地址，实现局域网内设备的通信。

---

## NAT协议如何进行公私网映射？

NAT（网络地址转换）将私网IP地址和端口映射到公网IP和端口：
- 当私网设备访问公网时，NAT路由器会记录源IP和端口，并将其转换为公网IP和端口。
- 公网返回数据时，NAT路由器根据映射表将数据转发给对应的私网设备。
- 通过不同的端口号区分私网中的多个设备。

---

## 划分子网解决了什么问题？

1. **减少网络拥堵**：缩小广播域，减少广播风暴。
2. **提高管理灵活性**：公司可以自主分配IP地址，便于内部网络管理。
3. **优化路由**：减少路由表大小，提高路由效率。

---

## 子网之间如何进行连接？

通过路由器连接不同子网：
- 路由器每个端口连接一个子网，根据IP地址和子网掩码判断数据包转发方向。
- 使用路由协议（如OSPF、BGP）或静态路由配置实现子网间的通信。

---

## MTU和分片了解吗？

- **MTU（最大传输单元）**：数据链路层允许传输的最大数据包大小（如以太网为1500字节）。
- **分片**：当IP数据包大小超过MTU时，网络层将其分割成多个片段传输，并在目的地重组。
- **MS（最大报文段大小）**：TCP层为了避免分片，通过MSS协商传输的数据段大小。

---

## 静态路由和动态路由的区别

- **静态路由**：手动配置路由表，适用于小型网络，简单但无法自适应网络变化。
- **动态路由**：通过路由协议（如OSPF、BGP）自动更新路由表，适用于大型网络，能适应拓扑变化。

---

## DNS查询的过程

1. 浏览器缓存 → 2. 系统缓存（hosts文件） → 3. 本地DNS服务器 → 4. 递归查询根DNS、顶级域DNS、权威DNS，最终返回IP地址。

---

## 为什么TCP握手是3次挥手是4次？

- **三次握手**：确保双方收发能力正常（SYN、SYN-ACK、ACK）。
- **四次挥手**：因为TCP连接是全双工的，每方向需要单独关闭（FIN、ACK、FIN、ACK）。

---

## TCP拥塞避免

通过慢启动、拥塞避免、快重传和快恢复算法动态调整发送速率，避免网络过载。

---

## Raft算法原理？属于CAP模型中的哪种模型？Raft算法只保证一半写成功，那如果读到同步失败的从节点上怎么办？

- **原理**：通过选举领导者、日志复制和安全性保证一致性。
- **CAP**：属于CP（一致性和分区容错性）。
- **读取问题**：客户端通过主节点确认日志提交索引，确保读取最新数据（或使用ReadIndex机制）。

---

## 实习中如何定位慢查询？优化思路？

- **定位**：使用慢查询日志、EXPLAIN分析执行计划。
- **优化**：添加索引、优化SQL语句、分库分表、调整数据库配置。

---

## MySQL索引的数据结构？为什么这么设计？为什么不能每个字段都加索引？

- **数据结构**：B+树，支持范围查询和高效排序。
- **设计原因**：减少磁盘I/O，平衡查询效率与维护成本。
- **不能每个字段加索引**：索引占用存储空间，降低写操作性能（插入/更新/删除需维护索引）。

---

## 4层和7层负载均衡

- **4层（传输层）**：基于IP和端口转发（如LVS）。
- **7层（应用层）**：基于内容转发（如Nginx），支持更复杂的策略。

---

## 分布式锁实现

- 基于数据库（唯一约束）、Redis（SETNX）、ZooKeeper（临时有序节点）。

---

## RPC与SDK调用的区别

- **RPC**：远程过程调用，跨网络通信，需序列化和网络传输。
- **SDK调用**：本地API调用，无网络开销。

---

## 手撕代码

### 删除链表中重复节点
```python
def deleteDuplicates(head):
    if not head:
        return head
    cur = head
    while cur and cur.next:
        if cur.val == cur.next.val:
            cur.next = cur.next.next
        else:
            cur = cur.next
    return head
```

### 合并有序数组
```python
def merge(nums1, m, nums2, n):
    i, j, k = m-1, n-1, m+n-1
    while j >= 0:
        if i >= 0 and nums1[i] > nums2[j]:
            nums1[k] = nums1[i]
            i -= 1
        else:
            nums1[k] = nums2[j]
            j -= 1
        k -= 1
```

---

以上是对面试题的详细解答，如有需要可进一步深入讨论某个话题！

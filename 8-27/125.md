好的，这是一个非常典型的面试题组合，涵盖了数据结构与算法、Java框架底层原理和新兴技术领域。我们来逐一详细解答。

---

### **3. 五种排序算法及复杂度分析**

这里介绍五种经典且重要的排序算法。

1.  **冒泡排序**
    *   **思想**：重复遍历列表，比较相邻元素，如果顺序错误就交换它们。每一轮遍历会将当前最大的元素“冒泡”到正确位置。
    *   **时间复杂度**：
        *   最好情况（已排序）：O(n)。只需要遍历一次，发现没有交换发生即可结束。
        *   最坏情况（逆序）：O(n²)。需要 n-1 轮遍历，每轮比较 n-i 次。
        *   平均情况：O(n²)。
    *   **空间复杂度**：O(1)。是原地排序，只需要常数级的额外空间。

2.  **选择排序**
    *   **思想**：在未排序序列中找到最小（或最大）元素，存放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
    *   **时间复杂度**：
        *   最好、最坏、平均情况均为 O(n²)。因为无论序列如何，都需要进行 n(n-1)/2 次比较。
    *   **空间复杂度**：O(1)。是原地排序。

3.  **插入排序**
    *   **思想**：将待排序的元素一个个地插入到已经排好序的序列中的适当位置，直到全部插入完毕。
    *   **时间复杂度**：
        *   最好情况（已排序）：O(n)。每个元素只需要比较一次。
        *   最坏情况（逆序）：O(n²)。每个元素都需要和已排序的所有元素比较。
        *   平均情况：O(n²)。
    *   **空间复杂度**：O(1)。是原地排序。

4.  **快速排序**
    *   **思想**：分治法。选择一个“基准”元素，将数组分成两个子数组：小于基准的和大于基准的。然后递归地对子数组进行快速排序。
    *   **时间复杂度**：
        *   最好情况（每次划分都很均匀）：O(n log n)。
        *   最坏情况（每次划分都极不均匀，如基准是最大/最小值）：O(n²)。
        *   平均情况：O(n log n)。
    *   **空间复杂度**：O(log n)。主要是递归调用栈的深度，平均情况下为 O(log n)，最坏情况下为 O(n)。

5.  **归并排序**
    *   **思想**：分治法。将数组递归地分成两半，分别对两半进行排序，然后将两个已排序的半部分合并成一个完整的排序数组。
    *   **时间复杂度**：
        *   最好、最坏、平均情况均为 O(n log n)。因为它总是将数组对半分割。
    *   **空间复杂度**：O(n)。合并过程需要一个与原数组同样大小的临时数组。

**总结对比：**

| 排序算法 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 稳定性 |
| :--- | :---: | :---: | :---: | :---: | :---: |
| 冒泡排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 |
| 选择排序 | O(n²) | O(n²) | O(n²) | O(1) | 不稳定 |
| 插入排序 | O(n) | O(n²) | O(n²) | O(1) | 稳定 |
| **快速排序** | **O(n log n)** | **O(n log n)** | O(n²) | O(log n) | 不稳定 |
| **归并排序** | **O(n log n)** | **O(n log n)** | **O(n log n)** | O(n) | 稳定 |

*   **哪一种时间复杂度最低？**
    *   从平均和最好情况看，**快速排序** 和 **归并排序** 的 O(n log n) 是最优的。
    *   如果考虑最坏情况，**归并排序** 的 O(n log n) 是稳定的最优解，而快速排序在最坏情况下会退化为 O(n²)。
    *   在实际应用中，快速排序通常因其常数因子更小而被认为是最快的通用排序算法，但标准库（如Java的 `Arrays.sort()`）通常会使用混合算法（如Timsort，基于归并排序和插入排序）来避免最坏情况并保证稳定性。

---

### **5. Spring注解分类**

可以按照功能进行分类：

1.  **核心配置与组件扫描**
    *   `@Configuration`：声明一个类为配置类，替代XML文件。
    *   `@ComponentScan`：指定Spring要扫描的包路径，寻找带有 `@Component` 及其衍生注解的类。
    *   `@Bean`：在配置类的方法上使用，将方法返回的对象注册为Spring容器中的Bean。替代XML中的 `<bean>` 标签。

2.  **Bean的定义与作用域**
    *   `@Component`：通用的 stereotype 注解，标识一个类为Spring组件（Bean）。
    *   `@Repository`：标注数据访问层（DAO）组件。
    *   `@Service`：标注业务逻辑层（Service）组件。
    *   `@Controller` / `@RestController`：标注表现层（Web MVC Controller）组件。
    *   `@Scope`：指定Bean的作用域，如 `singleton`（默认，单例）、`prototype`（原型）、`request`、`session`等。

3.  **依赖注入**
    *   `@Autowired`：自动按类型（byType）注入依赖。可用于字段、setter方法、构造方法上。
    *   `@Qualifier`：与 `@Autowired` 配合使用，当有多个相同类型的Bean时，按名称（byName）指定要注入的Bean。
    *   `@Resource`：JDK提供的注解，默认按名称（byName）注入，找不到再按类型（byType）注入。
    *   `@Value`：注入简单类型属性、SpEL表达式或配置文件中的值（如 `@Value("${db.url}")`）。

4.  **AOP与事务**
    *   `@Aspect`：声明一个类为切面。
    *   `@Transactional`：声明式事务管理，标注在类或方法上。

5.  **Web MVC**
    *   `@RequestMapping`：将HTTP请求映射到处理器方法。
    *   `@GetMapping`, `@PostMapping` 等：`@RequestMapping` 的快捷方式。
    *   `@RequestParam`：获取请求参数。
    *   `@RequestBody`：将请求体绑定到方法参数。
    *   `@ResponseBody`：将方法返回值直接写入HTTP响应体。

---

### **6. 注解底层实现原理**

注解的底层实现本质上是**基于反射的**。

1.  **定义阶段**：注解本身只是一个标记，用 `@interface` 关键字定义。编译后，它会成为一个继承自 `java.lang.annotation.Annotation` 的接口。
2.  **保留策略**：注解需要通过 `@Retention` 指定其保留策略：
    *   `RetentionPolicy.SOURCE`：仅存在于源码中，编译后丢弃。
    *   `RetentionPolicy.CLASS`：保存在class文件中，但JVM运行时不可见。这是默认值。
    *   **`RetentionPolicy.RUNTIME`**：保存在class文件中，且**在运行时可通过反射读取**。Spring使用的注解基本都是RUNTIME级别的。
3.  **运行时处理**：
    *   Spring容器启动时，会扫描classpath下指定的包。
    *   利用Java的反射机制（如 `Class.getDeclaredAnnotations()`，`Method.getAnnotation(...)` 等）读取类的字节码，检查类、方法、字段上是否存在特定注解（如 `@Component`, `@Autowired`）。
    *   根据注解携带的信息（注解的属性值），Spring容器执行相应的逻辑。例如：
        *   发现 `@Component`，就实例化该类并将其注册到IoC容器中。
        *   发现 `@Autowired`，就从容器中查找匹配的Bean，并通过反射（`Field.set(...)` 或 `Method.invoke(...)`）完成注入。

**简单来说：注解本身不做任何事，它只是元数据。是“注解处理器”（在这里是Spring框架）通过反射读取这些元数据，并据此执行了相应的业务逻辑。**

---

### **7. 类注入时，是by name还是by type?**

这取决于你使用的注解：

*   **`@Autowired`（Spring注解）：默认是 **byType**（按类型匹配）**。
    *   如果Spring上下文中存在且仅存在一个该类型的Bean，注入成功。
    *   如果存在多个相同类型的Bean，Spring会抛异常。此时需要配合 `@Qualifier("beanName")` 注解来指定Bean的名称，变为 **byName**。

*   **`@Resource`（JSR-250标准注解）：默认是 **byName**（按名称匹配）**。
    *   它会先根据属性名或 `@Resource` 的 `name` 属性查找Bean。
    *   如果找不到匹配名称的Bean，则会回退到 **byType** 进行匹配。

**总结：`@Autowired` 默认 byType，需配合 `@Qualifier` 实现 byName；`@Resource` 默认 byName，找不到再 byType。**

---

### **8. Agent的工具是动态加载还是静态加载？**

这是一个关于大模型Agent架构的问题。**更主流的现代实现方式是动态加载。**

*   **静态加载**：
    *   在Agent系统启动时，就将所有可用的工具（Tools）一次性加载到内存中。
    *   **优点**：简单、直接，调用速度快。
    *   **缺点**：缺乏灵活性。工具集是固定的，无法在运行时增加新的工具。对于需要大量工具或工具经常更新的场景，会占用大量内存且难以维护。

*   **动态加载**：
    *   Agent在启动时只加载核心运行时。当需要执行某个特定任务时，才根据任务描述或用户指令，去**动态地发现、加载并实例化**所需的工具。
    *   **优点**：
        1.  **灵活性高**：可以“热插拔”工具，无需重启Agent服务。
        2.  **可扩展性强**：易于集成第三方工具或新开发的功能。
        3.  **资源高效**：只加载当前任务需要的工具，节省内存。
    *   **缺点**：实现更复杂，需要一套工具发现、注册和加载的机制（例如通过配置文件、数据库、服务发现等），并且调用时可能会有微小的延迟。

**结论**：在大模型Agent领域，为了应对复杂多变的任务和环境，**动态加载是更被推崇的设计**。例如，LangChain、AutoGPT等框架都支持工具的动态注册和调用，这使得Agent的能力可以无限扩展。

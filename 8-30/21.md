# 2025年4月21日美团一面（非核心部门）面试题正文
1. 请讲一下反射  
反射是 Java 的核心机制，指运行程序在运行时动态分析、操作类、方法、字段等元信息。  
- **获取 Class 类的三种常见方法**：  
  1. 直接通过`类名.class`获取；  
  2. 通过 Object 超类的`getClass()`方法获取；  
  3. 通过`Class.forName(全类名)`方法获取。  
- **核心操作类**：  
  - `Constructor`类：动态创建对象（类似破坏 Spring 中的单例模式）；  
  - `Method`类：动态调用类中的方法；  
  - `Field`类：动态修改字段（成员变量）的数值、设置方法属性。  
- **用途**：Spring 用反射实现依赖注入和动态代理；单元测试用反射访问字段和方法。  
- **缺点**：反射性能较慢（通常慢几十倍）；易出现回调地狱。

2. 介绍一下 AOP，讲一下 AOP 使用的流程？  
AOP（面向切面编程）是一套规范，通过预编译和运行期间动态代理的方式实现程序统一维护，核心是将分散在各业务逻辑中的相同代码，通过横向切割抽取到公共模块中。  

- **AOP 核心术语**：  
  - 连接点：程序中可进行 AOP 处理的部分（如字段处理、方法调用、类初始化、异常）；  
  - 切入点：连接点的集合，明确 AOP 操作的位置（Spring 中通过 AspectJ 实现）；  
  - 通知：切入点的具体操作，包括前置通知、后置通知、环绕通知等；  
  - 切面：连接点、切入点、通知的组合；  
  - 目标对象：被代理的对象；  
  - 织入：将切入点作用到目标对象的操作。  

- **AOP 配置与使用流程**：  
  1. **XML 配置方式**：声明切面类，在切面类中定义通知方法，通过 XML 引用配置；  
  2. **AspectJ 注解方式**（简化 XML 配置）：  
     - 切面类添加`@Component`（声明为 Spring 管理的 Bean）和`@Aspect`（定义为切面类）；  
     - 通过`@Pointcut`注解定义切入点表达式（指定要切入的类/方法）；  
     - 通过`@Before`、`@Around`、`@After`等注解定义通知；  
     - 通知方法中可传入`JoinPoint`对象，用于获取目标方法、目标对象、方法参数及运行时上下文信息。  

- **示例代码**：  
```java
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;
import java.util.Arrays;

@Component
@Aspect
public class LogAspect {
    // 定义切入点：匹配 CalculatorImpl 类的所有 public int 方法
    @Pointcut("execution(public int com.dc.esb.CalculatorImpl.*(..))")
    public void pointCut() {}

    // 前置通知
    @Before("pointCut()")
    public void beforeMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        System.out.println("Logger-->前置通知，方法名：" + methodName + "，参数：" + args);
    }

    // 后置通知
    @After("execution(public int com.dc.esb.CalculatorImpl.*(..))")
    public void afterMethod(JoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("Logger-->后置通知，方法名：" + methodName);
    }

    // 返回通知（获取方法返回值）
    @AfterReturning(value = "execution(public int com.dc.esb.CalculatorImpl.*(..))", returning = "result")
    public void afterReturningMethod(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("Logger-->返回通知，方法名：" + methodName + "，结果：" + result);
    }

    // 异常通知（捕获方法异常）
    @AfterThrowing(value = "execution(public int com.dc.esb.CalculatorImpl.*(..))", throwing = "ex")
    public void afterThrowingMethod(JoinPoint joinPoint, Throwable ex) {
        String methodName = joinPoint.getSignature().getName();
        System.out.println("Logger-->异常通知，方法名：" + methodName + "，异常：" + ex);
    }

    // 环绕通知（包裹目标方法执行）
    @Around("execution(public int com.dc.esb.CalculatorImpl.*(..))")
    public Object aroundMethod(ProceedingJoinPoint joinPoint) {
        String methodName = joinPoint.getSignature().getName();
        String args = Arrays.toString(joinPoint.getArgs());
        Object result = null;
        try {
            System.out.println("环绕通知-->目标对象方法执行之前");
            // 执行目标方法
            result = joinPoint.proceed();
            System.out.println("环绕通知-->目标对象方法返回值之后");
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            System.out.println("环绕通知-->目标对象方法出现异常时");
        } finally {
            System.out.println("环绕通知-->目标对象方法执行完毕");
        }
        return result;
    }
}
```

3. AOP 底层原理是如何实现的？（Spring 角度？JDK 动态代理？CGLIB 动态代理？）  
Spring AOP 的核心实现依赖`BeanPostProcessor`接口（Spring 容器的扩展点），其作用是在 Bean 生命周期中，于“Bean 配置属性 + 实现 Aware 接口”后、Bean 初始化前后插入自定义逻辑。Spring AOP 通过实现该接口，在 Bean 初始化后创建代理对象。  

- **Spring AOP 动态代理实现三步流程**：  
  1. **注册自动代理创建器**：启用 AOP 时（如通过`@EnableAspectJAutoProxy`注解），Spring 自动注册`AnnotationAwareAspectJAutoProxyCreator`；  
  2. **扫描切面与增强逻辑**：Spring 扫描所有 Bean，识别带`@Aspect`注解的切面类，并解析`@Before`、`@After`等增强注解；  
  3. **Bean 初始化后创建代理**：调用`BeanPostProcessor`的后置方法，对需代理的 Bean 创建代理对象（JDK 或 CGLIB 动态代理）。  

- **核心示例代码（自动代理创建器逻辑）**：  
```java
public class AnnotationAwareAspectJAutoProxyCreator extends AbstractAutoProxyCreator {
    @Override
    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
        // 1. 检查当前 Bean 是否为切面类（基础设施类），若是则直接返回
        if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
            return bean;
        }

        // 2. 获取匹配当前 Bean 的增强器（Advice）
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);

        // 3. 若有增强器，创建代理对象（JDK 或 CGLIB）
        if (specificInterceptors != DO_NOT_PROXY) {
            this.advisedBeans.put(cacheKey, Boolean.TRUE);
            Object proxy = createProxy(
                bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)
            );
            this.proxyTypes.put(cacheKey, proxy.getClass());
            return proxy;
        }

        this.advisedBeans.put(cacheKey, Boolean.FALSE);
        return bean;
    }
}
```

4. 两个动态代理（JDK 动态代理、CGLIB 动态代理）的区别？性能和扩展性哪个好？为什么？  
| 维度                | JDK 动态代理                          | CGLIB 动态代理                          |
|---------------------|---------------------------------------|-----------------------------------------|
| 底层原理            | 基于接口，生成被代理接口的匿名实现类  | 基于字节码，通过继承被代理类生成子类    |
| 依赖条件            | 被代理类必须实现接口                  | 被代理类不能被`final`修饰（无法继承）    |
| 创建代理对象性能    | 较快                                  | 较慢（需生成字节码、子类）              |
| 运行时调用性能      | JDK 1.8 后较快                        | JDK 1.6/1.7 时较快，1.8 后慢于 JDK 代理 |
| 扩展性              | 仅支持接口方法代理                    | 支持类中所有非`final`方法代理           |

- **性能与场景选择**：  
  1. **创建代理对象频率低的场景**（如单例 Bean、实例池）：CGLIB 代理运行时性能更优（JDK 1.6/1.7），适合此类场景；  
  2. **创建代理对象频率高的场景**：JDK 代理创建速度快，适合频繁创建代理的场景；  
  3. **JDK 版本影响**：JDK 1.8 对动态代理做了优化，运行时性能超过 CGLIB，此时优先选 JDK 代理（若被代理类实现接口）。  

- **Spring 默认策略**：  
  - Spring 3+：自动判断——被代理类实现接口则用 JDK 代理，否则用 CGLIB 代理；  
  - Spring Boot 2+：默认用 CGLIB 代理（可配置切换为 JDK 代理）。

5. 如何实现 Bean 的生命周期？详细讲讲  
Bean 的生命周期整体分为“实例化 → 属性赋值 → 初始化 → 销毁”四步，具体可拆解为 10 个详细步骤（基于`AbstractAutowireCapableBeanFactory`类逻辑）：  

1. **实例化 Bean 对象**：调用 Bean 的构造方法，创建 Bean 实例；  
2. **设置 Bean 属性**：调用 Bean 的`set`方法，为属性赋值（注入配置的属性值）；  
3. **注入 Aware 接口依赖**：若 Bean 实现`BeanNameAware`、`BeanFactoryAware`、`ApplicationContextAware`等接口，Spring 注入对应的 Bean ID、BeanFactory 或 ApplicationContext；  
4. **调用 BeanPostProcessor 前置方法**：若存在实现`BeanPostProcessor`的类，调用其`postProcessBeforeInitialization()`方法（自定义初始化前逻辑）；  
5. **调用 InitializingBean 接口方法**：若 Bean 实现`InitializingBean`，调用其`afterPropertiesSet()`方法（属性赋值后的初始化逻辑）；  
6. **调用自定义 init 方法**：执行 Bean 配置中指定的`init-method`方法（自定义初始化逻辑）；  
7. **调用 BeanPostProcessor 后置方法**：调用`BeanPostProcessor`的`postProcessAfterInitialization()`方法（自定义初始化后逻辑，如 AOP 代理创建）；  
8. **Bean 就绪并使用**：Bean 进入可用状态，供应用程序调用；  
9. **调用 DisposableBean 接口方法**：容器关闭时，若 Bean 实现`DisposableBean`，调用其`destroy()`方法（自定义销毁逻辑）；  
10. **调用自定义 destroy 方法**：执行 Bean 配置中指定的`destroy-method`方法（自定义销毁逻辑）。

6. 循环依赖如何解决？  
Spring 通过“三级缓存”机制解决单例 Bean 的循环依赖问题，同时可结合`@Lazy`注解（延迟加载）辅助解决。  

- **三级缓存定义**：  
  - 一级缓存（singletonObjects）：存储初始化完成、属性赋值完毕的单例 Bean；  
  - 二级缓存（earlySingletonObjects）：存储实例化完成、但未完成属性赋值和初始化的“早期暴露 Bean”；  
  - 三级缓存（singletonFactories）：存储单例 Bean 的工厂对象（`ObjectFactory`），用于生成早期暴露 Bean（支持 AOP 代理）。  

- **解决逻辑**：  
  当 Bean A 依赖 Bean B、Bean B 依赖 Bean A 时，Spring 先实例化 A，将 A 的工厂对象放入三级缓存；接着实例化 B，B 依赖 A 时，从三级缓存获取 A 的早期暴露 Bean（若需 AOP 则生成代理），放入二级缓存；B 初始化完成后放入一级缓存，A 再从一级缓存获取 B 完成属性赋值，最终 A 初始化完成放入一级缓存，循环依赖解决。

7. 为什么用三级缓存，不可以用二级缓存吗？  
二级缓存可解决简单循环依赖，但无法处理“循环依赖 + AOP 代理”的场景，三级缓存的核心作用是**延迟生成代理对象**，符合 Spring“代理对象按需创建”的设计原则。  

- **二级缓存的缺陷**：  
  1. **破坏代理延迟创建原则**：若用二级缓存直接存储早期暴露 Bean，需在实例化后立即创建代理（即使无循环依赖），违背 Spring“仅在需要时创建代理”的逻辑；  
  2. **单例性问题**：循环依赖场景下，二级缓存可能导致多次创建代理对象，破坏单例 Bean 的唯一性；  
  3. **代码耦合**：将“早期暴露”与“代理创建”强制绑定，降低代码可维护性。  

- **三级缓存的优势**：  
  通过`ObjectFactory`工厂对象，仅在循环依赖发生时才生成早期暴露 Bean（及代理），无循环依赖时不提前创建代理，既解决循环依赖，又符合 Spring 设计原则。

8. AOP 什么时候用 JDK 动态代理，什么时候用 CGLIB 动态代理？  
- **JDK 动态代理适用场景**：  
  1. 被代理的目标对象实现了至少一个接口；  
  2. 被代理类或方法被`final`修饰（CGLIB 无法继承`final`类/方法）；  
  3. 需频繁创建代理对象（JDK 代理创建速度更快）。  

- **CGLIB 动态代理适用场景**：  
  1. 被代理的目标对象未实现任何接口；  
  2. 代理对象创建频率低、运行时调用频繁（JDK 1.6/1.7 时 CGLIB 运行性能更优）；  
  3. Spring Boot 2+ 环境（默认使用 CGLIB 代理，可配置切换）。  

- **Spring 自动选择逻辑**：  
  Spring 3+ 优先判断目标对象是否实现接口——实现则用 JDK 代理，否则用 CGLIB 代理；若需强制使用 CGLIB 代理，可配置`proxy-target-class="true"`（XML）或`@EnableAspectJAutoProxy(proxyTargetClass = true)`（注解）。

9. 讲讲索引的原理  
索引是数据库中用于加速查询的数据结构，核心作用是“将数据目录化”，类似书籍目录（通过目录快速定位页码，而非逐页查找）。  

- **常见索引数据结构及特点**：  
  1. **Hash 索引**：基于哈希表实现，通过哈希函数将索引键映射到哈希桶，查询速度快（O(1)），但不支持范围查询、排序；  
  2. **二叉搜索树（BST）**：左子树值小于根、右子树值大于根，查询时间复杂度 O(logn)，但易出现“斜树”（退化为链表，O(n)）；  
  3. **B 树**：多路平衡搜索树，每个节点存储多个键和指针，减少 IO 次数（数据库数据存储在磁盘，IO 成本高），但叶子节点不连续，排序效率低；  
  4. **B+ 树（主流数据库索引结构）**：B 树的优化版，所有数据存储在叶子节点，叶子节点通过指针连续关联；支持范围查询、排序，且 IO 次数更少（非叶子节点仅存索引键，单节点存储更多键）。  

- **索引工作流程**：  
  查询时，数据库先通过索引键在 B+ 树中从根节点向下遍历，定位到叶子节点的目标数据地址，再通过地址读取磁盘中的数据，避免全表扫描。

10. 索引失效的场景  
索引失效指查询未使用预期的索引，转而进行全表扫描，常见场景如下：  
- **对索引字段进行运算/函数操作**：如`where age + 1 = 25`、`where SUBSTR(name, 1, 1) = '张'`；  
- **索引字段模糊查询（左模糊/全模糊）**：如`where name like '%三'`（左模糊）、`where name like '%三%'`（全模糊），仅右模糊（`like '张%'`）支持索引；  
- **索引字段类型转换**：如索引字段为`varchar`类型，查询时用`where id = 123`（未加引号，隐式转换为`int`）；  
- **OR 条件中存在非索引字段**：如`where age = 25 or sex = '男'`，若`sex`无索引，则`age`的索引失效；  
- **联合索引不满足“最左前缀匹配原则”**：联合索引（a, b, c）仅支持`a`、`a,b`、`a,b,c`的查询顺序，若跳过左前缀（如`b`、`b,c`），则索引失效；  
- **查询结果占全表数据比例过高**：当查询结果超过全表 30%~50% 时，数据库认为全表扫描比索引查询更高效，索引失效。

# 2025年4月21日美团一面（非核心部门）面试题正文（续）
11. 什么时候需要建立索引？为什么要建立索引？  
- **需要建立索引的场景**：  
  1. **高频查询字段**：如订单表的`user_id`（用户查历史订单）、商户表的`merchant_id`（商户查自身订单），索引可减少查询时的磁盘 IO 次数，加速结果返回；  
  2. **用于排序/分组的字段**：如`order_time`（按订单时间排序）、`category_id`（按商品分类分组），索引的有序性可避免数据库对结果集二次排序（“Using filesort”），提升性能；  
  3. **联合查询的关联字段**：如订单表的`rider_id`（关联骑手表）、`merchant_id`（关联商户表），索引可加速多表 JOIN 操作；  
  4. **唯一约束字段**：如用户表的`phone_number`（唯一登录手机号），通过唯一索引可快速校验唯一性，同时加速查询；  
  5. **范围查询字段**：如`create_time`（查询“近7天订单”），B+树索引的有序结构对范围查询支持友好，效率远高于全表扫描。  

- **建立索引的核心原因**：  
  数据库数据存储在磁盘中，全表扫描需逐行读取磁盘数据，IO 成本极高；索引通过“预排序+目录化”的结构，将查询从“逐行扫描”转化为“索引树定位”，大幅减少磁盘 IO 次数，降低查询耗时，提升系统响应速度。  

- **注意事项**：  
  - 索引字段应避免为`NULL`（NULL 会影响索引排序和查询效率，建议设默认值）；  
  - 避免过度建索引（索引会占用磁盘空间，且增删改操作需同步维护索引，增加开销）。

12. 有一个骑手表、订单表、商户表，你该怎么设计索引？  
需结合业务高频查询场景设计，核心优化“订单表”（外卖场景中订单查询频率最高），同时兼顾骑手表、商户表的核心查询需求：  

### （1）订单表（核心优化对象）  
| 索引类型       | 索引字段                          | 设计原因                                                                 |
|----------------|-----------------------------------|--------------------------------------------------------------------------|
| 主键索引       | `order_id`（自增）                | 自增主键可避免 B+树索引分裂，提升插入性能；作为订单唯一标识，加速单订单查询 |
| 普通索引       | `user_id`                         | 支持“用户查询历史订单”的高频场景                                         |
| 普通索引       | `rider_id`                        | 支持“骑手查询自己配送的订单”场景                                         |
| 联合索引       | `merchant_id + status + create_time` | 覆盖“商户按订单状态（如待接单、已完成）筛选，并按创建时间排序”的高频需求   |
| 联合索引       | `status + create_time`            | 支持“按订单状态筛选+时间范围查询”（如“近1小时待接单订单”）                 |
| 覆盖索引       | `status + payment_time` INCLUDE (`total_amount`) | 覆盖“统计不同状态订单的支付金额总和”等报表查询，避免回表读取数据           |

### （2）骑手表  
| 索引类型       | 索引字段                          | 设计原因                                                                 |
|----------------|-----------------------------------|--------------------------------------------------------------------------|
| 主键索引       | `rider_id`（自增）                | 骑手唯一标识，加速单骑手信息查询                                         |
| 唯一索引       | `phone_number`                    | 骑手登录校验（唯一），同时加速“按手机号查骑手”场景                         |
| 联合索引       | `current_area_code + load_status` | 支持“调度系统按区域（`current_area_code`）筛选骑手，并按负载状态（`load_status`，如空闲/忙碌）分配订单” |
| 地理位置索引   | `location`（GEOHASH/GIST）        | 支持“附近骑手推荐”场景（如用户下单后，查找3公里内的空闲骑手）             |
| 普通索引（可选）| `is_online + last_active_time`    | 筛选“在线骑手”，但需注意：若在线骑手占比超过50%，索引可能失效，建议结合业务判断 |

### （3）商户表  
| 索引类型       | 索引字段                          | 设计原因                                                                 |
|----------------|-----------------------------------|--------------------------------------------------------------------------|
| 主键索引       | `merchant_id`（自增）             | 商户唯一标识，加速单商户信息查询                                         |
| 地理位置索引   | `location`（GEOHASH/GIST）        | 支持“用户查找附近商户”的核心场景                                         |
| 联合索引       | `category_id + average_rating`    | 支持“按商户分类（如快餐、奶茶）筛选，并按评分排序”的推荐场景             |
| 联合索引       | `city_id + is_open`               | 支持“按城市筛选营业中商户”的运营需求                                     |
| 前缀索引       | `merchant_name(20)`               | 商户名称查询多为模糊匹配（如“搜索‘麦当劳’”），前缀索引可减少索引存储空间，同时支持左模糊查询（`like '麦当%'`） |

13. 缓存穿透  
- **定义**：指请求查询的数据“既不在缓存（如 Redis）中，也不在数据库（如 MySQL）中”，导致所有请求直接穿透缓存，冲击数据库，可能引发数据库宕机。  
- **常见原因**：  
  1. 业务逻辑漏洞（如查询不存在的用户 ID、订单 ID）；  
  2. 恶意攻击（如黑客构造大量不存在的键，发起高并发请求）；  
  3. 数据误删（数据库中数据被删除，但缓存未同步清理）。  

- **解决方案**：  
  1. **请求参数校验**：在接口层过滤非法参数（如用户 ID 为负数、订单号格式错误），直接拦截无效请求；  
  2. **缓存空值**：若数据库查询结果为空，仍将“空值”存入缓存（设置较短过期时间，如5分钟），避免后续相同请求重复穿透到数据库；  
  3. **布隆过滤器**：在缓存前加布隆过滤器，将数据库中所有有效键（如用户 ID、订单 ID）提前存入过滤器；请求先经过过滤器校验，若键不存在则直接拦截，仅有效键才允许查询缓存和数据库（布隆过滤器可快速判断“键是否不存在”，但存在极小误判率）；  
  4. **限流降级**：高并发场景下，通过限流组件（如 Sentinel）限制请求QPS，若缓存/数据库异常，触发降级策略（返回默认值），保护数据库。

14. 缓存雪崩与缓存击穿  
### （1）缓存雪崩  
- **定义**：指大量缓存数据在同一时间过期，或缓存服务（如 Redis）宕机，导致所有请求瞬间穿透到数据库，数据库因无法承受高并发而宕机，进而引发整个系统崩溃。  
- **核心原因**：  
  1. 缓存数据设置相同过期时间（如批量导入的订单缓存均设置24小时过期）；  
  2. 缓存集群故障（如 Redis 主从同步中断、集群节点全部下线）。  

- **解决方案**：  
  1. **过期时间随机化**：为缓存数据设置基础过期时间（如24小时）+ 随机偏移量（如0~1小时），避免大量数据同时过期；  
  2. **缓存集群高可用**：部署 Redis 主从+哨兵集群，或 Redis Cluster，确保单个节点故障时，从节点可快速切换为主节点，避免缓存服务宕机；  
  3. **互斥锁**：当缓存过期时，仅允许一个线程查询数据库并重建缓存，其他线程等待（如用 Redis 的`setNx`实现分布式锁），避免大量线程同时冲击数据库；  
  4. **缓存预热**：业务上线前，通过脚本提前将高频访问数据加载到缓存中，避免上线后大量请求直接查询数据库；  
  5. **异步更新缓存**：缓存过期后，不立即重建缓存，而是通过消息队列（如 Kafka）发送更新通知，由后台线程异步查询数据库并更新缓存，前端请求先返回旧数据（或默认值），保证接口响应速度；  
  6. **限流降级**：缓存宕机时，通过限流组件限制数据库请求QPS，同时触发降级（返回缓存降级数据），避免数据库崩溃。  

### （2）缓存击穿  
- **定义**：指某一个“热点缓存”（如热门商品详情、高频访问的活动页面）过期，此时大量并发请求同时查询该热点数据，导致请求穿透到数据库，数据库瞬间承受高压力（可视为“缓存雪崩的子集”，仅针对单个热点键）。  
- **核心原因**：热点缓存过期，且并发请求量极大。  

- **解决方案**：  
  1. **热点缓存永不过期**：不设置过期时间，通过业务逻辑手动更新缓存（如商品价格变更时，同步更新缓存）；  
  2. **互斥锁**：与缓存雪崩解决方案一致，缓存过期时仅允许一个线程重建缓存，其他线程等待；  
  3. **定时刷新缓存**：对热点缓存设置定时任务（如每30分钟），在缓存过期前主动查询数据库并更新缓存，避免缓存过期；  
  4. **二级缓存**：增加本地缓存（如本地 HashMap），热点数据先查本地缓存，再查分布式缓存；本地缓存设置较短过期时间，分布式缓存设置较长过期时间，减少分布式缓存过期带来的冲击。

15. 缓存击穿（补充）  
- **补充说明**：缓存击穿本质是“单个热点缓存过期引发的局部高并发问题”，除上述解决方案外，还可结合业务场景优化：  
  - 若热点数据更新频率低（如活动规则），可直接将数据固化到本地代码（如配置文件），完全避免缓存依赖；  
  - 若热点数据更新频率高（如商品库存），可采用“读写分离+缓存更新”策略：写操作更新数据库后，立即更新缓存；读操作优先查缓存，缓存未命中时查询数据库并更新缓存。  

- **与缓存雪崩的区别**：缓存雪崩是“大量缓存同时过期/缓存服务宕机”，影响范围是整个系统；缓存击穿是“单个热点缓存过期”，影响范围仅针对该热点键的查询。

16. 讲讲数据库和缓存的数据一致性  
- **定义**：指缓存中的数据与数据库中的数据保持一致，避免出现“缓存存旧数据、数据库存新数据”的脏数据问题（尤其在高并发读写场景下）。  

- **核心矛盾**：读写并发时，若“读操作”在“写操作更新数据库但未更新缓存”的间隙查询，可能读取到旧数据；或“写操作”异常导致缓存未更新，引发数据不一致。  

- **主流解决方案**：  
  需根据业务对“一致性”的要求选择方案（强一致性需牺牲性能，最终一致性可兼顾性能），常见两种核心更新策略：  

### 策略1：先删除缓存，再更新数据库（可能引发脏数据，需优化）  
- **流程**：写线程 → 删除缓存 → 更新数据库 → 缓存后续由读线程重建。  
- **问题**：若写线程删除缓存后、更新数据库前，读线程查询缓存（未命中）→ 查数据库（读旧数据）→ 将旧数据写入缓存，导致“缓存存旧数据、数据库存新数据”，后续读请求均读取脏数据。  
- **优化方案：延迟双删**：  
  1. 写线程先删除缓存；  
  2. 写线程更新数据库；  
  3. 延迟500ms~1s后，写线程再次删除缓存。  
  - 原理：延迟删除可覆盖“读线程在写线程更新数据库前写入旧缓存”的时间窗口，第二次删除可清除读线程写入的旧缓存，后续读请求会查询数据库获取新数据并重建缓存。  

### 策略2：先更新数据库，再删除缓存（推荐，一致性更优）  
- **流程**：写线程 → 更新数据库 → 删除缓存 → 缓存后续由读线程重建。  
- **优势**：相比“先删缓存”，可大幅降低脏数据概率——读线程仅可能在“数据库已更新但缓存未删除”的间隙读取旧缓存，该时间窗口极短（删除缓存操作耗时远短于更新数据库），脏数据风险低。  
- **问题**：若写线程更新数据库后，删除缓存失败（如网络异常），会导致“数据库存新数据、缓存存旧数据”。  
- **优化方案**：  
  1. **删除重试**：通过定时任务重试删除缓存（如记录删除失败的键到日志表，定时扫描并重试）；  
  2. **异步通知**：用消息队列（如 Kafka）或变更数据捕获（CDC）工具（如 Canal）监听数据库更新事件，数据库更新后自动发送消息，由消费端异步删除缓存（即使删除失败，消息队列可重试）；  
  3. **缓存过期时间兜底**：为缓存设置合理过期时间，即使出现数据不一致，过期后缓存会自动失效，后续读请求可重建正确缓存（保证最终一致性）。  

- **注意事项**：  
  - 避免“更新数据库后更新缓存”：若多个写线程并发更新，可能出现“线程1更新数据库→线程2更新数据库→线程1更新缓存→线程2更新缓存”，导致缓存数据与数据库一致；但若线程2更新数据库后，线程1延迟更新缓存，会导致缓存存旧数据（“更新缓存”存在并发安全问题，优先用“删除缓存”）。

17. HashMap 和 ConcurrentHashMap 的底层实现  
### （1）HashMap（JDK 1.8）  
- **底层结构**：数组（哈希桶）+ 链表 + 红黑树（当链表长度超过8，且数组长度≥64时，链表转为红黑树；当红黑树节点数少于6时，退化为链表）。  
- **核心属性**：  
  - 初始容量：默认16（必须为2的幂，便于通过“位运算”计算哈希桶索引）；  
  - 负载因子：默认0.75（当元素个数达到“容量×负载因子”时，数组扩容为原来的2倍）；  
  - 阈值（threshold）：容量×负载因子，触发扩容的临界值。  

- **核心流程**：  
  1. **哈希计算**：通过`key.hashCode()`计算哈希值，再通过“哈希值 ^ (哈希值 >>> 16)”减少哈希冲突，最后用“哈希值 & (数组长度-1)”计算哈希桶索引；  
  2. **存储数据**：  
     - 若哈希桶为空，直接创建节点存入；  
     - 若哈希桶不为空，判断节点key与传入key是否相等（`equals()`），相等则覆盖value；  
     - 若不相等，若为红黑树则插入树节点，若为链表则尾插节点，插入后判断链表长度是否需转红黑树；  
  3. **扩容机制**：元素个数达到阈值时，数组扩容为2倍，重新计算所有节点的哈希桶索引并迁移（JDK 1.8优化为“高低位拆分”，减少迁移开销）。  

- **线程安全问题**：多线程并发操作时，可能出现链表环（扩容时）、数据覆盖等问题，故 HashMap 不支持并发场景。

### （2）ConcurrentHashMap（JDK 1.8）  
- **设计目标**：解决 HashMap 的线程安全问题，同时保证高并发性能（相比 Hashtable 的“全表锁”，粒度更细）。  
- **底层结构**：与 HashMap 一致（数组+链表+红黑树），但通过“CAS + 局部锁（synchronized）”保证线程安全。  

- **核心优化（JDK 1.8 对比 JDK 1.7）**：  
  - JDK 1.7：采用“分段锁（Segment）”，将数组分为多个 Segment，每个 Segment 对应一把锁，锁粒度为 Segment；  
  - JDK 1.8：移除 Segment，直接对“哈希桶节点”加锁（synchronized 修饰链表头节点/红黑树根节点），锁粒度细化到单个哈希桶，并发性能大幅提升。  

- **核心操作的线程安全实现**：  
  1. **put 操作**：  
     - 计算哈希桶索引，若数组为空则初始化（CAS 保证原子性）；  
     - 若目标哈希桶为空，用 CAS 尝试插入节点，失败则自旋重试；  
     - 若目标哈希桶不为空，对桶头节点加 synchronized 锁，执行插入/覆盖操作（避免并发修改）；  
  2. **get 操作**：无锁设计，通过“volatile 修饰节点的 value”保证可见性（无需加锁，提升读性能）；  
  3. **扩容操作**：支持并发扩容，通过“转移指针”标记已迁移的哈希桶，多个线程可同时参与扩容（每个线程负责一部分哈希桶的迁移）。  

- **关键特性**：  
  - 支持高并发读写，读操作无锁，写操作仅锁单个哈希桶；  
  - 不支持`null`键和`null`值（避免`null`引发的并发判断歧义）；  
  - 提供原子操作方法（如`putIfAbsent()`、`remove()`），满足并发场景下的原子性需求。

# 什么是缓存雪崩、击穿、穿透？
用户的数据一般存储于数据库，数据库数据落在磁盘上，磁盘读写速度是计算机中最慢的硬件之一。当用户请求都访问数据库时，请求数量一旦增多，数据库很容易崩溃。因此，为避免用户直接访问数据库，会使用 Redis 作为缓存层。Redis 是内存数据库，将数据库数据缓存在 Redis 中，相当于数据缓存在内存，内存读写速度比硬盘快几个数量级，能大幅提高系统性能。

引入缓存层后，会出现缓存异常的三个问题，分别是**缓存雪崩、缓存击穿、缓存穿透**。这三个问题是面试中常考察的内容，不仅要清楚其发生原因，还需掌握解决方法。


## 一、缓存雪崩
通常为保证缓存数据与数据库数据一致性，会给 Redis 中的数据设置过期时间。当缓存数据过期后，若用户访问的数据不在缓存中，业务系统需重新生成缓存——访问数据库并将数据更新到 Redis，后续请求便可直接命中缓存。

当**大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机**时，若此时有大量用户请求，这些请求都无法在 Redis 中处理，会全部直接访问数据库，导致数据库压力骤增，严重时会造成数据库宕机，进而引发一系列连锁反应，导致整个系统崩溃，这就是**缓存雪崩**。

缓存雪崩的发生有两个原因，不同诱因对应不同的应对策略：

### （一）大量数据同时过期
针对大量数据同时过期引发的缓存雪崩，常见应对方法如下：
1. **均匀设置过期时间**：给缓存数据设置过期时间时，避免将大量数据设置为同一过期时间。可在基础过期时间上增加一个随机数，确保数据不会在同一时间过期。
2. **互斥锁**：业务线程处理用户请求时，若发现访问的数据不在 Redis 中，就加互斥锁，保证同一时间内只有一个请求构建缓存（从数据库读取数据并更新到 Redis）。缓存构建完成后释放锁，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么返回空值或默认值。实现互斥锁时需设置**超时时间**，防止因请求意外阻塞导致锁无法释放，进而使系统无响应。
3. **后台更新缓存**：业务线程不再负责更新缓存，缓存不设置有效期（视为“永久有效”），由后台线程定时更新缓存。但需注意，系统内存紧张时部分缓存数据会被“淘汰”，从缓存被淘汰到下一次后台定时更新缓存的这段时间，业务线程读取缓存失败会返回空值，可通过以下两种方式解决：
   - 后台线程不仅定时更新缓存，还**频繁检测缓存是否有效**（检测间隔建议为毫秒级），若发现缓存因系统内存紧张被淘汰而失效，立即从数据库读取数据并更新到缓存。但该方式仍存在检测间隔，用户体验一般。
   - 业务线程发现缓存数据失效后，**通过消息队列发送消息通知后台线程更新缓存**。后台线程收到消息后，先判断缓存是否存在，存在则不执行更新，不存在则读取数据库数据并加载到缓存。该方式缓存更新更及时，用户体验更好。
   此外，业务上线时可通过后台更新缓存机制提前缓存数据（即**缓存预热**），避免等待用户访问才触发缓存构建。

### （二）Redis 故障宕机
针对 Redis 故障宕机引发的缓存雪崩，常见应对方法如下：
1. **服务熔断或请求限流机制**：
   - **服务熔断**：Redis 故障宕机时，暂停业务应用对缓存服务的访问，直接返回错误，避免请求继续访问数据库，从而降低数据库压力，保证数据库正常运行。待 Redis 恢复正常后，再允许业务应用访问缓存服务。但该机制会导致全部业务无法正常工作，对业务影响较大。
   - **请求限流**：只将少部分请求发送到数据库处理，超出限额的请求在入口直接拒绝服务。待 Redis 恢复正常且完成缓存预热后，解除限流机制。该方式能减少对业务的影响。
2. **构建 Redis 缓存高可靠集群**：服务熔断和请求限流是缓存雪崩发生后的应对方案，更优的做法是通过**主从节点架构构建 Redis 高可靠集群**。若主节点故障宕机，从节点可切换为新主节点，继续提供缓存服务，从根源上避免因 Redis 故障宕机引发的缓存雪崩。


## 二、缓存击穿
业务中常有部分数据被频繁访问（如秒杀活动中的商品数据），这类数据被称为热点数据。若缓存中的**某个热点数据过期**，此时大量请求访问该热点数据，无法从缓存中读取，会直接访问数据库，导致数据库被高并发请求冲垮，这就是**缓存击穿**。

缓存击穿可视为缓存雪崩的一个子集，应对方案可复用部分缓存雪崩的解决思路：
1. **互斥锁方案**：与“大量数据同时过期”场景下的互斥锁逻辑一致，保证同一时间只有一个业务线程更新缓存，未能获取锁的请求等待锁释放后重新读缓存，或返回空值/默认值。
2. **热点数据永不过期（后台异步更新）**：不给热点数据设置过期时间，由后台线程异步更新缓存；或在热点数据即将过期前，提前通知后台线程更新缓存并重新设置过期时间，确保热点数据始终能从缓存中读取。


## 三、缓存穿透
缓存雪崩和击穿发生时，数据库中仍存在应用要访问的数据，一旦缓存恢复对应数据，就能减轻数据库压力；而缓存穿透的核心问题是**数据既不在缓存中，也不在数据库中**。当用户请求访问这类数据时，先查询缓存发现缺失，再查询数据库仍未找到，无法构建缓存服务后续请求。若有大量此类请求，会导致数据库压力骤增，这就是**缓存穿透**。

缓存穿透的发生通常有两种情况：
- 业务误操作：缓存和数据库中的数据都被误删除，导致两者中均无目标数据。
- 黑客恶意攻击：故意大量访问读取不存在数据的业务接口。

应对缓存穿透的常见方案如下：
1. **非法请求限制**：在 API 入口处校验请求参数，判断参数是否合理（如是否含非法值、请求字段是否存在），若识别为恶意请求，直接返回错误，避免请求进一步访问缓存和数据库。
2. **缓存空值或默认值**：当业务发现缓存穿透现象时，针对查询不到的数据，在缓存中设置空值或默认值。后续相同请求可从缓存中读取到空值/默认值并返回，无需再查询数据库。
3. **使用布隆过滤器**：
   - 原理：布隆过滤器由“初始值为 0 的位图数组”和“N 个哈希函数”组成。写入数据库数据时，在布隆过滤器中做标记；用户请求到来且缓存失效后，先查询布隆过滤器快速判断数据是否存在，若不存在则无需查询数据库。
   - 标记流程：
     1. 使用 N 个哈希函数分别对数据做哈希计算，得到 N 个哈希值；
     2. 将 N 个哈希值对位图数组长度取模，得到每个哈希值在位图数组中的对应位置；
     3. 将位图数组对应位置的值设为 1。
   - 查询逻辑：查询数据时，通过相同的 N 个哈希函数计算并取模，检查位图数组对应位置的值是否全为 1。只要有一个位置为 0，就判定数据不在数据库中；若全为 1，仅表示数据“可能存在”（因哈希冲突可能导致误判）。
   - 优势：即使发生缓存穿透，大量请求也只会查询 Redis 和布隆过滤器，不会访问数据库，能有效保护数据库，且 Redis 原生支持布隆过滤器。


## 四、总结
缓存雪崩、击穿和穿透的核心差异在于数据的存在性及失效场景，应对方案也因原因不同而有所区别，具体对比如下（核心逻辑）：
| 缓存问题 | 核心原因 | 关键差异 | 典型应对方案 |
|----------|----------|----------|--------------|
| 缓存雪崩 | 大量数据同时过期 / Redis 宕机 | 多数据失效，请求批量冲击数据库 | 均匀设过期时间、互斥锁、后台更新缓存；Redis 集群、服务熔断/限流 |
| 缓存击穿 | 单个热点数据过期 | 单数据失效，请求集中冲击数据库 | 互斥锁、热点数据永不过期（后台异步更新） |
| 缓存穿透 | 数据既不在缓存也不在数据库 | 无有效数据，请求持续冲击数据库 | 非法请求限制、缓存空值、布隆过滤器 |

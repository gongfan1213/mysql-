## 字节一面 2.11

### 项目的难点

1. **跨域解决**  
2. **websocket，重连接，连接断开这个情况，连接断开的时候正好再发消息，怎么建立好连接后重新发送消息**  

### 八股

3. **闭包的实际应用场景举例**  
  数据隐藏，函数初始化，缓存，防抖节流效果  
4. **http和https的区别 tls加密**  
6. **栈和队列实践应用可以想到什么**  
7. **flex布局，你项目中使用情况**  

### 算法手写

8. **使用reduce改写实现自己的map方法**  
9. **实现自己的mypromise，实现一秒后触发resolve，reject函数**  

---

## 字节二面 2.14

### 项目

- 群聊怎么实现的，后端存储session，性能方面多个读与写操作，怎么优化  
- 私聊怎么实现的  
- 心跳机制，心跳机制的降级操作知道吗  
- 懒加载和虚拟列表怎么做的，  
- 然后你提到了lcp，你知道怎么计算的吗  

### 算法

1. **数组的append方法，排除空情况**  
2. **找到目录，给了一个树状的数组，给了一个目录，元素是一个个对象，每个对象由name, children组成**  
3. **合并区间**  
4. **扑克牌顺子问题，输入一个数为5的列表，判断是否是连续的**  

### 反问

- 问了下学习建议，框架的原理要去掌握  
- 他问我是否接受压力比较大，基本上 9:00 之后下班  

---

## 字节三面 2.14

### 八股

- 定位布局，绝对定位与相对定位的区别  
- 说一下 sticky，怎么实现滚动到底后，按钮栏回到最顶部  
  （正常文档流中表现为 relative，当滚动到某个特定位置，会固定到屏幕上某个位置，就像 fixed 定位一样）  
- vue 响应式原理，vue2 与 vue3 的区别  

### 算法

1. **多叉树数据结构自己定义，判断是否存在一条路径上的和 = sum**  
2. **版本号排序（sort方法）**  
3. **代码输出题，判断 this 指向**  

---

下面我将对每个题目进行详细解答。

---

## 一面题目详解

### 1. 跨域解决方案
跨域是浏览器同源策略导致的限制，常用解决方案：
- **CORS**：服务端设置 `Access-Control-Allow-Origin` 等响应头
- **JSONP**：利用 `<script>` 标签不受同源策略限制
- **代理服务器**：开发时用 webpack devServer proxy，生产用 nginx 反向代理
- **postMessage**：跨窗口通信
- **WebSocket**：不受同源策略限制

### 2. WebSocket 重连与消息重发
- **监听连接断开**：通过 `onclose` 事件
- **重连机制**：使用指数退避算法，比如 1s, 2s, 4s... 后重连
- **消息缓存**：在发送消息时若连接未就绪，将消息存入队列，连接恢复后重新发送
- **示例代码**：
```javascript
let messageQueue = [];
let ws = null;

function connect() {
  ws = new WebSocket('ws://...');
  ws.onopen = () => {
    messageQueue.forEach(msg => ws.send(msg));
    messageQueue = [];
  };
  ws.onclose = () => {
    setTimeout(connect, 1000);
  };
}

function sendMessage(msg) {
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(msg);
  } else {
    messageQueue.push(msg);
  }
}
```

### 3. 闭包的实际应用场景
- **数据隐藏/模块模式**：
```javascript
function createCounter() {
  let count = 0;
  return function() {
    return ++count;
  };
}
```
- **函数初始化**（柯里化）：
```javascript
function multiply(a) {
  return function(b) {
    return a * b;
  };
}
```
- **缓存（记忆化）**：
```javascript
function memoize(fn) {
  const cache = {};
  return function(...args) {
    const key = JSON.stringify(args);
    return cache[key] || (cache[key] = fn.apply(this, args));
  };
}
```
- **防抖节流**：
```javascript
function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  };
}
```

### 4. HTTP 和 HTTPS 的区别
- **HTTP**：明文传输，端口 80
- **HTTPS**：SSL/TLS 加密传输，端口 443
- **TLS 加密过程**：
  1. 客户端发送支持的加密协议版本
  2. 服务器返回证书和公钥
  3. 客户端验证证书，生成对称密钥并用公钥加密
  4. 服务器用私钥解密获取对称密钥
  5. 双方使用对称密钥加密通信

### 6. 栈和队列的实际应用
- **栈**：函数调用栈、括号匹配、撤销操作、DFS
- **队列**：任务队列、消息队列、BFS、缓存

### 7. Flex 布局使用情况
- **容器属性**：`display: flex`, `flex-direction`, `justify-content`, `align-items`, `flex-wrap`
- **项目属性**：`flex-grow`, `flex-shrink`, `flex-basis`, `order`
- **实际应用**：水平垂直居中、等分布局、圣杯布局、响应式导航

### 8. 使用 reduce 实现 map
```javascript
Array.prototype.myMap = function(callback) {
  return this.reduce((acc, current, index, array) => {
    acc.push(callback(current, index, array));
    return acc;
  }, []);
};
```

### 9. 实现 MyPromise
```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    
    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
      }
    };
    
    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
      }
    };
    
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  
  then(onFulfilled, onRejected) {
    if (this.state === 'fulfilled') {
      onFulfilled(this.value);
    } else if (this.state === 'rejected') {
      onRejected(this.reason);
    }
  }
}

// 测试：1秒后触发 resolve
new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve('成功');
    // 或 reject('失败');
  }, 1000);
}).then(
  value => console.log(value),
  reason => console.log(reason)
);
```

---

## 二面题目详解

### 项目相关问题

#### 群聊实现与性能优化
- **实现方式**：WebSocket 广播消息，后端存储 session 或使用 Redis 存储在线用户
- **性能优化**：
  - 读写分离：主库写，从库读
  - 消息队列：异步处理消息发送
  - 连接池：数据库连接复用
  - 缓存：常用数据放入 Redis

#### 私聊实现
- 建立一对一 WebSocket 连接或通过服务器转发私聊消息
- 消息格式包含发送者、接收者、内容、时间戳

#### 心跳机制与降级
- **心跳机制**：定时发送 ping/pong 包检测连接状态
- **降级操作**：心跳失败时尝试重连，多次失败后转为轮询
- **示例**：
```javascript
let heartbeatInterval = setInterval(() => {
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: 'ping' }));
  }
}, 30000);

ws.onclose = () => {
  clearInterval(heartbeatInterval);
  // 降级为轮询
  startPolling();
};
```

#### 懒加载与虚拟列表
- **懒加载**：监听元素进入视口后加载内容
- **虚拟列表**：只渲染可见区域的项目，减少 DOM 数量
- **实现原理**：计算可见区域，动态渲染对应数据

#### LCP（最大内容绘制）计算
- LCP 测量页面加载过程中最大可见内容元素的渲染时间
- 通过 PerformanceObserver API 监控：
```javascript
new PerformanceObserver((entryList) => {
  const entries = entryList.getEntries();
  const lastEntry = entries[entries.length - 1];
  console.log('LCP:', lastEntry.renderTime || lastEntry.loadTime);
}).observe({ type: 'largest-contentful-paint', buffered: true });
```

### 算法题

#### 1. 数组 append 方法（排除空值）
```javascript
function appendArray(arr, ...elements) {
  elements.forEach(el => {
    if (el != null) { // 排除 null 和 undefined
      arr.push(el);
    }
  });
  return arr;
}
```

#### 2. 树状目录查找
```javascript
function findPath(tree, targetName) {
  for (let node of tree) {
    if (node.name === targetName) {
      return [node.name];
    }
    if (node.children) {
      const path = findPath(node.children, targetName);
      if (path.length) {
        return [node.name, ...path];
      }
    }
  }
  return [];
}
```

#### 3. 合并区间
```javascript
function mergeIntervals(intervals) {
  if (intervals.length <= 1) return intervals;
  
  intervals.sort((a, b) => a[0] - b[0]);
  const result = [intervals[0]];
  
  for (let i = 1; i < intervals.length; i++) {
    const current = intervals[i];
    const last = result[result.length - 1];
    
    if (current[0] <= last[1]) {
      last[1] = Math.max(last[1], current[1]);
    } else {
      result.push(current);
    }
  }
  
  return result;
}
```

#### 4. 扑克牌顺子判断
```javascript
function isStraight(nums) {
  const set = new Set();
  let min = 14, max = 0;
  
  for (const num of nums) {
    if (num === 0) continue; // 跳过大小王
    if (set.has(num)) return false; // 有重复牌
    set.add(num);
    min = Math.min(min, num);
    max = Math.max(max, num);
  }
  
  return max - min < 5;
}
```

---

## 三面题目详解

### 八股文

#### 定位布局
- **相对定位**：相对于自身原本位置偏移，不脱离文档流
- **绝对定位**：相对于最近的非 static 定位祖先元素，脱离文档流
- **固定定位**：相对于视口定位，脱离文档流
- **粘性定位**：在滚动到特定阈值前为相对定位，之后变为固定定位

#### Sticky 定位实现滚动效果
```css
.sticky-element {
  position: sticky;
  top: 0;
  transition: all 0.3s;
}

/* 滚动到底部时回到顶部 */
.container:has(.bottom-trigger:visible) .sticky-element {
  position: relative;
  top: auto;
}
```

#### Vue 响应式原理
- **Vue2**：Object.defineProperty 劫持属性，递归遍历对象
- **Vue3**：Proxy 代理对象，惰性劫持，性能更好

#### Vue2 与 Vue3 区别
- 响应式原理不同
- Composition API vs Options API
- 更好的 TypeScript 支持
- 更小的包体积
- 更好的性能

### 算法题

#### 1. 多叉树路径和
```javascript
class TreeNode {
  constructor(val, children = []) {
    this.val = val;
    this.children = children;
  }
}

function hasPathSum(root, targetSum) {
  if (!root) return false;
  if (root.children.length === 0) return root.val === targetSum;
  
  for (let child of root.children) {
    if (hasPathSum(child, targetSum - root.val)) {
      return true;
    }
  }
  return false;
}
```

#### 2. 版本号排序
```javascript
function sortVersions(versions) {
  return versions.sort((a, b) => {
    const aParts = a.split('.').map(Number);
    const bParts = b.split('.').map(Number);
    
    for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {
      const aVal = aParts[i] || 0;
      const bVal = bParts[i] || 0;
      if (aVal !== bVal) return aVal - bVal;
    }
    return 0;
  });
}
```

#### 3. this 指向代码题
```javascript
// 常见 this 指向场景
const obj = {
  name: 'obj',
  method() {
    console.log(this.name);
  }
};

obj.method(); // 'obj'
const method = obj.method;
method(); // undefined (严格模式下) 或 window.name

// 箭头函数
const arrowObj = {
  name: 'arrowObj',
  method: () => {
    console.log(this.name);
  }
};
arrowObj.method(); // 取决于外层 this
```

---

以上是对字节跳动三面面试题的详细解答。这些题目涵盖了前端开发的核心知识点，包括 JavaScript 基础、算法数据结构、网络协议、框架原理等，是前端面试的典型考察内容。

# 数据库与缓存一致性解决方案总结
本文以程序员阿旺优化服务器性能、解决数据库与缓存一致性问题的场景为线索，系统分析了缓存更新策略的优劣及关键问题的解决方案，核心内容如下：

## 一、核心问题：缓存与数据库的更新顺序抉择
引入Redis作为数据库缓存后，核心矛盾是**数据更新时“数据库”与“缓存”的操作顺序如何选择**，需避免并发场景下的数据不一致问题。


### （一）“更新数据库+更新缓存”策略：存在并发一致性风险
该策略有两种操作顺序，但均因并发问题导致数据不一致：
1. **先更数据库，再更缓存**：若两个请求（A、B）并发更新同一条数据，可能出现“A更库→B更库→B更缓存→A更缓存”的顺序，最终库是B的新值，缓存是A的旧值。
2. **先更缓存，再更数据库**：类似地，可能出现“A更缓存→B更缓存→B更库→A更库”的顺序，最终库是A的新值，缓存是B的旧值。

**结论**：两种顺序均无法解决并发更新导致的不一致，仅适用于对缓存命中率要求极高的场景，且需额外加分布式锁（保证单线程更新缓存）或给缓存设短过期时间（兜底一致性）。


### （二）“更新数据库+删除缓存”策略（Cache Aside旁路缓存策略）：更优的基础方案
该策略分为“写策略”和“读策略”，核心是**更新时删缓存，读取时补缓存**，具体逻辑如下：
- **写策略**：先更新数据库，再删除缓存；
- **读策略**：缓存命中则直接返回，缓存未命中则读库→写缓存→返回。

#### 1. 两种删除顺序的对比
| 操作顺序 | 并发场景问题 | 实际可行性 |
|----------|--------------|------------|
| 先删缓存，再更数据库 | 读请求（B）在“删缓存后、更库前”触发，会读旧库值→写旧缓存，最终库新、缓存旧 | 一致性风险高，不推荐 |
| 先更数据库，再删缓存 | 理论上存在“读请求（A）读旧库值→删缓存→A写旧缓存”的顺序，但因“缓存写入远快于库写入”，实际发生概率极低 | 一致性风险低，推荐使用 |

#### 2. 方案兜底：给缓存加过期时间
即使极端情况下出现数据不一致，缓存过期后会自动失效，后续请求会读库补缓存，实现“最终一致性”。


## 二、关键难题：如何保证“更库+删缓存”两步都成功
“先更库，再删缓存”的核心风险是**第二步“删缓存”失败**，导致库是新值、缓存是旧值，用户需等缓存过期才看到新数据。解决方案分为两类：


### （一）消息队列重试机制：代码入侵式方案
1. **核心逻辑**：将“删缓存”操作存入消息队列，由消费者执行删缓存；
2. **重试机制**：删缓存失败则重新从队列取任务重试，重试超次数则报错；删缓存成功则从队列移除任务，避免重复执行；
3. **优缺点**：优点是能保证重试直到成功，缺点是需改造业务代码，入侵性强。


### （二）订阅MySQL binlog+消息队列：无代码入侵方案
1. **核心原理**：利用MySQL binlog记录数据库变更，通过Canal中间件（伪装MySQL从节点，订阅binlog）解析变更日志，将“需删缓存的key”发送到消息队列，消费者读取队列并执行删缓存；
2. **关键细节**：必须“删缓存成功后，才给消息队列回ACK”，避免消息丢失导致无法重试；
3. **优缺点**：优点是无业务代码入侵，一致性保障强；缺点是需引入Canal、消息队列等组件，对运维能力要求高。


## 三、补充问答：为何“删缓存”优于“更缓存”
1. **性能更轻量**：删除操作比更新操作（可能需聚合多表数据）更高效，减少计算资源消耗；
2. **避免无效更新**：更新后的缓存可能长时间不被访问，属于“无效计算”，而“删缓存+读时补缓存”符合Lazy Loading（懒加载）思想，仅在需要时才构建缓存；
3. **减少复杂逻辑**：若缓存数据来自多表聚合（如商品详情关联商品表、价格表），更新单表时“更缓存”需重新聚合多表数据，逻辑复杂，而“删缓存”无需关注数据来源。


## 四、最终推荐方案
1. **基础策略**：采用“先更新数据库，再删除缓存”（Cache Aside策略），并给缓存加过期时间；
2. **一致性保障**：优先选择“Canal订阅binlog+消息队列+删缓存重试”（无代码入侵），若团队运维能力有限，可选用“消息队列重试机制”；
3. **特殊场景**：对缓存命中率要求极高时，可选用“更库+更缓存”，并搭配分布式锁+短过期时间。

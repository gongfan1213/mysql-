## 米哈游前端日常实习二面详细解答

### 1. clientX/Y 与 pageX/Y 的区别

**核心区别：**
- **clientX/Y**：相对于**浏览器视口**的坐标，不包含滚动条滚动的距离
- **pageX/Y**：相对于**整个文档**的坐标，包含滚动条滚动的距离

**代码示例：**
```javascript
document.addEventListener('click', (event) => {
  console.log('clientX:', event.clientX); // 相对于视口
  console.log('pageX:', event.pageX);     // 相对于整个文档
  console.log('scrollX:', window.scrollX); // 水平滚动距离
  console.log('scrollY:', window.scrollY); // 垂直滚动距离
  
  // 关系：pageX = clientX + scrollX
  console.log('验证:', event.pageX === event.clientX + window.scrollX);
});
```

**拖拽指令中的应用：**
```javascript
// 在自定义拖拽指令中
const dragDirective = {
  mounted(el, binding) {
    let startX, startY, initialX, initialY;
    
    el.addEventListener('mousedown', (e) => {
      // 使用 clientX/Y 计算相对位移更合适
      startX = e.clientX;
      startY = e.clientY;
      initialX = el.offsetLeft;
      initialY = el.offsetTop;
      
      const onMouseMove = (e) => {
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        
        el.style.left = initialX + dx + 'px';
        el.style.top = initialY + dy + 'px';
      };
      
      const onMouseUp = () => {
        document.removeEventListener('mousemove', onMouseMove);
        document.removeEventListener('mouseup', onMouseUp);
      };
      
      document.addEventListener('mousemove', onMouseMove);
      document.addEventListener('mouseup', onMouseUp);
    });
  }
};
```

### 2. SVG 绘图的优点与性能优化

**SVG 的优点：**
- **矢量图形**：无限缩放不失真
- **DOM 操作**：可以直接用 CSS/JS 操作
- **可访问性**：支持文本描述和屏幕阅读器
- **动画能力**：内置 SMIL 动画，CSS/JS 动画支持
- **文件体积**：简单的图形体积小

**大量图形的性能瓶颈与解决方案：**

**问题：** DOM 节点过多导致重排重绘性能下降

**解决方案：**
```javascript
// 1. 使用 Canvas 2D 绘制大量图形
class MassGraphRenderer {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.shapes = [];
  }
  
  addShape(shape) {
    this.shapes.push(shape);
  }
  
  render() {
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    
    this.shapes.forEach(shape => {
      this.ctx.beginPath();
      // 绘制逻辑
      this.ctx.fillStyle = shape.color;
      this.ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
      this.ctx.fill();
    });
  }
}

// 2. SVG 优化 - 使用 <use> 元素复用
<svg>
  <defs>
    <circle id="template-circle" r="5" fill="blue"/>
  </defs>
  <use href="#template-circle" x="10" y="10"/>
  <use href="#template-circle" x="20" y="20"/>
  <!-- 大量复用 -->
</svg>

// 3. 虚拟化渲染 - 只渲染可见区域
class VirtualizedSVGRenderer {
  constructor(container, viewportWidth, viewportHeight) {
    this.container = container;
    this.viewportWidth = viewportWidth;
    this.viewportHeight = viewportHeight;
    this.allShapes = []; // 所有图形数据
    this.visibleShapes = []; // 可见图形
  }
  
  updateViewport(scrollX, scrollY) {
    // 计算可见区域
    const visibleRect = {
      x: scrollX,
      y: scrollY,
      width: this.viewportWidth,
      height: this.viewportHeight
    };
    
    // 筛选可见图形
    this.visibleShapes = this.allShapes.filter(shape => 
      this.isShapeVisible(shape, visibleRect)
    );
    
    this.render();
  }
  
  isShapeVisible(shape, visibleRect) {
    return shape.x + shape.radius >= visibleRect.x &&
           shape.x - shape.radius <= visibleRect.x + visibleRect.width &&
           shape.y + shape.radius >= visibleRect.y &&
           shape.y - shape.radius <= visibleRect.y + visibleRect.height;
  }
  
  render() {
    // 只渲染可见图形
    const svgContent = this.visibleShapes.map(shape => 
      `<circle cx="${shape.x}" cy="${shape.y}" r="${shape.radius}" fill="${shape.color}"/>`
    ).join('');
    
    this.container.innerHTML = svgContent;
  }
}
```

### 3. 同源限制与 postMessage

**同源限制 (Same-Origin Policy)：**
- **定义**：协议、域名、端口完全相同才是同源
- **目的**：防止恶意网站读取其他网站的敏感数据
- **限制范围**：Cookie、LocalStorage、DOM、AJAX 请求等

**postMessage 的同源限制：**
```javascript
// 父窗口向子窗口发送消息
const iframe = document.getElementById('iframe');
iframe.contentWindow.postMessage('hello', 'https://target-origin.com');

// 子窗口接收消息
window.addEventListener('message', (event) => {
  // 检查来源，增强安全性
  if (event.origin !== 'https://expected-origin.com') {
    return;
  }
  console.log('收到消息:', event.data);
});
```

**postMessage 没有严格的同源限制，但应该验证 origin 确保安全**

### 4. postMessage 数据传输限制与解决方案

**可传输的数据类型：**
- 字符串、数字、布尔值
- 数组、普通对象（可序列化的）
- ArrayBuffer、ImageBitmap（转移而非复制）

**不可直接传输的：**
- 函数、DOM 节点、类实例、循环引用对象

**传输函数的解决方案：**
```javascript
// 方案1：传输函数字符串（有安全风险）
const functionString = `function add(a, b) { return a + b; }`;
window.postMessage({
  type: 'function',
  code: functionString
}, '*');

// 接收方
window.addEventListener('message', (event) => {
  if (event.data.type === 'function') {
    const func = eval(`(${event.data.code})`);
    console.log(func(1, 2)); // 3
  }
});

// 方案2：预定义函数库，传输函数标识
const functionLibrary = {
  add: (a, b) => a + b,
  multiply: (a, b) => a * b
};

// 发送方
window.postMessage({
  type: 'execute',
  functionName: 'add',
  args: [1, 2]
}, '*');

// 接收方
window.addEventListener('message', (event) => {
  if (event.data.type === 'execute') {
    const result = functionLibrary[event.data.functionName](...event.data.args);
    console.log(result);
  }
});
```

**传输 DOM 节点的解决方案：**
```javascript
// 方案：传输选择器或序列化数据
// 发送方
const element = document.getElementById('my-element');
window.postMessage({
  type: 'element-info',
  selector: '#my-element',
  data: {
    text: element.textContent,
    className: element.className
  }
}, '*');
```

### 5. 多标签页通信方案

**1. localStorage + storage 事件：**
```javascript
// 标签页A - 发送消息
localStorage.setItem('cross-tab-message', JSON.stringify({
  from: 'tabA',
  message: 'hello',
  timestamp: Date.now()
}));

// 标签页B - 接收消息
window.addEventListener('storage', (event) => {
  if (event.key === 'cross-tab-message' && event.newValue) {
    const data = JSON.parse(event.newValue);
    console.log('收到消息:', data);
  }
});
```

**2. BroadcastChannel：**
```javascript
// 所有标签页
const channel = new BroadcastChannel('app-channel');

// 发送消息
channel.postMessage({
  type: 'data-update',
  data: { /* ... */ }
});

// 接收消息
channel.onmessage = (event) => {
  console.log('收到广播:', event.data);
};
```

**3. SharedWorker：**
```javascript
// shared-worker.js
const connections = [];

self.addEventListener('connect', (event) => {
  const port = event.ports[0];
  connections.push(port);
  
  port.addEventListener('message', (event) => {
    // 广播给所有连接
    connections.forEach(conn => {
      if (conn !== port) {
        conn.postMessage(event.data);
      }
    });
  });
  
  port.start();
});

// 页面中使用
const worker = new SharedWorker('shared-worker.js');
worker.port.postMessage('hello from tab');
worker.port.onmessage = (event) => {
  console.log('收到共享消息:', event.data);
};
```

### 6. RxJS 流式数据处理

**常见概念和操作符：**
```javascript
import { fromEvent, interval, of } from 'rxjs';
import { 
  map, 
  filter, 
  debounceTime, 
  switchMap, 
  takeUntil,
  mergeMap,
  catchError
} from 'rxjs/operators';

// 创建 Observable
const searchInput = document.getElementById('search');
const search$ = fromEvent(searchInput, 'input');

// 使用操作符处理流
const searchResult$ = search$.pipe(
  map(event => event.target.value),
  debounceTime(300), // 防抖
  filter(query => query.length >= 2), // 过滤
  switchMap(query => 
    from(fetch(`/api/search?q=${query}`)).pipe(
      mergeMap(response => response.json()),
      catchError(error => of({ error: true, message: error.message }))
    )
  )
);

// 订阅
searchResult$.subscribe(result => {
  console.log('搜索结果:', result);
});
```

**其他流处理方案对比：**
- **原生 Promise**：简单异步，但缺乏取消和组合能力
- **async/await**：语法糖，同样缺乏高级流控制
- **EventEmitter**：Node.js 事件机制，适合简单事件
- **Bacon.js**：类似的 FRP 库
- **Most.js**：高性能的流处理库

### 7. 虚拟列表实现

**定高虚拟列表：**
```javascript
class FixedVirtualList {
  constructor(container, itemHeight, renderItem) {
    this.container = container;
    this.itemHeight = itemHeight;
    this.renderItem = renderItem;
    this.data = [];
    this.visibleCount = Math.ceil(container.clientHeight / itemHeight);
    
    this.virtualScroll();
  }
  
  setData(newData) {
    this.data = newData;
    this.virtualScroll();
  }
  
  virtualScroll() {
    const scrollTop = this.container.scrollTop;
    const startIndex = Math.floor(scrollTop / this.itemHeight);
    const endIndex = Math.min(startIndex + this.visibleCount, this.data.length);
    
    // 渲染可见项
    const visibleData = this.data.slice(startIndex, endIndex);
    this.renderItems(visibleData, startIndex);
    
    // 设置容器高度支撑滚动
    this.container.style.height = this.data.length * this.itemHeight + 'px';
  }
  
  renderItems(items, startIndex) {
    const fragment = document.createDocumentFragment();
    
    items.forEach((item, index) => {
      const element = this.renderItem(item, startIndex + index);
      element.style.position = 'absolute';
      element.style.top = (startIndex + index) * this.itemHeight + 'px';
      fragment.appendChild(element);
    });
    
    this.container.innerHTML = '';
    this.container.appendChild(fragment);
  }
}
```

**不定高虚拟列表实现思路：**
```javascript
class DynamicVirtualList {
  constructor(container, estimateHeight, renderItem) {
    this.container = container;
    this.estimateHeight = estimateHeight;
    this.renderItem = renderItem;
    this.positions = []; // 记录每个元素的位置信息
  }
  
  // 初始化位置信息
  initPositions(data) {
    this.positions = data.map((_, index) => ({
      index,
      top: index * this.estimateHeight,
      height: this.estimateHeight,
      bottom: (index + 1) * this.estimateHeight
    }));
  }
  
  // 更新位置信息（渲染后测量实际高度）
  updatePositions(renderedItems) {
    renderedItems.forEach((element, relativeIndex) => {
      const actualIndex = parseInt(element.dataset.index);
      const actualHeight = element.offsetHeight;
      
      if (actualHeight !== this.positions[actualIndex].height) {
        // 高度变化，更新后续所有位置
        const heightDiff = actualHeight - this.positions[actualIndex].height;
        this.positions[actualIndex].height = actualHeight;
        this.positions[actualIndex].bottom = this.positions[actualIndex].top + actualHeight;
        
        // 更新后续元素位置
        for (let i = actualIndex + 1; i < this.positions.length; i++) {
          this.positions[i].top += heightDiff;
          this.positions[i].bottom += heightDiff;
        }
      }
    });
  }
  
  // 二分查找可见区域
  findVisibleRange(scrollTop, clientHeight) {
    const startIndex = this.binarySearch(this.positions, scrollTop);
    const endIndex = this.binarySearch(this.positions, scrollTop + clientHeight);
    
    return {
      start: Math.max(0, startIndex - 1), // 缓冲区
      end: Math.min(this.positions.length, endIndex + 1) // 缓冲区
    };
  }
  
  binarySearch(positions, scrollTop) {
    let left = 0;
    let right = positions.length - 1;
    
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const midValue = positions[mid].bottom;
      
      if (midValue < scrollTop) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    return left;
  }
}
```

**数据懒加载 vs 分页：**
- **相似点**：都是分批加载数据
- **不同点**：
  - 分页：明确的页面概念，用户主动切换
  - 懒加载：滚动触发，无缝体验
  - 分页有明确的边界，懒加载是连续的

## 手撕代码

### 1. 数组元素类型联合类型工具类型

```typescript
// 实现 GetArrayElementType<T>
type GetArrayElementType<T extends any[]> = T extends (infer U)[] ? U : never;

// 测试用例
type Test1 = GetArrayElementType<number[]>; // number
type Test2 = GetArrayElementType<[string, number, boolean]>; // string | number | boolean
type Test3 = GetArrayElementType<Array<{ id: number; name: string }>>; // { id: number; name: string }

// 更完善的版本，处理 readonly 数组和元组
type GetArrayElementTypeAdvanced<T> = 
  T extends readonly (infer U)[] ? U :
  T extends Array<infer U> ? U : never;

// 处理嵌套数组
type FlattenArray<T> = 
  T extends readonly (infer U)[] ? FlattenArray<U> : T;

type Test4 = FlattenArray<number[][][]>; // number
```

### 2. 缩进字符串转树形结构

```javascript
function parseIndentStringToTree(input) {
  const lines = input.trim().split('\n');
  const stack = [{ children: [] }]; // 根节点
  const result = stack[0].children;
  
  lines.forEach(line => {
    // 计算缩进级别
    const indentLevel = line.match(/^\s*/)[0].length;
    const content = line.trim();
    
    if (!content) return; // 跳过空行
    
    // 创建新节点
    const newNode = {
      name: content,
      children: []
    };
    
    // 根据缩进级别找到父节点
    while (stack.length > indentLevel + 1) {
      stack.pop();
    }
    
    // 添加到父节点的 children
    const parent = stack[stack.length - 1];
    parent.children.push(newNode);
    
    // 新节点入栈
    stack.push(newNode);
  });
  
  return result;
}

// 测试用例
const input = `
前端
  基础
    HTML
    CSS
      CSS基础
      CSS进阶
    JavaScript
  框架
    React
    Vue
  工具
    Webpack
    Vite
`;

const tree = parseIndentStringToTree(input);
console.log(JSON.stringify(tree, null, 2));

// 输出结果：
[
  {
    "name": "前端",
    "children": [
      {
        "name": "基础",
        "children": [
          {
            "name": "HTML",
            "children": []
          },
          {
            "name": "CSS",
            "children": [
              {
                "name": "CSS基础",
                "children": []
              },
              {
                "name": "CSS进阶",
                "children": []
              }
            ]
          },
          {
            "name": "JavaScript",
            "children": []
          }
        ]
      },
      {
        "name": "框架",
        "children": [
          {
            "name": "React",
            "children": []
          },
          {
            "name": "Vue",
            "children": []
          }
        ]
      },
      {
        "name": "工具",
        "children": [
          {
            "name": "Webpack",
            "children": []
          },
          {
            "name": "Vite",
            "children": []
          }
        ]
      }
    ]
  }
]
```

**增强版本（支持更多功能）：**
```javascript
function parseIndentStringToTreeAdvanced(input, options = {}) {
  const { indentChar = ' ', keyName = 'name', childrenName = 'children' } = options;
  const lines = input.trim().split('\n');
  const stack = [{ [childrenName]: [] }];
  const result = stack[0][childrenName];
  let prevIndentLevel = -1;
  
  lines.forEach((line, index) => {
    // 计算缩进（支持不同缩进字符）
    const indentMatch = line.match(new RegExp(`^${indentChar}*`));
    const indentLevel = indentMatch ? indentMatch[0].length : 0;
    const content = line.trim();
    
    if (!content) return;
    
    // 检查缩进是否合法
    if (indentLevel > prevIndentLevel + 1) {
      throw new Error(`第${index + 1}行缩进不合法: "${line}"`);
    }
    
    // 创建新节点
    const newNode = {
      [keyName]: content,
      [childrenName]: [],
      line: index + 1,
      indent: indentLevel
    };
    
    // 调整栈到正确层级
    while (stack.length > indentLevel + 1) {
      stack.pop();
    }
    
    // 添加到父节点
    const parent = stack[stack.length - 1];
    parent[childrenName].push(newNode);
    
    // 更新栈
    stack.push(newNode);
    prevIndentLevel = indentLevel;
  });
  
  return result;
}
```

这个面试确实很有挑战性，涉及了很多前端深度知识，特别是虚拟列表和复杂的数据结构处理。这些题目很好地考察了候选人的综合能力。

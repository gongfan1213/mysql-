## React Scheduler 具体调用机制

### Scheduler 工作原理
**核心调度流程：**
```javascript
// React Scheduler 的优先级系统
const ImmediatePriority = 1;    // 最高优先级
const UserBlockingPriority = 2;
const NormalPriority = 3;
const LowPriority = 4;
const IdlePriority = 5;         // 最低优先级

// 任务调度
function scheduleCallback(priorityLevel, callback) {
  // 获取当前时间
  const currentTime = getCurrentTime();
  
  // 根据优先级设置超时时间
  let timeout;
  switch (priorityLevel) {
    case ImmediatePriority:
      timeout = IMMEDIATE_PRIORITY_TIMEOUT; // -1
      break;
    case UserBlockingPriority:
      timeout = USER_BLOCKING_PRIORITY_TIMEOUT; // 250
      break;
    case IdlePriority:
      timeout = IDLE_PRIORITY_TIMEOUT; // 1073741823
      break;
    case LowPriority:
      timeout = LOW_PRIORITY_TIMEOUT; // 10000
      break;
    default:
      timeout = NORMAL_PRIORITY_TIMEOUT; // 5000
  }
  
  // 计算过期时间
  const expirationTime = currentTime + timeout;
  
  // 创建新任务
  const newTask = {
    id: taskIdCounter++,
    callback,
    priorityLevel,
    expirationTime,
    sortIndex: expirationTime,
  };
  
  // 将任务推入任务队列
  push(taskQueue, newTask);
  
  // 请求调度
  if (!isHostCallbackScheduled && !isPerformingWork) {
    isHostCallbackScheduled = true;
    requestHostCallback(flushWork);
  }
  
  return newTask;
}
```

**时间切片实现：**
```javascript
// 基于 MessageChannel 的调度
const channel = new MessageChannel();
const port = channel.port2;
channel.port1.onmessage = performWorkUntilDeadline;

function requestHostCallback(callback) {
  scheduledHostCallback = callback;
  if (!isMessageLoopRunning) {
    isMessageLoopRunning = true;
    port.postMessage(null);
  }
}

function performWorkUntilDeadline() {
  if (scheduledHostCallback !== null) {
    const currentTime = getCurrentTime();
    // 设置截止时间（5ms的时间切片）
    deadline = currentTime + yieldInterval;
    
    const hasMoreWork = scheduledHostCallback(
      currentTime,
      hasMoreWork
    );
    
    if (!hasMoreWork) {
      isMessageLoopRunning = false;
      scheduledHostCallback = null;
    } else {
      // 还有工作，继续调度
      port.postMessage(null);
    }
  }
}
```

## React 数据状态管理

### 现代 React 状态管理方案
**1. 内置状态：**
```javascript
// useState
const [state, setState] = useState(initialState);

// useReducer
const [state, dispatch] = useReducer(reducer, initialState);

// useSyncExternalStore (React 18+)
const state = useSyncExternalStore(subscribe, getSnapshot);
```

**2. 状态库对比：**
- **Redux Toolkit**：标准化 Redux
- **Zustand**：轻量级状态管理
- **Jotai**：原子式状态
- **Valtio**：Proxy-based 状态

**3. 服务器状态：**
```javascript
// React Query / TanStack Query
const { data, isLoading, error } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
});

// SWR
const { data, error } = useSWR('/api/data', fetcher);
```

## 视频流式传输

### 视频流技术方案
**1. HLS (HTTP Live Streaming)：**
```javascript
// M3U8 播放列表示例
#EXTM3U
#EXT-X-VERSION:3
#EXT-X-TARGETDURATION:10
#EXT-X-MEDIA-SEQUENCE:0
#EXTINF:10.0,
segment0.ts
#EXTINF:10.0,
segment1.ts
#EXTINF:10.0,
segment2.ts
```

**2. MPEG-DASH：**
```javascript
// MPD 文件结构
<MPD>
  <Period>
    <AdaptationSet>
      <Representation bandwidth="1000000">
        <SegmentTemplate media="video_$Number$.m4s"/>
      </Representation>
    </AdaptationSet>
  </Period>
</MPD>
```

**3. WebRTC (实时通信)：**
```javascript
// 获取视频流
navigator.mediaDevices.getUserMedia({ video: true, audio: true })
  .then(stream => {
    const videoElement = document.getElementById('video');
    videoElement.srcObject = stream;
    
    // 创建 PeerConnection
    const peerConnection = new RTCPeerConnection();
    stream.getTracks().forEach(track => {
      peerConnection.addTrack(track, stream);
    });
  });
```

## SSE (Server-Sent Events)

### SSE 实现方案
```javascript
// 客户端
const eventSource = new EventSource('/api/stream');

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('Received:', data);
};

eventSource.onerror = (error) => {
  console.error('SSE error:', error);
};

// 服务端 (Node.js)
app.get('/api/stream', (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive',
    'Access-Control-Allow-Origin': '*',
  });
  
  // 发送初始数据
  res.write(`data: ${JSON.stringify({ type: 'connected' })}\n\n`);
  
  // 定时发送数据
  const interval = setInterval(() => {
    res.write(`data: ${JSON.stringify({ 
      type: 'update', 
      timestamp: Date.now() 
    })}\n\n`);
  }, 1000);
  
  // 清理连接
  req.on('close', () => {
    clearInterval(interval);
  });
});
```

## 抖音搜索快速首屏优化

### 性能优化策略
**1. 预加载与预渲染：**
```javascript
// 路由预加载
import { preload } from 'react-router';

// 预加载搜索相关资源
const preloadSearch = () => {
  preload('/api/search-config');
  preload('/search-bundle.js');
};

// 鼠标悬停时预加载
const SearchLink = () => (
  <Link 
    to="/search" 
    onMouseEnter={preloadSearch}
  >
    搜索
  </Link>
);
```

**2. 数据预取：**
```javascript
// React 18 Suspense + 数据预取
const searchData = preloadData('/api/search-trending');

function SearchPage() {
  return (
    <Suspense fallback={<SearchSkeleton />}>
      <SearchResults data={searchData} />
    </Suspense>
  );
}
```

**3. 边缘计算：**
```javascript
// 使用边缘函数加速
// Cloudflare Workers 示例
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  // 在边缘节点处理搜索请求
  const url = new URL(request.url);
  if (url.pathname === '/api/search') {
    return handleSearch(request);
  }
  return fetch(request);
}
```

## SSR 水合失败兜底方案

### 水合失败检测与处理
**1. 检测水合失败：**
```javascript
// 水合失败检测
function useHydrationCheck() {
  const [isHydrated, setIsHydrated] = useState(false);
  const [hydrationError, setHydrationError] = useState(null);

  useEffect(() => {
    // 检查水合是否完成
    const checkHydration = () => {
      try {
        // 模拟水合检查
        const ssrMarkup = document.getElementById('ssr-content');
        if (ssrMarkup && !ssrMarkup.dataset.hydrated) {
          setHydrationError('Hydration failed');
          setIsHydrated(false);
        } else {
          setIsHydrated(true);
        }
      } catch (error) {
        setHydrationError(error.message);
        setIsHydrated(false);
      }
    };

    checkHydration();
  }, []);

  return { isHydrated, hydrationError };
}
```

**2. 兜底方案：**
```javascript
// 渐进式水合
function ProgressiveHydration({ children, fallback }) {
  const [shouldHydrate, setShouldHydrate] = useState(false);
  const { isHydrated, hydrationError } = useHydrationCheck();

  useEffect(() => {
    // 在空闲时间进行水合
    const idleCallback = requestIdleCallback(() => {
      setShouldHydrate(true);
    });

    return () => cancelIdleCallback(idleCallback);
  }, []);

  if (hydrationError) {
    // 水合失败，显示降级内容
    return fallback;
  }

  if (!shouldHydrate || !isHydrated) {
    // 延迟水合，显示静态内容
    return <div suppressHydrationWarning>{children}</div>;
  }

  // 正常渲染
  return children;
}
```

**3. 错误边界兜底：**
```javascript
class HydrationErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // 水合错误时更新状态
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // 报告水合错误
    console.error('Hydration failed:', error, errorInfo);
    
    // 强制客户端重新渲染
    this.setState({ hasError: true });
  }

  render() {
    if (this.state.hasError) {
      // 水合失败时的降级UI
      return this.props.fallback;
    }

    return this.props.children;
  }
}
```

## Monorepo 架构

### 优势与不足
**优势：**
- **代码共享**：组件、工具函数共享
- **统一构建**：一致的构建流程
- **依赖管理**：统一的依赖版本
- **开发效率**：跨包修改、统一测试

**不足：**
- **构建复杂度**：需要处理包间依赖
- **存储开销**：单个仓库体积大
- **权限控制**：细粒度权限管理复杂

### Package 粒度划分原则
```json
// 合理的包划分
{
  "packages": [
    // 核心包
    "packages/core",
    "packages/utils",
    
    // UI 组件
    "packages/ui-button",
    "packages/ui-modal",
    "packages/ui-form",
    
    // 业务功能
    "packages/features-search",
    "packages/features-user",
    
    // 工具链
    "packages/eslint-config",
    "packages/typescript-config",
    
    // 应用
    "apps/web",
    "apps/mobile"
  ]
}
```

**划分原则：**
- **单一职责**：每个包专注一个功能
- **复用性**：可被多个项目使用
- **独立性**：可独立发布和测试
- **依赖清晰**：避免循环依赖

## 构建工具对比

### Webpack vs Vite vs RSPack
**配置对比：**
```javascript
// Webpack 配置
module.exports = {
  entry: './src/index.js',
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        use: 'babel-loader'
      }
    ]
  },
  plugins: [
    new HtmlWebpackPlugin()
  ]
};

// Vite 配置
export default {
  plugins: [react()],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom']
        }
      }
    }
  }
};

// RSPack 配置 (基于 Rust)
module.exports = {
  entry: './src/index.js',
  builtins: {
    html: [{ template: './index.html' }]
  }
};
```

**性能特点：**
- **Webpack**：功能全面，生态成熟
- **Vite**：开发环境快速启动，基于 ESM
- **RSPack**：构建性能优秀，Rust 编写

## Turborepo 构建系统

### Turborepo 配置
```json
// turbo.json
{
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "test": {
      "dependsOn": ["build"],
      "outputs": []
    },
    "lint": {
      "outputs": []
    },
    "dev": {
      "cache": false,
      "persistent": true
    }
  }
}
```

**优势：**
- **增量构建**：只构建变更的包
- **并行执行**：最大化利用多核CPU
- **远程缓存**：团队共享构建缓存

## CI/CD 与 DevOps

### 完整 CI/CD 流程
```yaml
# GitHub Actions 示例
name: CI/CD Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: 18
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test
      
      - name: Run lint
        run: npm run lint

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build application
        run: npm run build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-output
          path: dist/

  deploy:
    needs: build
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Deploy to production
        run: npm run deploy
```

## 工程化质量保证

### 质量约束体系
**1. 代码规范：**
```json
// .eslintrc.js
module.exports = {
  extends: [
    'eslint:recommended',
    '@bytecode/eslint-config-react',
    '@bytecode/eslint-config-typescript'
  ],
  rules: {
    'react-hooks/exhaustive-deps': 'error',
    '@typescript-eslint/no-unused-vars': 'error'
  }
};
```

**2. 提交规范：**
```json
// .commitlintrc.js
module.exports = {
  extends: ['@commitlint/config-conventional'],
  rules: {
    'type-enum': [
      2,
      'always',
      ['feat', 'fix', 'docs', 'style', 'refactor', 'test', 'chore']
    ]
  }
};
```

**3. 自动化测试：**
```javascript
// 测试策略
// - 单元测试: Jest + Testing Library
// - 集成测试: Playwright
// - E2E 测试: Cypress

// 示例单元测试
import { render, screen } from '@testing-library/react';
import SearchComponent from './SearchComponent';

test('renders search input', () => {
  render(<SearchComponent />);
  const inputElement = screen.getByPlaceholderText(/搜索/i);
  expect(inputElement).toBeInTheDocument();
});
```

**4. 代码审查：**
```yaml
# PR 模板
## 变更描述
- [ ] 功能新增
- [ ] Bug 修复
- [ ] 代码重构
- [ ] 文档更新

## 检查清单
- [ ] 代码符合规范
- [ ] 测试用例覆盖
- [ ] 文档已更新
- [ ] 自测通过
```

这样的工程化体系能够确保代码质量，提高团队协作效率，同时保证项目的可维护性和可扩展性。

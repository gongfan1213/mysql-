## 字节豆包前端日常实习一面详细解答

### 1. useRef 使用场景

**常见使用场景：**
- **访问 DOM 元素**：
```javascript
function MyComponent() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  return (
    <>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus</button>
    </>
  );
}
```

- **存储可变值**（不触发重新渲染）：
```javascript
function Timer() {
  const countRef = useRef(0);
  const [count, setCount] = useState(0);
  
  const handleStart = () => {
    countRef.current = setInterval(() => {
      setCount(prev => prev + 1);
    }, 1000);
  };
  
  const handleStop = () => {
    clearInterval(countRef.current);
  };
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={handleStart}>Start</button>
      <button onClick={handleStop}>Stop</button>
    </div>
  );
}
```

- **保存上一次的值**：
```javascript
function usePrevious(value) {
  const ref = useRef();
  useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}
```

### 2. 较少使用的 Hook

**useLayoutEffect：**
- 在 DOM 更新后同步执行，会阻塞浏览器渲染
- 适用场景：需要同步读取 DOM 布局时
```javascript
function Tooltip() {
  const ref = useRef(null);
  const [position, setPosition] = useState({});
  
  useLayoutEffect(() => {
    const { top, left } = ref.current.getBoundingClientRect();
    setPosition({ top, left });
  }, []);
  
  return <div ref={ref}>Tooltip</div>;
}
```

**useImperativeHandle：**
- 自定义暴露给父组件的实例值
```javascript
// 子组件
const FancyInput = forwardRef((props, ref) => {
  const inputRef = useRef();
  
  useImperativeHandle(ref, () => ({
    focus: () => {
      inputRef.current.focus();
    },
    shake: () => {
      // 实现抖动动画
    }
  }));
  
  return <input ref={inputRef} />;
});

// 父组件
function Parent() {
  const inputRef = useRef();
  
  return (
    <>
      <FancyInput ref={inputRef} />
      <button onClick={() => inputRef.current.shake()}>Shake</button>
    </>
  );
}
```

### 3. 自定义 Hook 实现

**usePrevious：**
```javascript
function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  });
  
  return ref.current;
}

// 使用示例
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    <div>
      <p>Now: {count}, Before: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

**useToggle：**
```javascript
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setValue(prev => !prev);
  }, []);
  
  return [value, toggle];
}
```

### 4. React 底层原理

**Fiber 架构：**
- **目的**：解决大型应用卡顿问题，实现增量渲染
- **特点**：
  - 将渲染任务拆分成多个小任务（Fiber 节点）
  - 可中断、可恢复的渲染过程
  - 优先级调度机制

**Diff 算法：**
- **树对比**：只对比同一层级的节点
- **组件对比**：相同类型的组件继续 Diff，不同类型直接替换
- **Key 优化**：使用 key 识别节点移动，减少不必要的重新创建

**简易 React 实现思路：**
```javascript
// 简易的 createElement
function createElement(type, props, ...children) {
  return {
    type,
    props: {
      ...props,
      children: children.map(child =>
        typeof child === 'object' ? child : createTextElement(child)
      )
    }
  };
}

// 简易的渲染函数
function render(element, container) {
  const dom = element.type === 'TEXT_ELEMENT'
    ? document.createTextNode('')
    : document.createElement(element.type);
  
  // 设置属性
  Object.keys(element.props)
    .filter(key => key !== 'children')
    .forEach(name => {
      dom[name] = element.props[name];
    });
  
  // 递归渲染子元素
  element.props.children.forEach(child =>
    render(child, dom)
  );
  
  container.appendChild(dom);
}
```

### 5. React 合成事件机制

**特点：**
- **事件委托**：所有事件委托到 document（React 17+ 改为 root）
- **跨浏览器兼容**：统一事件对象，消除浏览器差异
- **性能优化**：减少内存占用，避免频繁绑定/解绑

**原理：**
```javascript
// 简易合成事件实现
class SyntheticEvent {
  constructor(nativeEvent) {
    this.nativeEvent = nativeEvent;
    this._stopPropagation = false;
  }
  
  stopPropagation() {
    this._stopPropagation = true;
    this.nativeEvent.stopPropagation();
  }
}

// 事件委托
document.addEventListener('click', (nativeEvent) => {
  const syntheticEvent = new SyntheticEvent(nativeEvent);
  
  // 找到对应的 React 组件处理函数
  const targetComponent = findTargetComponent(nativeEvent.target);
  if (targetComponent) {
    targetComponent.handleClick(syntheticEvent);
  }
});
```

### 6. 并发渲染实现

**从 requestIdleCallback 到 Scheduler：**
```javascript
// 基于 requestIdleCallback 的简易调度
function workLoop(deadline) {
  while (nextUnitOfWork && deadline.timeRemaining() > 1) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  }
  
  if (nextUnitOfWork) {
    requestIdleCallback(workLoop);
  }
}

requestIdleCallback(workLoop);

// React Scheduler 的优先级机制
const NoPriority = 0;
const ImmediatePriority = 1;
const UserBlockingPriority = 2;
const NormalPriority = 3;
const LowPriority = 4;
const IdlePriority = 5;
```

**并发特性：**
- **useTransition**：非阻塞的状态更新
- **useDeferredValue**：延迟更新某些值
```javascript
function SearchBox() {
  const [query, setQuery] = useState('');
  const deferredQuery = useDeferredValue(query);
  
  return (
    <>
      <input value={query} onChange={e => setQuery(e.target.value)} />
      <SearchResults query={deferredQuery} />
    </>
  );
}
```

### 7. React 新特性

**Suspense：**
```javascript
// 数据获取的 Suspense
function Profile() {
  const user = fetchUser(); // 抛出 Promise
  return <h1>{user.name}</h1>;
}

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <Profile />
    </Suspense>
  );
}
```

**Server Components：**
```javascript
// 服务端组件（不会发送到客户端）
async function Note({ id }) {
  const note = await db.notes.get(id); // 直接在服务端执行
  
  return (
    <div>
      <h1>{note.title}</h1>
      <p>{note.content}</p>
    </div>
  );
}
```

### 手撕代码

#### 函数柯里化
```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      };
    }
  };
}

// 使用示例
function add(a, b, c) {
  return a + b + c;
}

const curriedAdd = curry(add);
console.log(curriedAdd(1)(2)(3)); // 6
console.log(curriedAdd(1, 2)(3)); // 6
console.log(curriedAdd(1)(2, 3)); // 6
```

#### 二叉树路径总和
```javascript
class TreeNode {
  constructor(val, left = null, right = null) {
    this.val = val;
    this.left = left;
    this.right = right;
  }
}

function pathSum(root, targetSum) {
  const result = [];
  
  function dfs(node, currentPath, currentSum) {
    if (!node) return;
    
    currentPath.push(node.val);
    currentSum += node.val;
    
    // 叶子节点且路径和等于目标值
    if (!node.left && !node.right && currentSum === targetSum) {
      result.push([...currentPath]);
    }
    
    // 递归遍历左右子树
    dfs(node.left, currentPath, currentSum);
    dfs(node.right, currentPath, currentSum);
    
    // 回溯
    currentPath.pop();
  }
  
  dfs(root, [], 0);
  return result;
}

// 使用示例
const root = new TreeNode(5,
  new TreeNode(4,
    new TreeNode(11,
      new TreeNode(7),
      new TreeNode(2)
    )
  ),
  new TreeNode(8,
    new TreeNode(13),
    new TreeNode(4,
      new TreeNode(5),
      new TreeNode(1)
    )
  )
);

console.log(pathSum(root, 22));
// 输出: [[5,4,11,2], [5,8,4,5]]
```

### 面试总结建议

**准备重点：**
1. **项目深度**：熟悉每个项目的技术选型、难点、解决方案
2. **React 原理**：Fiber、Hooks 原理、事件机制、性能优化
3. **编码能力**：熟练掌握常见算法和设计模式
4. **工程化**：构建工具、代码规范、测试等

**回答技巧：**
- 结合具体项目经验回答问题
- 展示思考过程和解决问题的能力
- 主动提及相关的最佳实践和优化方案

这次面试主要考察 React 深度和实际编码能力，需要在这些方面重点准备。

## 页面性能评估核心指标

### 除加载时间外的核心性能指标

**1. Core Web Vitals（核心网页指标）：**
- **LCP (Largest Contentful Paint)**：最大内容绘制，测量加载性能
- **FID (First Input Delay)**：首次输入延迟，测量交互性
- **CLS (Cumulative Layout Shift)**：累计布局偏移，测量视觉稳定性

**2. 其他重要指标：**
- **FCP (First Contentful Paint)**：首次内容绘制
- **TTI (Time to Interactive)**：可交互时间
- **TBT (Total Blocking Time)**：总阻塞时间
- **INP (Interaction to Next Paint)**：下次绘制前的交互延迟

**3. 资源相关指标：**
- **缓存命中率**
- **资源压缩率**
- **第三方资源影响**

### 评估卡顿问题的方法

**1. 开发者工具分析：**
```javascript
// 使用 Performance 面板录制分析
// 观察 Long Tasks（长任务）
```

**2. 代码监控：**
```javascript
// 监控长任务
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.duration > 50) { // 超过50ms的任务
      console.log('Long task:', entry);
    }
  }
});
observer.observe({entryTypes: ['longtask']});

// 监控布局抖动
let lastLayoutTime = 0;
const resizeObserver = new ResizeObserver(entries => {
  const now = performance.now();
  if (now - lastLayoutTime < 100) {
    console.warn('Layout thrashing detected');
  }
  lastLayoutTime = now;
});
```

**3. 用户感知指标：**
- 滚动流畅度
- 动画帧率
- 输入响应时间

### 用 JavaScript 计算 FPS 核心原理

```javascript
class FPSMonitor {
  constructor() {
    this.fps = 0;
    this.frameCount = 0;
    this.lastTime = performance.now();
    this.rafId = null;
  }
  
  start() {
    const calculateFPS = (currentTime) => {
      this.frameCount++;
      
      // 每秒计算一次
      if (currentTime - this.lastTime >= 1000) {
        this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
        this.frameCount = 0;
        this.lastTime = currentTime;
        
        console.log(`FPS: ${this.fps}`);
        
        // 卡顿检测
        if (this.fps < 30) {
          console.warn('Low FPS detected:', this.fps);
        }
      }
      
      this.rafId = requestAnimationFrame(calculateFPS);
    };
    
    this.rafId = requestAnimationFrame(calculateFPS);
  }
  
  stop() {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
  }
}

// 使用
const fpsMonitor = new FPSMonitor();
fpsMonitor.start();
```

## CSS 布局问题

### vw 单位含义及区别

**vw (Viewport Width)：**
- **含义**：视口宽度的 1%，`1vw = 视口宽度的 1%`
- **特点**：相对于视口，不受父元素影响

**区别对比：**
| 单位 | 基准 | 响应式 | 应用场景 |
|------|------|--------|----------|
| px | 绝对像素 | 否 | 固定尺寸 |
| % | 父元素 | 是 | 相对布局 |
| vw | 视口宽度 | 是 | 全屏布局 |

**示例：**
```css
.container {
  width: 50%; /* 父元素宽度的一半 */
  width: 50vw; /* 视口宽度的一半 */
  width: 500px; /* 固定500像素 */
}
```

### 元素水平垂直居中方案

**1. Flexbox 方案：**
```css
.center-flex {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
```

**2. Grid 方案：**
```css
.center-grid {
  display: grid;
  place-items: center;
  height: 100vh;
}
```

**3. 绝对定位 + transform：**
```css
.center-absolute {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}
```

**4. Table-cell 方案：**
```css
.parent {
  display: table-cell;
  vertical-align: middle;
  text-align: center;
  width: 100vw;
  height: 100vh;
}
.child {
  display: inline-block;
}
```

## 同步异步执行顺序分析

**经典面试题示例：**
```javascript
console.log('1');

setTimeout(() => {
  console.log('2');
  Promise.resolve().then(() => {
    console.log('3');
  });
}, 0);

Promise.resolve().then(() => {
  console.log('4');
  setTimeout(() => {
    console.log('5');
  }, 0);
});

console.log('6');

// 执行顺序：1 -> 6 -> 4 -> 2 -> 3 -> 5
```

**执行机制：**
1. 同步代码（调用栈）
2. 微任务（Promise、queueMicrotask）
3. 宏任务（setTimeout、setInterval）
4. 渲染

## 手写代码实现

### 1. 画一个圆（直径固定页面宽度1/10，永远居中）

**HTML/CSS 实现：**
```html
<!DOCTYPE html>
<html>
<head>
  <style>
    .circle {
      width: 10vw;
      height: 10vw;
      border-radius: 50%;
      background-color: #3498db;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div class="circle"></div>
</body>
</html>
```

**React 实现：**
```jsx
import React from 'react';
import './Circle.css';

const Circle = () => {
  return <div className="circle"></div>;
};

export default Circle;
```

```css
/* Circle.css */
.circle {
  width: 10vw;
  height: 10vw;
  border-radius: 50%;
  background-color: #3498db;
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
}
```

### 2. 输入框关键词联想组件

**React 实现：**
```jsx
import React, { useState, useEffect, useRef } from 'react';
import axios from 'axios';

const AutoComplete = () => {
  const [inputValue, setInputValue] = useState('');
  const [suggestions, setSuggestions] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [showSuggestions, setShowSuggestions] = useState(false);
  const wrapperRef = useRef(null);

  // 点击外部关闭联想列表
  useEffect(() => {
    const handleClickOutside = (event) => {
      if (wrapperRef.current && !wrapperRef.current.contains(event.target)) {
        setShowSuggestions(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, []);

  // 获取联想词
  const fetchSuggestions = async (keyword) => {
    if (!keyword.trim()) {
      setSuggestions([]);
      return;
    }

    setIsLoading(true);
    try {
      const response = await axios.get('/api/auto_completion', {
        params: { q: keyword }
      });
      setSuggestions(response.data);
      setShowSuggestions(true);
    } catch (error) {
      console.error('Fetch suggestions failed:', error);
      setSuggestions([]);
    } finally {
      setIsLoading(false);
    }
  };

  // 防抖处理
  useEffect(() => {
    const timer = setTimeout(() => {
      fetchSuggestions(inputValue);
    }, 300);

    return () => clearTimeout(timer);
  }, [inputValue]);

  // 选择联想词
  const handleSelectSuggestion = (suggestion) => {
    setInputValue(suggestion);
    setShowSuggestions(false);
  };

  return (
    <div className="autocomplete-wrapper" ref={wrapperRef}>
      <input
        type="text"
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
        onFocus={() => setShowSuggestions(suggestions.length > 0)}
        placeholder="请输入关键词..."
        className="autocomplete-input"
      />
      
      {showSuggestions && (
        <ul className="suggestions-list">
          {isLoading ? (
            <li className="suggestion-item loading">加载中...</li>
          ) : suggestions.length > 0 ? (
            suggestions.map((suggestion, index) => (
              <li
                key={index}
                className="suggestion-item"
                onClick={() => handleSelectSuggestion(suggestion)}
              >
                {suggestion}
              </li>
            ))
          ) : (
            <li className="suggestion-item no-result">无匹配结果</li>
          )}
        </ul>
      )}
    </div>
  );
};

export default AutoComplete;
```

**配套 CSS：**
```css
.autocomplete-wrapper {
  position: relative;
  width: 300px;
  margin: 20px auto;
}

.autocomplete-input {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
  box-sizing: border-box;
}

.autocomplete-input:focus {
  outline: none;
  border-color: #3498db;
}

.suggestions-list {
  position: absolute;
  top: 100%;
  left: 0;
  right: 0;
  background: white;
  border: 1px solid #ddd;
  border-top: none;
  border-radius: 0 0 4px 4px;
  max-height: 200px;
  overflow-y: auto;
  list-style: none;
  margin: 0;
  padding: 0;
  z-index: 1000;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.suggestion-item {
  padding: 10px;
  cursor: pointer;
  border-bottom: 1px solid #f0f0f0;
}

.suggestion-item:hover {
  background-color: #f8f9fa;
}

.suggestion-item:last-child {
  border-bottom: none;
}

.suggestion-item.loading,
.suggestion-item.no-result {
  color: #999;
  cursor: default;
}

.suggestion-item.loading:hover,
.suggestion-item.no-result:hover {
  background-color: transparent;
}
```

## 输入联想组件优化点

**1. 性能优化：**
- **防抖/节流**：减少请求频率
- **缓存机制**：缓存已查询结果
- **请求取消**：避免过期请求

**2. 用户体验优化：**
- **高亮匹配文本**
- **键盘导航支持**（上下键选择，回车确认）
- **分组显示**（热门搜索、历史记录）
- **加载状态指示**

**3. 功能增强：**
- **多数据源支持**
- **错误重试机制**
- **自定义渲染模板**
- **虚拟滚动**（大量数据时）

**优化后的防抖和缓存：**
```javascript
const useAutoComplete = () => {
  const [cache, setCache] = useState(new Map());
  const requestControllerRef = useRef(null);

  const fetchSuggestions = useCallback(async (keyword) => {
    // 取消之前的请求
    if (requestControllerRef.current) {
      requestControllerRef.current.abort();
    }

    // 缓存检查
    if (cache.has(keyword)) {
      return cache.get(keyword);
    }

    // 创建新的 AbortController
    requestControllerRef.current = new AbortController();

    try {
      const response = await axios.get('/api/auto_completion', {
        params: { q: keyword },
        signal: requestControllerRef.current.signal
      });
      
      // 更新缓存
      setCache(prev => new Map(prev).set(keyword, response.data));
      return response.data;
    } catch (error) {
      if (error.name !== 'CanceledError') {
        console.error('Fetch failed:', error);
      }
      return [];
    }
  }, [cache]);

  return { fetchSuggestions };
};
```

## 前端核心学习方式

**1. 基础扎实：**
- **HTML/CSS/JavaScript** 三件套深度掌握
- **数据结构与算法**
- **计算机网络**（HTTP、TCP/IP）

**2. 框架理解：**
- 不仅要会用，更要理解原理
- 阅读源码，理解设计思想
- 关注生态和发展趋势

**3. 工程化能力：**
- **构建工具**（Webpack、Vite）
- **版本控制**（Git）
- **代码规范**、**测试**、**部署**

**4. 实践驱动：**
- **项目实战**：从简单到复杂
- **技术博客**：总结和输出
- **开源贡献**：参与社区

**5. 持续学习：**
- 关注技术动态
- 参加技术分享
- 构建知识体系

**学习路径建议：**
```
基础 → 框架 → 工程化 → 性能优化 → 架构设计
    ↓       ↓         ↓           ↓
 语法特性  原理理解  工具链搭建  用户体验
    ↓       ↓         ↓           ↓
 浏览器原理 设计模式  自动化     跨端开发
```

这样的学习方式能够建立扎实的前端基础，同时具备解决实际问题的能力。

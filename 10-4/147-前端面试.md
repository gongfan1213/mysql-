看起来是二面的题目，确实比较深入和全面。我来帮你系统整理这些问题的答案，让你下次面试能够更有条理地回答。

## 1. TCP vs UDP 区别

**系统性回答：**
```
传输层协议对比：
TCP (传输控制协议)：
✓ 面向连接 - 三次握手建立连接
✓ 可靠传输 - 确认机制、重传机制
✓ 流量控制 - 滑动窗口
✓ 拥塞控制 - 慢开始、拥塞避免
✓ 顺序保证 - 数据包按序到达
✓ 头部20字节 - 较大开销

UDP (用户数据报协议)：
✓ 无连接 - 直接发送数据
✓ 不可靠 - 不保证送达，无重传
✓ 无流量控制
✓ 无拥塞控制  
✓ 不保证顺序
✓ 头部8字节 - 开销小

应用场景：
TCP：HTTP、HTTPS、FTP、邮件等需要可靠传输的场景
UDP：视频流、语音通话、DNS查询、实时游戏等追求低延迟的场景
```

## 2. 浏览器输入URL到展示页面过程

**分阶段详细回答：**

### 阶段1：网络请求
```bash
1. URL解析 - 检查格式，处理特殊字符
2. DNS查询 - 域名→IP地址（浏览器缓存→系统缓存→路由器缓存→ISP DNS）
3. TCP连接 - 三次握手建立连接
4. TLS握手 - 如果是HTTPS
5. HTTP请求 - 发送请求头和数据
```

### 阶段2：浏览器处理
```bash
6. 响应处理 - 服务器返回状态码和数据
7. 解析HTML - 构建DOM树
8. 解析CSS - 构建CSSOM树  
9. 执行JS - 可能阻塞解析
10. 构建渲染树 - DOM + CSSOM
11. 布局计算 - 计算元素位置大小
12. 绘制页面 - 像素级绘制
```

### 阶段3：后续加载
```bash
13. 加载资源 - 图片、字体等
14. 执行异步代码 - 事件绑定等
```

## 3. Script标签阻塞分析与解决方案

### 阻塞原理
```html
<!-- 同步script会阻塞HTML解析 -->
<script src="app.js"></script>

<!-- 解析过程：
1. 遇到script标签
2. 暂停DOM构建
3. 下载并执行JS
4. 恢复DOM构建
-->
```

### 解决方案
```html
<!-- 方案1：defer - 延迟执行，不阻塞 -->
<script defer src="app.js"></script>

<!-- 方案2：async - 异步执行，下载不阻塞 -->
<script async src="analytics.js"></script>

<!-- 方案3：动态加载 -->
<script>
function loadScript(src) {
  const script = document.createElement('script');
  script.src = src;
  document.head.appendChild(script);
}
loadScript('app.js');
</script>

<!-- 方案4：ES6模块 -->
<script type="module" src="app.js"></script>
```

## 4. CSS代码阻塞分析与解决方案

### 阻塞原理
```html
<!-- CSS会阻塞渲染 -->
<link rel="stylesheet" href="style.css">

<!-- 影响：
1. CSS不阻塞DOM解析，但阻塞渲染
2. 浏览器会等待CSSOM构建完成后才渲染
3. 避免FOUC（样式闪烁）
-->
```

### 解决方案
```html
<!-- 方案1：媒体查询优化 -->
<link rel="stylesheet" href="print.css" media="print">
<link rel="stylesheet" href="mobile.css" media="(max-width: 768px)">

<!-- 方案2：关键CSS内联 -->
<style>
/* 关键样式内联 */
.header { color: blue; }
</style>
<link rel="stylesheet" href="non-critical.css" media="print" onload="this.media='all'">

<!-- 方案3：预加载 -->
<link rel="preload" href="style.css" as="style" onload="this.rel='stylesheet'">

<!-- 方案4：异步加载 -->
<script>
// 异步加载CSS
const link = document.createElement('link');
link.rel = 'stylesheet';
link.href = 'style.css';
document.head.appendChild(link);
</script>
```

## 5. requestAnimationFrame (raf) 与 requestIdleCallback (ric) 原理

### raf 原理
```javascript
// 在每一帧开始时执行，保证与浏览器渲染同步
function animate() {
  // 在浏览器下一帧渲染前执行
  element.style.transform = `translateX(${position}px)`;
  position += 1;
  
  if (position < 100) {
    requestAnimationFrame(animate);
  }
}
requestAnimationFrame(animate);

// 优势：
// 1. 60fps节流，避免过度渲染
// 2. 页面不可见时自动暂停
// 3. 电池友好
```

### ric 原理  
```javascript
// 在浏览器空闲时期执行
function processTask(deadline) {
  // deadline.timeRemaining() 返回剩余空闲时间
  while (deadline.timeRemaining() > 0 && tasks.length > 0) {
    processNextTask();
  }
  
  if (tasks.length > 0) {
    requestIdleCallback(processTask);
  }
}
requestIdleCallback(processTask);

// 适用场景：
// 1. 非关键任务
// 2. 数据分析上报
// 3. 预加载非关键资源
```

## 6. 浏览器帧数定义与优化

### 帧数定义
```
60fps = 每帧16.67ms
┌─────────────────────────────────────────┐
│ 一帧内的工作分配：                       │
│ • 输入事件处理    ≈ 2ms                 │
│ • JavaScript执行  ≈ 4ms                 │
│ • 样式计算        ≈ 2ms                 │
│ • 布局            ≈ 2ms                 │
│ • 绘制            ≈ 2ms                 │
│ • 合成            ≈ 2ms                 │
│ 总计             ≈ 14ms (留2ms余量)    │
└─────────────────────────────────────────┘
```

### 帧率优化
```javascript
// 避免在raf中执行耗时操作
function optimizedAnimation() {
  requestAnimationFrame(() => {
    // 将耗时任务拆分
    if (hasTimeLeft()) {
      doChunkOfWork();
    }
    
    // 或者使用web worker
    if (window.Worker) {
      worker.postMessage(heavyData);
    }
  });
}
```

## 7. 重排(Reflow) vs 重绘(Repaint)

### 定义与区别
```javascript
// 重排（回流）- 几何属性改变，需要重新计算布局
element.style.width = '100px';      // 重排
element.style.height = '200px';     // 重排
element.style.padding = '10px';     // 重排

// 重绘 - 外观改变，不影响布局
element.style.color = 'red';        // 重绘
element.style.backgroundColor = 'blue'; // 重绘
element.style.outline = '1px solid'; // 重绘

// 伪元素：通常是重绘
element::before { content: '★'; }   // 重绘
element::after { transform: scale(1.1); } // 可能引起重排
```

### 优化建议
```javascript
// 批量DOM操作
const fragment = document.createDocumentFragment();
items.forEach(item => fragment.appendChild(createElement(item)));
container.appendChild(fragment);

// 使用transform和opacity（跳过重排重绘，直接合成）
element.style.transform = 'translateX(100px)'; // 合成层
element.style.opacity = '0.5'; // 合成层
```

## 8. prefetch vs preload 区别

```html
<!-- preload - 当前页面肯定要用，高优先级 -->
<link rel="preload" href="critical-font.woff2" as="font" crossorigin>
<link rel="preload" href="main.js" as="script">

<!-- prefetch - 下个页面可能要用，低优先级 -->
<link rel="prefetch" href="next-page-data.json" as="document">
<link rel="prefetch" href="product-image.jpg" as="image">

<!-- 区别总结：
preload: 立即加载，当前页面使用，优先级高
prefetch: 空闲加载，未来页面使用，优先级低
-->
```

## 9. async vs defer 区别

```html
<!-- 无属性 - 同步执行，阻塞解析 -->
<script src="sync.js"></script>

<!-- async - 异步执行，下载不阻塞，执行时阻塞 -->
<script async src="async.js"></script>
<!-- 适用：不依赖DOM的独立脚本，如 analytics -->

<!-- defer - 延迟执行，不阻塞解析，在DOMContentLoaded前执行 -->
<script defer src="defer.js"></script>
<!-- 适用：依赖DOM的脚本 -->

<!-- 执行顺序比较：
无属性: 按出现顺序立即执行
async: 下载完立即执行，顺序不定
defer: 按出现顺序在DOM解析完后执行
-->
```

**script放头部的风险：**
- 阻塞DOM解析，导致白屏时间延长
- 如果脚本依赖DOM元素，可能获取不到
- 影响首屏渲染性能

## 10. React 核心认识

**系统性回答：**
```
React 设计理念：
1. 声明式编程 - 描述UI应该是什么样子
2. 组件化开发 - 可复用、可组合的UI单元  
3. 虚拟DOM - 高效的更新机制
4. 单向数据流 - 数据自上而下流动

核心特性：
• JSX语法 - JavaScript的语法扩展
• 状态管理 - useState, useReducer
• 生命周期 - useEffect, 生命周期钩子
• 上下文 - Context API
• Hooks - 函数组件的状态和副作用管理

生态体系：
• 状态管理: Redux, MobX, Zustand
• 路由: React Router
• UI库: Material-UI, Ant Design
• 服务端: Next.js, Remix
```

## 11. useEffect 依赖数组比较机制

```javascript
// React使用 Object.is 进行浅比较
Object.is([1, 2], [1, 2]); // false - 数组是引用类型

// 问题示例
function Component() {
  const [data] = useState([1, 2, 3]);
  const config = { type: 'user' };
  
  useEffect(() => {
    // 每次渲染都会执行，因为data和config是新对象
    fetchData(data, config);
  }, [data, config]); // 依赖项每次都是新对象
  
  // 解决方案1：使用useMemo
  const memoizedConfig = useMemo(() => ({ type: 'user' }), []);
  const memoizedData = useMemo(() => data, [data]);
  
  // 解决方案2：使用useRef（不会触发重渲染）
  const configRef = useRef({ type: 'user' });
  
  // 解决方案3：值类型依赖
  const dataString = JSON.stringify(data);
  useEffect(() => {
    fetchData(JSON.parse(dataString));
  }, [dataString]);
}
```

## 12. 图片懒加载实现

### 现代方案：Intersection Observer
```javascript
class LazyLoader {
  constructor() {
    this.observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          this.loadImage(entry.target);
          this.observer.unobserve(entry.target);
        }
      });
    }, {
      rootMargin: '50px', // 提前50px加载
      threshold: 0.1
    });
  }
  
  observe(img) {
    this.observer.observe(img);
  }
  
  loadImage(img) {
    const src = img.dataset.src;
    if (src) {
      img.src = src;
      img.removeAttribute('data-src');
    }
  }
}

// 使用
const lazyLoader = new LazyLoader();
document.querySelectorAll('img[data-src]').forEach(img => {
  lazyLoader.observe(img);
});
```

### 兼容方案：滚动监听 + 防抖
```javascript
function lazyLoadCompat() {
  const images = document.querySelectorAll('img[data-src]');
  
  const checkVisible = () => {
    images.forEach(img => {
      const rect = img.getBoundingClientRect();
      if (rect.top < window.innerHeight + 100) {
        img.src = img.dataset.src;
        img.removeAttribute('data-src');
      }
    });
  };
  
  // 防抖优化
  const debounceCheck = debounce(checkVisible, 100);
  window.addEventListener('scroll', debounceCheck);
  window.addEventListener('resize', debounceCheck);
  checkVisible(); // 初始检查
}
```

## 13. Fiber 架构深入理解

### Fiber 核心概念
```javascript
// Fiber节点结构
const fiberNode = {
  type: 'div',           // 节点类型
  key: null,             // 唯一标识
  stateNode: divElement, // 对应的DOM节点
  child: fiberNode,      // 第一个子节点
  sibling: fiberNode,    // 下一个兄弟节点
  return: fiberNode,     // 父节点
  pendingProps: {},      // 新的props
  memoizedProps: {},     // 当前的props
  memoizedState: null,   // 当前的state
  effectTag: null,       // 副作用标识
  nextEffect: null,      // 下一个副作用节点
  alternate: null,       // 对应的workInProgress节点
};

// Fiber调度原理
function workLoop() {
  while (nextUnitOfWork && !shouldYield()) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  }
  
  if (!nextUnitOfWork && workInProgressRoot) {
    commitRoot(); // 提交更新
  }
  
  requestIdleCallback(workLoop);
}
```

### Fiber 优势
```
1. 可中断执行 - 通过shouldYield判断是否有更高优先级任务
2. 任务分片 - 将渲染任务拆分成小单元
3. 优先级调度 - 不同更新有不同的优先级
4. 错误边界 - 更好的错误处理机制
```

## 14. CSS解析与DOM解析关系

**详细回答：**
```
解析过程时序：

1. 并行开始：
   - HTML解析器构建DOM树
   - CSS解析器构建CSSOM树

2. 关键依赖：
   - DOM解析遇到<link>和<style>会启动CSS解析
   - JavaScript执行可能依赖CSSOM（如获取样式）
   - 渲染树需要DOM + CSSOM都就绪

3. 阻塞关系：
   - CSS不阻塞DOM解析，但阻塞渲染
   - 浏览器会等待CSSOM构建完成才显示页面
   - 避免FOUC（无样式内容闪烁）

4. 优化策略：
   - 关键CSS内联
   - 非关键CSS异步加载
   - 合理使用媒体查询
```

## 15. Web Worker 详解

### 使用方式
```javascript
// 主线程
const worker = new Worker('worker.js');

worker.postMessage({ type: 'process', data: largeData });

worker.onmessage = (event) => {
  const result = event.data;
  updateUI(result);
};

worker.onerror = (error) => {
  console.error('Worker error:', error);
};

// worker.js
self.onmessage = (event) => {
  const { type, data } = event.data;
  
  if (type === 'process') {
    const result = heavyComputation(data);
    self.postMessage(result);
  }
};

function heavyComputation(data) {
  // 耗时计算
  return processedData;
}
```

### 适用场景
- 大量数据计算
- 图像/视频处理
- 复杂算法执行
- 实时数据分析

## 16. React流式传输 (Suspense & Streaming)

### React 18 流式渲染
```jsx
// 服务端组件
async function UserProfile({ userId }) {
  const user = await fetchUser(userId);
  return <div>{user.name}</div>;
}

// 客户端使用Suspense
function App() {
  return (
    <div>
      <Suspense fallback={<div>Loading user...</div>}>
        <UserProfile userId="123" />
      </Suspense>
      
      <Suspense fallback={<div>Loading posts...</div>}>
        <UserPosts userId="123" />
      </Suspense>
    </div>
  );
}

// 流式传输优势：
// 1. 逐步发送HTML
// 2. 更早显示页面框架
// 3. 并行加载资源
// 4. 更好的用户体验
```

## 17. 减小打包体积策略

### 多维度优化
```javascript
// webpack.config.js
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
  
  // 代码分割
  plugins: [
    new BundleAnalyzerPlugin(),
  ],
};

// 具体策略：
// 1. 代码分割 - SplitChunksPlugin
// 2. 摇树优化 - Tree Shaking  
// 3. 压缩代码 - TerserPlugin
// 4. Gzip压缩 - CompressionPlugin
// 5. 图片优化 - 压缩、WebP格式
// 6. 按需加载 - 动态import()
// 7. 外部化依赖 - CDN引入
// 8. 分析工具 - webpack-bundle-analyzer
```

## 18. 502 vs 504 状态码区别

```
502 Bad Gateway:
• 服务器作为网关或代理，从上游服务器收到无效响应
• 问题在中间服务器与后端服务器之间
• 常见原因：后端服务崩溃、配置错误、连接超时

504 Gateway Timeout:  
• 服务器作为网关或代理，没有及时从上游服务器收到请求
• 问题在网络连接或后端服务器响应超时
• 常见原因：后端服务处理超时、网络延迟、负载过高

排查方向：
502: 检查后端服务状态、代理配置
504: 检查超时设置、网络连接、后端性能
```

## 19. 手撕代码题

### 1. 升序数组元素出现次数

**方法1：直接遍历**
```javascript
function countOccurrences(arr, target) {
  let count = 0;
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === target) {
      count++;
    } else if (arr[i] > target) {
      break; // 提前终止，利用有序性
    }
  }
  return count;
}
```

**方法2：二分查找边界**
```javascript
function countOccurrencesBinary(arr, target) {
  function findFirst(target) {
    let left = 0, right = arr.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (arr[mid] >= target) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return left;
  }
  
  function findLast(target) {
    let left = 0, right = arr.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (arr[mid] <= target) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    return right;
  }
  
  const first = findFirst(target);
  const last = findLast(target);
  
  return first <= last ? last - first + 1 : 0;
}
```

### 2. 数组扁平化

**多种实现方式：**
```javascript
// 方法1：递归
function flattenRecursive(arr) {
  const result = [];
  
  function flattenHelper(arr) {
    for (const item of arr) {
      if (Array.isArray(item)) {
        flattenHelper(item);
      } else {
        result.push(item);
      }
    }
  }
  
  flattenHelper(arr);
  return result;
}

// 方法2：使用reduce
function flattenReduce(arr) {
  return arr.reduce((acc, curr) => {
    return acc.concat(Array.isArray(curr) ? flattenReduce(curr) : curr);
  }, []);
}

// 方法3：迭代 + 栈
function flattenIterative(arr) {
  const stack = [...arr];
  const result = [];
  
  while (stack.length) {
    const next = stack.pop();
    if (Array.isArray(next)) {
      stack.push(...next);
    } else {
      result.push(next);
    }
  }
  
  return result.reverse();
}

// 方法4：使用flat (ES2019)
function flattenFlat(arr) {
  return arr.flat(Infinity);
}
```

## 20. 反问技巧

**针对广告性能优化的反问：**
```javascript
// 可以问的具体问题：
1. "在广告业务中，你们遇到的最具挑战性的性能问题是什么？"
2. "团队目前主要使用哪些性能监控和优化工具？"
3. "在广告加载方面，有哪些具体的性能指标要求？"
4. "对于第三方广告脚本的加载优化，有什么最佳实践吗？"
5. "团队在性能优化方面未来的技术规划是什么？"
```

## 面试总结建议

1. **系统性思维**：回答问题要有结构，分点阐述
2. **原理理解**：不仅要会用，还要理解背后的机制
3. **实践经验**：结合真实项目经验讲解
4. **持续学习**：关注新技术和发展趋势
5. **压力管理**：紧张时深呼吸，先思考再回答

这些题目确实很有深度，好好消化后，下次面试一定能表现得更好！

好的，这是一套非常全面且高质量的前端面试题，涵盖了从具体技术到工程实践的多个层面。我们来逐一进行详细解答。

## 1. 询问插件的整个业务逻辑

这是一个开放式问题，我会以一个典型的 **前端埋点监控插件** 为例来说明其业务逻辑：

```javascript
class MonitoringPlugin {
  constructor(options) {
    // 初始化配置
    this.options = {
      appId: '',
      reportUrl: '',
      autoTrack: true, // 自动跟踪PV/UV
      performance: true, // 性能监控
      errorTrack: true, // 错误监控
      ...options
    };
    
    this.init();
  }

  init() {
    // 1. 检查环境
    if (!this.checkEnvironment()) return;
    
    // 2. 绑定事件监听器
    this.bindEvents();
    
    // 3. 性能数据收集
    if (this.options.performance) {
      this.performanceMonitor();
    }
    
    // 4. 错误监控
    if (this.options.errorTrack) {
      this.errorMonitor();
    }
    
    // 5. 用户行为跟踪
    if (this.options.autoTrack) {
      this.behaviorTrack();
    }
    
    // 6. 数据上报
    this.setupReport();
  }

  // 环境检查
  checkEnvironment() {
    return typeof window !== 'undefined' && 
           typeof document !== 'undefined' &&
           this.options.appId;
  }

  // 性能监控
  performanceMonitor() {
    window.addEventListener('load', () => {
      const timing = performance.timing;
      const perfData = {
        type: 'performance',
        dns: timing.domainLookupEnd - timing.domainLookupStart,
        tcp: timing.connectEnd - timing.connectStart,
        ttfb: timing.responseStart - timing.requestStart,
        domReady: timing.domContentLoadedEventEnd - timing.navigationStart,
        load: timing.loadEventEnd - timing.navigationStart
      };
      this.report(perfData);
    });
  }

  // 错误监控
  errorMonitor() {
    window.addEventListener('error', (event) => {
      const errorData = {
        type: 'error',
        message: event.message,
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
      };
      this.report(errorData);
    });

    // Promise错误
    window.addEventListener('unhandledrejection', (event) => {
      const errorData = {
        type: 'promise_error',
        reason: event.reason?.toString()
      };
      this.report(errorData);
    });
  }

  // 用户行为跟踪
  behaviorTrack() {
    // PV/UV统计
    this.report({
      type: 'page_view',
      url: window.location.href,
      referrer: document.referrer
    });

    // 点击事件跟踪
    document.addEventListener('click', (event) => {
      const target = event.target;
      const clickData = {
        type: 'click',
        element: target.tagName,
        id: target.id,
        className: target.className,
        text: target.textContent?.slice(0, 50)
      };
      this.report(clickData);
    });
  }

  // 数据上报
  setupReport() {
    this.cache = [];
    this.timer = null;
    
    // 批量上报，减少请求次数
    this.debouncedReport = this.debounce(() => {
      if (this.cache.length > 0) {
        this.sendBatch(this.cache);
        this.cache = [];
      }
    }, 1000);
  }

  report(data) {
    const reportData = {
      ...data,
      appId: this.options.appId,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent
    };

    this.cache.push(reportData);
    this.debouncedReport();
  }

  // 发送批量数据
  sendBatch(data) {
    const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
    navigator.sendBeacon(this.options.reportUrl, blob);
  }

  // 防抖函数
  debounce(fn, delay) {
    let timer = null;
    return function() {
      if (timer) clearTimeout(timer);
      timer = setTimeout(fn, delay);
    };
  }
}

// 使用示例
const monitor = new MonitoringPlugin({
  appId: 'your-app-id',
  reportUrl: 'https://api.example.com/report'
});
```

## 2. iframe通信有哪些方式

### 2.1 postMessage (推荐)
```html
<!-- 父页面 -->
<iframe id="childFrame" src="child.html"></iframe>
<script>
  const frame = document.getElementById('childFrame');
  
  // 向子iframe发送消息
  frame.contentWindow.postMessage({
    type: 'FROM_PARENT',
    data: 'Hello from parent'
  }, '*');

  // 接收来自子iframe的消息
  window.addEventListener('message', (event) => {
    if (event.data.type === 'FROM_CHILD') {
      console.log('收到子页面消息:', event.data.data);
    }
  });
</script>

<!-- 子页面 child.html -->
<script>
  // 向父页面发送消息
  window.parent.postMessage({
    type: 'FROM_CHILD', 
    data: 'Hello from child'
  }, '*');

  // 接收父页面消息
  window.addEventListener('message', (event) => {
    if (event.data.type === 'FROM_PARENT') {
      console.log('收到父页面消息:', event.data.data);
    }
  });
</script>
```

### 2.2 window.name
```javascript
// 父页面设置
frame.contentWindow.name = JSON.stringify({ message: 'hello' });

// 子页面读取
const data = JSON.parse(window.name);
```

### 2.3 document.domain (同域名下)
```javascript
// 父子页面都设置
document.domain = 'example.com';

// 然后可以直接访问
parent.document.getElementById('someElement');
```

### 2.4 MessageChannel
```javascript
// 创建通信通道
const channel = new MessageChannel();

// 父页面
frame.contentWindow.postMessage('init', '*', [channel.port2]);
channel.port1.onmessage = (event) => {
  console.log('收到消息:', event.data);
};

// 子页面
window.addEventListener('message', (event) => {
  const port = event.ports[0];
  port.onmessage = (event) => {
    console.log('收到消息:', event.data);
    port.postMessage('response from child');
  };
});
```

## 3. 为什么不用 EventSource

**EventSource (Server-Sent Events) 的局限性：**

```javascript
// EventSource 示例
const eventSource = new EventSource('/api/events');

eventSource.onmessage = (event) => {
  console.log('收到消息:', event.data);
};

eventSource.onerror = (error) => {
  console.error('EventSource错误:', error);
};

// 局限性：
const limitations = {
  // 1. 仅支持服务器到客户端的单向通信
  direction: 'server → client only',
  
  // 2. 仅支持文本数据，不支持二进制
  dataType: 'text only, no binary',
  
  // 3. 默认不支持跨域（需要CORS）
  cors: 'CORS required',
  
  // 4. 重连机制固定，难以自定义
  reconnect: 'auto-reconnect, hard to customize',
  
  // 5. 协议简单，功能有限
  protocol: 'simple protocol, limited features'
};

// WebSocket对比优势：
const ws = new WebSocket('wss://api.example.com/socket');

ws.onopen = () => {
  // 双向通信
  ws.send(JSON.stringify({ type: 'message', data: 'Hello' }));
};

ws.onmessage = (event) => {
  console.log('收到消息:', event.data);
};

// 支持二进制数据
ws.binaryType = 'arraybuffer';
```

## 4. 流式HTTP关闭与浏览器检测

### 4.1 服务端关闭流
```javascript
// Node.js Express 示例
app.get('/stream', (req, res) => {
  // 设置流式响应头
  res.writeHead(200, {
    'Content-Type': 'text/plain',
    'Transfer-Encoding': 'chunked'
  });
  
  let count = 0;
  const interval = setInterval(() => {
    if (count >= 10) {
      // 主动关闭流
      res.write('data: 流式传输结束\n\n');
      clearInterval(interval);
      res.end(); // 关闭连接
      return;
    }
    
    res.write(`data: 消息 ${count}\n\n`);
    count++;
  }, 1000);
  
  // 检测客户端断开
  req.on('close', () => {
    clearInterval(interval);
    console.log('客户端断开连接');
  });
});
```

### 4.2 浏览器检测流关闭
```javascript
// 使用 Fetch API + ReadableStream
async function fetchStream() {
  try {
    const response = await fetch('/api/stream');
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    
    while (true) {
      const { done, value } = await reader.read();
      
      if (done) {
        console.log('流式传输已完成');
        break;
      }
      
      const chunk = decoder.decode(value);
      console.log('收到数据:', chunk);
    }
  } catch (error) {
    console.log('流式传输被中断:', error);
  }
}

// 使用 EventSource
const eventSource = new EventSource('/api/stream');

eventSource.onmessage = (event) => {
  console.log('收到消息:', event.data);
};

eventSource.onerror = (event) => {
  if (event.eventPhase === EventSource.CLOSED) {
    console.log('连接已关闭');
  } else {
    console.log('连接错误:', event);
  }
};

// 手动关闭
// eventSource.close();
```

## 5. 项目介绍与页面结构

以一个 **在线教育平台** 为例：

```javascript
const projectStructure = {
  project: "在线教育平台",
  role: "前端负责人",
  techStack: ["Vue3", "TypeScript", "Vite", "Pinia", "Element Plus"],
  
  pages: {
    // 核心功能页面
    core: [
      {
        name: "首页",
        features: ["课程推荐", "轮播图", "搜索", "分类导航"],
        components: ["Banner", "CourseCard", "SearchBar"]
      },
      {
        name: "课程详情页", 
        features: ["课程信息", "教师介绍", "课程目录", "购买按钮"],
        components: ["VideoPlayer", "CourseInfo", "ChapterList"]
      },
      {
        name: "学习中心",
        features: ["视频播放", "课程目录", "笔记功能", "讨论区"],
        components: ["VideoPlayer", "Sidebar", "NoteEditor"]
      }
    ],
    
    // 用户相关页面
    user: [
      {
        name: "个人中心",
        features: ["个人信息", "我的课程", "学习进度", "订单管理"]
      },
      {
        name: "购物车",
        features: ["课程列表", "价格计算", "优惠券", "结算"]
      }
    ],
    
    // 管理页面
    admin: [
      {
        name: "仪表盘",
        features: ["数据统计", "用户分析", "收入报表"]
      }
    ]
  },
  
  keyFeatures: [
    "响应式设计，支持PC和移动端",
    "视频播放器自定义开发，支持多种格式",
    "实时聊天和问答系统",
    "学习进度同步和断点续看"
  ]
};
```

## 6. 前端监控内容

```javascript
const monitoringSystem = {
  // 性能监控
  performance: {
    timing: [
      "FP (First Paint)",
      "FCP (First Contentful Paint)", 
      "LCP (Largest Contentful Paint)",
      "FID (First Input Delay)",
      "CLS (Cumulative Layout Shift)"
    ],
    resources: [
      "DNS查询时间",
      "TCP连接时间", 
      "TTFB (Time to First Byte)",
      "资源加载时间"
    ]
  },
  
  // 错误监控
  errors: {
    javascript: [
      "运行时错误",
      "Promise rejection",
      "语法错误"
    ],
    resource: [
      "图片加载失败",
      "CSS加载失败", 
      "脚本加载失败"
    ],
    api: [
      "接口请求失败",
      "接口超时",
      "返回数据格式错误"
    ]
  },
  
  // 用户行为监控
  behavior: {
    navigation: [
      "PV (Page View)",
      "UV (Unique Visitor)", 
      "页面停留时间",
      "跳出率"
    ],
    interaction: [
      "点击事件",
      "表单提交", 
      "滚动深度",
      "按钮点击热力图"
    ]
  },
  
  // 业务监控
  business: {
    conversion: [
      "注册转化率",
      "购买转化率",
      "课程完成率"
    ],
    user: [
      "日活/月活",
      "用户留存率",
      "用户流失分析"
    ]
  }
};
```

## 7. 前端性能优化

```javascript
const performanceOptimization = {
  // 加载优化
  loading: [
    "代码分割 (Code Splitting)",
    "Tree Shaking",
    "资源压缩 (Gzip/Brotli)",
    "CDN加速",
    "HTTP/2 服务器推送"
  ],
  
  // 渲染优化  
  rendering: [
    "虚拟列表 (Virtual List)",
    "图片懒加载 (Lazy Load)",
    "防抖节流 (Debounce/Throttle)",
    "Web Worker 计算密集型任务",
    "CSS containment"
  ],
  
  // 缓存策略
  caching: [
    "Service Worker 缓存",
    "Memory Cache 合理使用",
    "LocalStorage 数据缓存",
    "IndexedDB 大容量数据"
  ],
  
  // 网络优化
  network: [
    "资源预加载 (preload)",
    "资源预连接 (preconnect)",
    "DNS预解析 (dns-prefetch)",
    "请求合并",
    "合理设置缓存头"
  ]
};
```

## 8. 跨域解决方案

```javascript
const corsSolutions = {
  // 1. CORS (推荐)
  cors: {
    description: "服务端设置响应头",
    example: `
      // Node.js Express
      app.use((req, res, next) => {
        res.header('Access-Control-Allow-Origin', '*');
        res.header('Access-Control-Allow-Methods', 'GET,POST,PUT,DELETE');
        res.header('Access-Control-Allow-Headers', 'Content-Type,Authorization');
        next();
      });
    `
  },
  
  // 2. 代理服务器
  proxy: {
    description: "开发环境代理",
    example: `
      // vite.config.js
      export default {
        server: {
          proxy: {
            '/api': {
              target: 'http://localhost:3000',
              changeOrigin: true
            }
          }
        }
      };
    `
  },
  
  // 3. JSONP
  jsonp: {
    description: "仅限GET请求",
    example: `
      function jsonp(url, callback) {
        const script = document.createElement('script');
        script.src = url + '?callback=' + callback;
        document.head.appendChild(script);
      }
      
      // 服务端返回: callbackName({data: ...});
    `
  },
  
  // 4. 其他方案
  others: [
    "nginx反向代理",
    "postMessage + iframe",
    "WebSocket (无跨域限制)"
  ]
};
```

## 9. WebSocket

```javascript
class WebSocketService {
  constructor(url) {
    this.url = url;
    this.socket = null;
    this.reconnectAttempts = 0;
    this.maxReconnectAttempts = 5;
    
    this.init();
  }
  
  init() {
    this.socket = new WebSocket(this.url);
    
    this.socket.onopen = () => {
      console.log('WebSocket连接已建立');
      this.reconnectAttempts = 0;
    };
    
    this.socket.onmessage = (event) => {
      const data = JSON.parse(event.data);
      this.handleMessage(data);
    };
    
    this.socket.onclose = () => {
      console.log('WebSocket连接已关闭');
      this.handleReconnect();
    };
    
    this.socket.onerror = (error) => {
      console.error('WebSocket错误:', error);
    };
  }
  
  send(message) {
    if (this.socket.readyState === WebSocket.OPEN) {
      this.socket.send(JSON.stringify(message));
    } else {
      console.warn('WebSocket未连接');
    }
  }
  
  handleMessage(data) {
    switch (data.type) {
      case 'chat':
        this.onChatMessage(data);
        break;
      case 'notification':
        this.onNotification(data);
        break;
      case 'heartbeat':
        this.send({ type: 'pong' });
        break;
    }
  }
  
  handleReconnect() {
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++;
      setTimeout(() => {
        console.log(`尝试重连... (${this.reconnectAttempts})`);
        this.init();
      }, 3000 * this.reconnectAttempts);
    }
  }
  
  close() {
    this.socket.close();
  }
}

// 使用示例
const ws = new WebSocketService('wss://api.example.com/ws');
```

## 10. 权限管理

```javascript
// 权限控制类
class PermissionManager {
  constructor() {
    this.userRoles = [];
    this.permissions = new Map();
  }
  
  // 设置用户角色
  setUserRoles(roles) {
    this.userRoles = roles;
    this.loadPermissions();
  }
  
  // 加载权限映射
  loadPermissions() {
    this.permissions.set('view_dashboard', ['admin', 'teacher']);
    this.permissions.set('manage_users', ['admin']);
    this.permissions.set('create_course', ['admin', 'teacher']);
    this.permissions.set('view_reports', ['admin', 'teacher', 'assistant']);
  }
  
  // 检查权限
  hasPermission(permission) {
    const allowedRoles = this.permissions.get(permission) || [];
    return this.userRoles.some(role => allowedRoles.includes(role));
  }
  
  // 路由守卫
  routeGuard(to, from, next) {
    const requiredPermission = to.meta?.permission;
    
    if (!requiredPermission || this.hasPermission(requiredPermission)) {
      next();
    } else {
      next('/403'); // 无权限页面
    }
  }
  
  // 按钮级权限指令 (Vue)
  install(app) {
    app.directive('permission', {
      mounted(el, binding) {
        const permission = binding.value;
        if (!this.hasPermission(permission)) {
          el.parentNode?.removeChild(el);
        }
      }
    });
  }
}

// 使用示例
const permissionManager = new PermissionManager();
permissionManager.setUserRoles(['teacher']);

console.log(permissionManager.hasPermission('create_course')); // true
console.log(permissionManager.hasPermission('manage_users')); // false
```

## 11. OAuth2 逻辑流程

```javascript
class OAuth2Client {
  constructor(config) {
    this.clientId = config.clientId;
    this.clientSecret = config.clientSecret;
    this.redirectUri = config.redirectUri;
    this.authUrl = config.authUrl;
    this.tokenUrl = config.tokenUrl;
  }
  
  // 1. 构建授权URL
  getAuthUrl() {
    const params = new URLSearchParams({
      client_id: this.clientId,
      redirect_uri: this.redirectUri,
      response_type: 'code',
      scope: 'read write',
      state: this.generateState(),
    });
    
    return `${this.authUrl}?${params}`;
  }
  
  // 2. 处理回调，获取授权码
  handleCallback() {
    const urlParams = new URLSearchParams(window.location.search);
    const code = urlParams.get('code');
    const state = urlParams.get('state');
    
    if (!this.validateState(state)) {
      throw new Error('Invalid state parameter');
    }
    
    return this.exchangeCodeForToken(code);
  }
  
  // 3. 用授权码交换访问令牌
  async exchangeCodeForToken(code) {
    const response = await fetch(this.tokenUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        client_id: this.clientId,
        client_secret: this.clientSecret,
        redirect_uri: this.redirectUri,
        code: code,
      }),
    });
    
    const tokenData = await response.json();
    this.storeTokens(tokenData);
    return tokenData;
  }
  
  // 4. 存储令牌
  storeTokens(tokenData) {
    localStorage.setItem('access_token', tokenData.access_token);
    localStorage.setItem('refresh_token', tokenData.refresh_token);
    localStorage.setItem('expires_in', Date.now() + tokenData.expires_in * 1000);
  }
  
  // 5. 使用访问令牌调用API
  async apiCall(url, options = {}) {
    let accessToken = localStorage.getItem('access_token');
    
    // 检查令牌是否过期
    if (this.isTokenExpired()) {
      accessToken = await this.refreshToken();
    }
    
    const response = await fetch(url, {
      ...options,
      headers: {
        'Authorization': `Bearer ${accessToken}`,
        'Content-Type': 'application/json',
        ...options.headers,
      },
    });
    
    if (response.status === 401) {
      // 令牌失效，重新授权
      this.startAuthorization();
      return;
    }
    
    return response;
  }
  
  // 6. 刷新令牌
  async refreshToken() {
    const refreshToken = localStorage.getItem('refresh_token');
    
    const response = await fetch(this.tokenUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
      },
      body: new URLSearchParams({
        grant_type: 'refresh_token',
        client_id: this.clientId,
        client_secret: this.clientSecret,
        refresh_token: refreshToken,
      }),
    });
    
    const tokenData = await response.json();
    this.storeTokens(tokenData);
    return tokenData.access_token;
  }
  
  // 工具方法
  generateState() {
    const state = Math.random().toString(36).substring(2);
    sessionStorage.setItem('oauth_state', state);
    return state;
  }
  
  validateState(state) {
    const savedState = sessionStorage.getItem('oauth_state');
    sessionStorage.removeItem('oauth_state');
    return state === savedState;
  }
  
  isTokenExpired() {
    const expiresIn = localStorage.getItem('expires_in');
    return Date.now() > parseInt(expiresIn);
  }
}
```

## 12. HTML, JS, CSS 缓存策略

```javascript
const cacheStrategies = {
  // 强缓存 - 适合不常变化的资源
  strongCache: {
    html: {
      // HTML不建议强缓存，使用协商缓存
      'Cache-Control': 'no-cache', 
      'ETag': true
    },
    js: {
      // JS文件可以强缓存，通过文件名hash版本控制
      'Cache-Control': 'public, max-age=31536000', // 1年
      'filename': 'app.[hash].js'
    },
    css: {
      // CSS同样使用hash版本控制
      'Cache-Control': 'public, max-age=31536000',
      'filename': 'style.[hash].css'
    }
  },
  
  // 协商缓存 - 适合经常变化的资源
  negotiatedCache: {
    html: {
      'Cache-Control': 'no-cache',
      'ETag': true,
      'Last-Modified': true
    },
    api: {
      'Cache-Control': 'no-cache',
      'ETag': true
    }
  },
  
  // 实际配置示例 (nginx)
  nginxConfig: `
    # HTML - 协商缓存
    location ~* \.html$ {
      add_header Cache-Control "no-cache";
      etag on;
    }
    
    # JS/CSS - 强缓存
    location ~* \.(js|css)$ {
      expires 1y;
      add_header Cache-Control "public, immutable";
    }
    
    # 图片 - 强缓存
    location ~* \.(jpg|jpeg|png|gif|ico)$ {
      expires 1y;
      add_header Cache-Control "public";
    }
  `,
  
  // 前端构建配置 (webpack)
  webpackConfig: {
    output: {
      filename: '[name].[contenthash].js',
      chunkFilename: '[name].[contenthash].chunk.js'
    },
    optimization: {
      splitChunks: {
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
          },
        },
      },
    }
  }
};
```

## 13. Git 常用命令

```bash
# 基础操作
git init                    # 初始化仓库
git clone <url>            # 克隆远程仓库
git status                 # 查看状态
git add <file>             # 添加文件到暂存区
git commit -m "message"    # 提交更改

# 分支管理
git branch                 # 查看分支
git branch <name>          # 创建分支  
git checkout <branch>      # 切换分支
git checkout -b <branch>   # 创建并切换分支
git merge <branch>         # 合并分支
git branch -d <branch>     # 删除分支

# 远程操作
git remote add origin <url> # 添加远程仓库
git push -u origin main    # 推送到远程
git pull                   # 拉取更新
git fetch                  # 获取远程更新

# 撤销与回退
git reset --hard <commit>  # 重置到指定提交
git revert <commit>        # 撤销指定提交
git checkout -- <file>     # 撤销文件修改

# 查看信息
git log                    # 查看提交历史
git diff                   # 查看差异
git show <commit>          # 查看提交详情

# 标签管理
git tag <tagname>          # 创建标签
git push origin <tagname>  # 推送标签

# 储藏更改
git stash                  # 储藏当前更改
git stash pop              # 应用储藏内容
```

## 14. Promise 相关编程题

```javascript
// 1. Promise基础实现
class MyPromise {
  constructor(executor) {
    this.state = 'pending';
    this.value = undefined;
    this.reason = undefined;
    this.onFulfilledCallbacks = [];
    this.onRejectedCallbacks = [];
    
    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled';
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    };
    
    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected';
        this.reason = reason;
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };
    
    try {
      executor(resolve, reject);
    } catch (error) {
      reject(error);
    }
  }
  
  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      const handleFulfilled = () => {
        try {
          const result = onFulfilled(this.value);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      };
      
      const handleRejected = () => {
        try {
          const result = onRejected(this.reason);
          resolve(result);
        } catch (error) {
          reject(error);
        }
      };
      
      if (this.state === 'fulfilled') {
        setTimeout(handleFulfilled, 0);
      } else if (this.state === 'rejected') {
        setTimeout(handleRejected, 0);
      } else {
        this.onFulfilledCallbacks.push(() => setTimeout(handleFulfilled, 0));
        this.onRejectedCallbacks.push(() => setTimeout(handleRejected, 0));
      }
    });
  }
}

// 2. Promise.all实现
Promise.myAll = function(promises) {
  return new Promise((resolve, reject) => {
    const results = [];
    let completed = 0;
    
    if (promises.length === 0) {
      resolve(results);
      return;
    }
    
    promises.forEach((promise, index) => {
      Promise.resolve(promise).then(value => {
        results[index] = value;
        completed++;
        
        if (completed === promises.length) {
          resolve(results);
        }
      }).catch(reject);
    });
  });
};

// 3. Promise.race实现
Promise.myRace = function(promises) {
  return new Promise((resolve, reject) => {
    promises.forEach(promise => {
      Promise.resolve(promise).then(resolve).catch(reject);
    });
  });
};

// 4. 使用示例
const p1 = Promise.resolve(1);
const p2 = Promise.resolve(2);
const p3 = new Promise(resolve => setTimeout(() => resolve(3), 1000));

Promise.myAll([p1, p2, p3]).then(console.log); // [1, 2, 3]
Promise.myRace([p1, p2, p3]).then(console.log); // 1
```

## 15. 合并有序数组

```javascript
// 方法1: 双指针 - 时间复杂度 O(m+n)
function mergeSortedArrays(arr1, arr2) {
  const result = [];
  let i = 0, j = 0;
  
  while (i < arr1.length && j < arr2.length) {
    if (arr1[i] <= arr2[j]) {
      result.push(arr1[i]);
      i++;
    } else {
      result.push(arr2[j]);
      j++;
    }
  }
  
  // 处理剩余元素
  while (i < arr1.length) {
    result.push(arr1[i]);
    i++;
  }
  
  while (j < arr2.length) {
    result.push(arr2[j]);
    j++;
  }
  
  return result;
}

// 方法2: 使用数组方法 - 简洁但性能稍差
function mergeSortedArraysSimple(arr1, arr2) {
  return [...arr1, ...arr2].sort((a, b) => a - b);
}

// 方法3: 原地合并 (适合arr1有足够空间)
function mergeInPlace(arr1, m, arr2, n) {
  let i = m - 1, j = n - 1, k = m + n - 1;
  
  while (i >= 0 && j >= 0) {
    if (arr1[i] > arr2[j]) {
      arr1[k] = arr1[i];
      i--;
    } else {
      arr1[k] = arr2[j];
      j--;
    }
    k--;
  }
  
  while (j >= 0) {
    arr1[k] = arr2[j];
    j--;
    k--;
  }
  
  return arr1;
}

// 测试用例
console.log(mergeSortedArrays([1, 3, 5], [2, 4, 6])); 
// [1, 2, 3, 4, 5, 6]

console.log(mergeSortedArrays([], [1, 2, 3])); 
// [1, 2, 3]

console.log(mergeSortedArrays([1, 2, 3], [])); 
// [1, 2, 3]

// 性能测试
const largeArr1 = Array.from({ length: 10000 }, (_, i) => i * 2);
const largeArr2 = Array.from({ length: 10000 }, (_, i) => i * 2 + 1);

console.time('双指针合并');
mergeSortedArrays(largeArr1, largeArr2);
console.timeEnd('双指针合并');

console.time('简单合并'); 
mergeSortedArraysSimple(largeArr1, largeArr2);
console.timeEnd('简单合并');
```

这套面试题确实非常全面，涵盖了前端开发的各个重要方面。建议在准备时不仅要理解概念，更要动手实践代码，这样才能在面试中游刃有余。

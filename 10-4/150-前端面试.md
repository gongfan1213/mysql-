这是一个非常全面的前端面试题列表，涵盖了网络、操作系统、HTTP、浏览器原理和移动端适配等核心知识点。我会先列出问题，然后为你提供详细的答案。

## 问题列表
1. DNS解析的过程？怎么调试
2. A记录和CNAME记录的区别
3. 讲讲进程和线程
4. 进程通讯的方式有哪些？具体说说
5. SSE和WebSocket的区别？具体到数据传输
6. 讲讲HTTPS？证书是用来干嘛的？
7. HTTP2和3
8. HTTP1.1设置了keepalive会发生什么
9. JS事件循环
10. 浏览器渲染的流程
11. 改变字体大小会导致回流吗？
12. setTimeout不精确的原因有哪些？
13. 浏览器垃圾回收机制？标记清除法有什么缺点？为什么要分代？
14. 渲染过程中遇到script怎么处理
15. 可能出现DOM树没有但渲染树中有节点的情况吗
16. 移动端适配有哪些方案？优缺点？

---

## 详细解答

### 1. DNS解析的过程？怎么调试

**DNS解析过程：**
1. **浏览器缓存**：检查浏览器本地缓存
2. **系统缓存**：检查hosts文件和系统DNS缓存
3. **路由器缓存**：查询路由器DNS缓存
4. **ISP DNS服务器**：向ISP的DNS服务器查询
5. **递归查询**：
   - 根域名服务器（.）
   - 顶级域名服务器（.com）
   - 权威域名服务器（example.com）
6. **返回结果**：获取IP地址并缓存

**调试方法：**
- `nslookup domain`：查询DNS记录
- `dig domain`：更详细的DNS查询
- `ping domain`：测试连通性并显示解析的IP
- 浏览器开发者工具Network面板查看DNS查询时间
- `chrome://net-internals/#dns`：Chrome DNS缓存管理

### 2. A记录和CNAME记录的区别

- **A记录**：将域名直接指向IPv4地址
  ```
  example.com → 192.0.2.1
  ```

- **CNAME记录**：将域名指向另一个域名（别名）
  ```
  www.example.com → example.com
  ```

**区别：**
- A记录映射到IP，CNAME映射到另一个域名
- CNAME可以实现灵活的域名管理，修改时只需改目标域名
- A记录查询更快，少一次解析步骤

### 3. 讲讲进程和线程

**进程**：
- 资源分配的基本单位，有独立的内存空间
- 包含代码、数据、堆栈等资源
- 进程间相互隔离，通信需要IPC机制
- 创建和销毁开销大

**线程**：
- CPU调度的基本单位，共享进程资源
- 有独立的栈，共享堆和全局变量
- 创建和切换开销小
- 需要同步机制避免资源竞争

### 4. 进程通讯的方式有哪些？具体说说

1. **管道**：单向数据流，用于父子进程通信
2. **消息队列**：通过消息传递数据，支持多对多通信
3. **共享内存**：最高效的方式，多个进程映射同一内存区域
4. **信号量**：用于进程间同步，控制资源访问
5. **信号**：异步通知机制，如kill命令
6. **Socket**：网络通信，支持不同主机间进程通信

### 5. SSE和WebSocket的区别？具体到数据传输

| 特性 | SSE | WebSocket |
|------|-----|-----------|
| 协议 | HTTP | 独立的WebSocket协议 |
| 方向 | 服务器到客户端单向 | 全双工双向 |
| 重连 | 自动重连机制 | 需要手动处理 |
| 数据格式 | 文本格式 | 二进制和文本 |
| 兼容性 | 较好 | 现代浏览器支持 |

**数据传输：**
- **SSE**：基于HTTP长连接，服务器推送文本数据，格式简单
- **WebSocket**：建立独立连接，支持二进制帧传输，效率更高

### 6. 讲讲HTTPS？证书是用来干嘛的？

**HTTPS = HTTP + SSL/TLS加密**

**工作流程：**
1. 客户端发起HTTPS请求
2. 服务器返回数字证书
3. 客户端验证证书有效性
4. 密钥交换，生成会话密钥
5. 使用对称加密进行安全通信

**证书的作用：**
- **身份验证**：确认服务器身份，防止中间人攻击
- **加密密钥交换**：安全地协商加密密钥
- **数据完整性**：确保数据在传输中未被篡改

### 7. HTTP2和HTTP3

**HTTP2特性：**
- 二进制分帧：提高传输效率
- 多路复用：一个连接并行多个请求
- 头部压缩：HPACK算法减少开销
- 服务器推送：服务器主动推送资源

**HTTP3特性：**
- 基于QUIC协议（UDP而非TCP）
- 改进的拥塞控制
- 0-RTT连接建立
- 更好的移动网络支持
- 解决队头阻塞问题

### 8. HTTP1.1设置了keepalive会发生什么

- **默认行为**：HTTP/1.1默认开启持久连接
- **连接复用**：同一个TCP连接可以处理多个HTTP请求
- **减少开销**：避免每次请求都进行TCP三次握手
- **超时控制**：通过`Keep-Alive: timeout=5`设置超时时间
- **限制**：浏览器对同一域名仍有连接数限制（通常6-8个）

### 9. JS事件循环

**执行机制：**
1. **调用栈**：同步代码执行
2. **微任务队列**：Promise、MutationObserver等
3. **宏任务队列**：setTimeout、setInterval、I/O等
4. **渲染步骤**：在宏任务之间执行UI渲染

**执行顺序：**
同步代码 → 微任务 → 渲染 → 宏任务 → 微任务 → ...

### 10. 浏览器渲染的流程

1. **解析HTML**：构建DOM树
2. **解析CSS**：构建CSSOM树
3. **构建渲染树**：结合DOM和CSSOM
4. **布局**：计算元素位置和大小（回流）
5. **绘制**：将像素绘制到屏幕上（重绘）
6. **合成**：层合并显示

### 11. 改变字体大小会导致回流吗？

**会**。改变字体大小会影响：
- 文本所在元素的高度和宽度
- 可能影响兄弟元素和父元素的布局
- 导致整个或部分页面重新布局（回流）

**优化建议**：尽量在页面加载时确定字体大小，避免运行时频繁修改。

### 12. setTimeout不精确的原因有哪些？

1. **最小延迟限制**：浏览器有最小超时时间（通常4ms）
2. **事件循环阻塞**：前面有长时间运行的同步代码
3. **标签页休眠**：非激活标签页的定时器被节流
4. **系统负载**：CPU繁忙导致延迟执行
5. **嵌套超时**：嵌套setTimeout有最小延迟限制

### 13. 浏览器垃圾回收机制

**标记清除法**：
- 标记所有从根对象可达的对象
- 清除未被标记的对象
- 整理内存碎片

**缺点**：
- 内存碎片化
- 全堆扫描性能开销大
- 可能造成页面卡顿

**分代回收原因**：
- **新生代**：对象生命周期短，频繁回收，使用Scavenge算法
- **老生代**：对象生命周期长，较少回收，使用标记清除/整理
- 提高回收效率，减少停顿时间

### 14. 渲染过程中遇到script怎么处理

1. **同步script**：暂停HTML解析，下载并执行脚本，完成后继续解析
2. **async script**：异步下载，下载完成后立即执行（可能阻塞解析）
3. **defer script**：异步下载，在DOM解析完成后按顺序执行

**最佳实践**：将script放在body底部或使用async/defer。

### 15. 可能出现DOM树没有但渲染树中有节点的情况吗

**可能**，例如：
- `display: none`的元素在DOM中但不在渲染树中
- 伪元素（::before, ::after）在渲染树中但不在DOM中
- 通过CSS生成的内容
- 某些特殊渲染上下文中的元素

### 16. 移动端适配有哪些方案？优缺点

**1. 响应式布局**
- 优点：一套代码多端适配，维护成本低
- 缺点：加载冗余代码，复杂度高

**2. REM适配**
- 优点：按比例缩放，适配简单
- 缺点：需要计算rem值，字体大小需要单独处理

**3. Viewport适配**
- 优点：直接控制视口，实现简单
- 缺点：某些Android设备兼容性问题

**4. Flex布局**
- 优点：弹性布局，适配性好
- 缺点：旧浏览器兼容性问题

**5. 媒体查询**
- 优点：精确控制不同屏幕样式
- 缺点：断点选择困难，代码冗余

**实践建议**：通常组合使用Viewport + REM + Flex布局方案。

---

这些问题的深度和广度确实反映了字节跳动对前端基础知识的重视程度。建议在准备时不仅要理解概念，还要能够结合实际开发经验进行阐述。

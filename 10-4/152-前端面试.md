好的，这是一份针对字节跳动前端一面的详细回答和代码实现。我会延续之前深入、模拟面试的风格来组织内容。

---

### **第一部分：项目与八股**

#### 1. 自我介绍 (可以介绍项目和亮点)

**回答思路：**
这是一个开场白，需要简洁、有重点地展示你的技术栈、项目经验和亮点。结构可以是：**我是谁 -> 我做过什么（技术栈+项目） -> 我的亮点/优势是什么**。

**示例：**
“面试官您好，我叫XXX，是一名前端开发工程师。我主要的技术栈是 React + TypeScript，对 Vue 也有一定了解。我最近主要参与开发了 [某个核心项目名]，这是一个面向内部运营人员的复杂数据管理平台。

在这个项目中，我主要负责前端架构和性能优化。其中几个比较有挑战性的亮点包括：
1.  **长列表渲染性能优化：** 我们有一个需要展示上万行数据的表格，我通过深入研究和实现了 **虚拟滚动** 方案，将首次渲染时间和滚动流畅度提升了10倍以上。
2.  **状态管理重构：** 将项目从传统的 Redux 重构为基于 React Context + useReducer 的轻量级方案，显著降低了代码复杂度，提升了开发效率。
3.  **构建部署优化：** 引入了 Vite 并优化了 Webpack 配置，将本地开发热启动时间从1分钟缩短到10秒内。

我对前端性能优化和工程化有浓厚的兴趣，也非常期待能加入字节跳动，在更有挑战的环境中和团队一起成长。谢谢。”

#### 2. 你在长列表优化中做了哪些具体的事情？

**回答要点：**
结合上一个问题，把“虚拟滚动”这个亮点展开说。

“我主要做了虚拟滚动的落地。具体工作包括：
- **技术选型与调研：** 对比了 `react-window` 和 `react-virtualized` 等社区方案，但由于我们的列表项高度不固定且交互复杂，最终决定基于业务自研。
- **核心算法实现：** 实现了动态计算列表项位置和可视区域的算法。关键点在于处理 **不定高项**，我采用了 **位置预估 + 渲染后测量更新** 的策略，并维护了一个位置索引缓存来快速查找。
- **性能监控与调优：** 在实现后，通过 Chrome Performance 面板和自定义指标，验证了优化效果。在万级数据下，DOM 节点数从一万多个减少到几十个，滚动 FPS 稳定在 60。
- **封装与复用：** 将虚拟滚动逻辑抽象成了一个可复用的高阶组件，方便团队其他成员在类似场景下使用。”

#### 3. 时间分片是指什么？

**回答要点：**
时间分片（Time Slicing）是另一种优化长任务（Long Task）的策略，与虚拟滚动解决的是不同维度的问题。

- **核心思想：** 将一个耗时的同步 JavaScript 任务（比如渲染大量DOM）分解成多个小块（切片），在浏览器的空闲时期分批执行，避免阻塞主线程导致页面卡顿或无响应。
- **实现技术：**
    1.  `setTimeout/setInterval`：将任务拆分后，用定时器分批执行。
    2.  `requestIdleCallback`：更现代的API，它会在浏览器空闲时期调用函数执行任务。
    3.  `Generator` 函数：利用其可暂停执行的特性，非常适合实现任务分片。
- **与虚拟滚动的区别：**
    - **虚拟滚动** 解决的是 **“渲染节点过多”** 的问题，通过减少DOM数量来优化。
    - **时间分片** 解决的是 **“单次JS执行时间过长”** 的问题，通过将大任务拆散来避免阻塞。

#### 4. 虚拟列表是什么，为什么需要它，原理是什么？

这个问题与美团面试题高度重合，可以简要清晰地回答。

- **是什么/为什么需要：** 虚拟列表是一种只渲染可视区域内列表项的技术。对于成百上千条数据的列表，如果全部渲染，会导致DOM节点过多，引发严重的性能问题，如白屏时间长、滚动卡顿、内存占用高等。虚拟列表就是为了解决这个问题。
- **原理：**
    1.  **容器与占位：** 外层容器有固定高度和 `overflow: auto`，并设置一个具有总列表高度（`总项数 * 预估项高`）的内层占位元素，以生成正确的滚动条。
    2.  **计算可视区域：** 监听容器滚动，根据 `scrollTop`、`容器高度` 和 `项高度`，计算出当前需要渲染的起始索引和结束索引。
    3.  **渲染与定位：** 只对 `[起始索引, 结束索引]` 区间内的数据进行渲染，并将渲染出的列表项通过 `transform: translateY(起始索引 * 项高度)` 定位到正确的位置。

#### 5. 解释一下 useEffect 的作用。

**回答要点：**
`useEffect` 是 React 函数组件中用于执行 **副作用操作** 的 Hook。

- **什么是副作用？** 任何与组件渲染结果无关的操作，如数据获取、订阅、手动修改DOM、设置定时器等。
- **执行时机：** 默认情况下，`useEffect` 的回调函数会在 **组件渲染到屏幕之后（即Commit阶段后）** 延迟执行。它不会阻塞浏览器更新屏幕。
- **依赖数组：**
    - 不提供：每次渲染后都执行。
    - 空数组 `[]`：仅在组件挂载后执行一次，常用于初始化操作。
    - 有依赖项 `[a, b]`：当依赖项 `a` 或 `b` 的值发生变化时，才会重新执行。
- **清理函数：** `useEffect` 的回调函数可以返回一个清理函数，它会在组件卸载前或执行下一次 effect 前被调用，用于取消订阅、清除定时器等，防止内存泄漏。

#### 6. 你了解 useCallback 吗？它有什么作用？

**回答要点：**
`useCallback` 是一个用于 **性能优化** 的 Hook，它返回一个记忆化（memoized）的回调函数。

- **作用：** 在组件多次渲染时，只有当其依赖项发生变化时，`useCallback` 才会返回一个新的函数实例。否则，它会返回上一次渲染时记忆的函数。
- **为什么需要它？**
    - 在JavaScript中，每次组件渲染时，其内部定义的函数都会重新创建，这意味者它们的引用地址发生了变化。
    - 当你将函数作为 prop 传递给被 `React.memo` 包裹的子组件时，或者作为其他 Hook（如 `useEffect`）的依赖项时，函数引用的变化会导致子组件不必要的重渲染或 effect 的重复执行。
    - `useCallback` 通过保持函数引用的稳定，来避免这些不必要的更新。
- **语法：** `const memoizedCallback = useCallback(() => { doSomething(a, b); }, [a, b]);`
- **注意：** 不要滥用 `useCallback`，它本身也有性能开销。只有在确有必要时（如上述场景）才使用。

#### 7. 事件委托是什么？它主要用来解决什么问题？

**回答要点：**
事件委托（Event Delegation）是利用 **事件冒泡** 机制，将子元素的事件监听器统一设置在父元素上的一种技术。

- **原理：** 当子元素的事件被触发时，事件会冒泡到父元素。父元素上绑定的事件监听器通过 `event.target` 属性来判断是哪个子元素触发的事件，并执行相应的处理逻辑。
- **解决的问题：**
    1.  **性能优化：** 只需要在父元素上设置一个事件监听器，而不是为每个子元素都设置，节省了内存。
    2.  **动态元素：** 对于后续动态添加的子元素，无需再为其绑定事件，事件委托会自动生效。
    3.  **代码简洁：** 减少了重复的事件绑定代码。

**示例：**
```javascript
// 传统方式：为每个 li 绑定点击事件
// document.querySelectorAll('li').forEach(li => {
//   li.addEventListener('click', handleClick);
// });

// 事件委托：只需在 ul 上绑定一次
document.getElementById('myList').addEventListener('click', function(event) {
  if (event.target && event.target.nodeName === 'LI') {
    // 处理 li 的点击逻辑
    console.log('You clicked on li: ' + event.target.id);
  }
});
```

#### 8. 对定时器(setTimeout)有了解吗？如何用它实现一个每秒执行一次的任务？

**回答要点：**
`setTimeout` 用于在指定的毫秒数后执行一次代码。

**实现每秒执行一次：**
```javascript
function repeatEverySecond() {
  setTimeout(() => {
    console.log('This runs every second!');
    // 在本次任务执行完后，再设置下一个定时器，形成循环
    repeatEverySecond();
  }, 1000);
}
repeatEverySecond();
```
或者更常见的用法是 `setInterval`:
```javascript
const intervalId = setInterval(() => {
  console.log('This runs every second!');
}, 1000);

// 在需要的时候清除定时器
// clearInterval(intervalId);
```

#### 9. 如何让定时器的时间尽可能精确？

**回答要点：**
`setTimeout/setInterval` 本身存在 **时间漂移**，因为它们只是将任务推入任务队列，如果此时主线程被占用，任务就需要等待，导致执行时间不精确。

**提高精度的方法：**
1.  **基于系统时间动态校准：** 不依赖固定的 `1000ms` 间隔，而是每次执行时计算与上一次执行的实际时间差，并动态调整下一次的等待时间。
    ```javascript
    let expected = Date.now() + 1000;
    function drifTolerantRepeat() {
      const drift = Date.now() - expected; // 计算时间漂移
      console.log('This runs at corrected time! Drift was: ' + drift + 'ms');

      // 处理任务...

      expected += 1000; // 更新下一次期望的执行时间点
      // 动态设置下一次定时器，减去本次的漂移量，让下一次执行尽量准时
      setTimeout(drifTolerantRepeat, 1000 - drift);
    }
    setTimeout(drifTolerantRepeat, 1000);
    ```
2.  **使用 `requestAnimationFrame`：** 对于需要与屏幕刷新率同步的动画，这是最佳选择，但它不是严格的时间间隔。
3.  **Web Worker：** 将定时逻辑放在 Worker 线程中，不受主线程繁忙的影响，可以产生更稳定的间隔。但对于简单任务来说成本较高。

---

### **第二部分：代码题**

#### 10. 手写一个自定义 Hook：useFetch

**要求：** 使用 `.then` 和 `.catch` 处理 Promise。

```javascript
import { useState, useEffect } from 'react';

function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    setLoading(true);
    setError(null); // 重置错误状态

    fetch(url)
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(fetchedData => {
        setData(fetchedData);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [url]); // 依赖 url，当 url 变化时重新执行

  return { data, loading, error };
}

// 使用示例
// function MyComponent() {
//   const { data, loading, error } = useFetch('https://api.example.com/data');
//   // ... 根据状态渲染 UI
// }
```

#### 11. 在 useFetch 基础上，增加新需求：当请求参数 (params) 变化时，自动重新请求。

**思路：** 将 `params` 作为一个依赖项传入 `useEffect`。通常我们会把 `params` 序列化（如 `JSON.stringify`）以确保依赖项的稳定性，或者使用 `use-deep-compare-effect` 等库。这里简单处理，假设 `params` 是一个稳定的引用或基本类型。

```javascript
import { useState, useEffect } from 'react';

function useFetch(url, params) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    // 可选的：根据 params 生成最终的请求 URL
    const queryString = new URLSearchParams(params).toString();
    const finalUrl = queryString ? `${url}?${queryString}` : url;

    setLoading(true);
    setError(null);

    fetch(finalUrl)
      .then(response => response.json())
      .then(fetchedData => {
        setData(fetchedData);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [url, params]); // 将 params 加入依赖数组

  return { data, loading, error };
}
```

#### 12. 手写一个自定义 Hook：usePrevious

**要求：** 用于记录 state 上一次的值。

```javascript
import { useRef, useEffect } from 'react';

function usePrevious(value) {
  const ref = useRef();

  // useEffect 在渲染完成后执行，所以 ref.current 保存的是上一次渲染的值
  useEffect(() => {
    ref.current = value;
  });

  return ref.current; // 返回上一次的值
}

// 使用示例
// function MyComponent({ count }) {
//   const prevCount = usePrevious(count);
//   // 初次渲染时，prevCount 是 undefined
//   return <div>Now: {count}, before: {prevCount}</div>;
// }
```

#### 13. 在 usePrevious 基础上，增加新需求：让其值的改变也能触发UI更新。

**思路：** 原版的 `usePrevious` 返回值变化不会触发重渲染。要触发更新，我们需要将其返回值纳入组件的状态。我们可以使用 `useState` 来存储上一次的值。

```javascript
import { useState, useEffect } from 'react';

function usePreviousWithUpdate(value) {
  const [previousValue, setPreviousValue] = useState(undefined);
  const [currentValue, setCurrentValue] = useState(value);

  useEffect(() => {
    // 如果当前值发生了变化
    if (currentValue !== value) {
      // 更新“上一次的值”为“当前值”
      setPreviousValue(currentValue);
      // 更新“当前值”为新的 value
      setCurrentValue(value);
    }
    // 这个 effect 在每次渲染后都会检查 value 是否变化
  }, [value, currentValue]);

  return previousValue;
}
```
**解释：** 这个 Hook 内部维护了两个 state：`previousValue` 和 `currentValue`。当传入的 `value` 与内部的 `currentValue` 不同时，就执行一次状态更新：将 `currentValue` 赋给 `previousValue`，将新的 `value` 赋给 `currentValue`。状态的更新自然会触发组件的重渲染。

#### 14. 算法题：找出字符串中出现次数最多的字母，并对前面的数字求和。

**题目解析：** 假设字符串格式是 `"数字+字母"` 的序列，例如 `"1a2b3a4c5a"`。需要做两件事：
1.  统计每个字母出现的次数，找出出现次数最多的那个（或那些）字母。
2.  对所有 **出现在这个“最多次数字母”前面** 的数字进行求和。

**思路：**
1.  **遍历字符串：** 同时记录当前数字和字母。
2.  **统计字母频率：** 用一个 `Map` 来记录每个字母出现的次数。
3.  **记录字母与数字的映射：** 用一个数据结构（如 `Map`）记录每个字母出现时，其前面的数字是多少。因为一个字母可能出现多次，所以需要存储一个数字列表。
4.  **找出最大频率：** 遍历频率 `Map`，找到最大的频率值。
5.  **找出所有出现次数最多的字母：** 再次遍历频率 `Map`，收集所有频率等于最大频率的字母。
6.  **求和：** 遍历这些“冠军字母”，从步骤3的映射中取出它们对应的所有数字，进行求和。

**代码实现：**
```javascript
function findMaxCharAndSum(str) {
  // 用于记录每个字母的频率
  const freqMap = new Map();
  // 用于记录每个字母对应的所有前面的数字
  const charToNumbersMap = new Map();

  let i = 0;
  const n = str.length;

  // 1. 遍历字符串，解析并记录数据
  while (i < n) {
    // 解析数字部分
    let numStr = '';
    while (i < n && !isNaN(parseInt(str[i]))) {
      numStr += str[i];
      i++;
    }
    // 解析字母部分
    if (i < n) {
      const char = str[i];
      const num = parseInt(numStr) || 0; // 如果数字为空，则视为0

      // 更新频率
      freqMap.set(char, (freqMap.get(char) || 0) + 1);
      // 记录该字母对应的数字
      if (!charToNumbersMap.has(char)) {
        charToNumbersMap.set(char, []);
      }
      charToNumbersMap.get(char).push(num);

      i++; // 移动到下一个字符
    }
  }

  // 2. 找出最大频率
  let maxFreq = 0;
  for (const freq of freqMap.values()) {
    if (freq > maxFreq) {
      maxFreq = freq;
    }
  }

  // 3. 找出所有出现次数等于最大频率的字母
  const maxChars = [];
  for (const [char, freq] of freqMap) {
    if (freq === maxFreq) {
      maxChars.push(char);
    }
  }

  // 4. 对这些字母对应的所有数字求和
  let totalSum = 0;
  for (const char of maxChars) {
    const numbers = charToNumbersMap.get(char);
    totalSum += numbers.reduce((sum, num) => sum + num, 0);
  }

  return {
    mostFrequentChars: maxChars,
    totalSum: totalSum
  };
}

// 测试
const testStr = "1a2b3a4c5a10b";
const result = findMaxCharAndSum(testStr);
console.log(result);
// 输出: { mostFrequentChars: ['a', 'b'], totalSum: (1+3+5) + (2+10) = 9 + 12 = 21 }
// 解释： 'a' 出现3次，数字和为 1+3+5=9。'b' 出现2次，数字和为 2+10=12。总共和为 21。
```

这份回答涵盖了从项目经验到基础八股，再到高阶Hook手写和中等算法题的完整解决方案，希望能帮助你应对字节跳动的高标准面试。

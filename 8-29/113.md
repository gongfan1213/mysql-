### 美团后端面经（业务研发平台）

#### 手撕代码题

**1. 最小k个数**  
**要求**：不能使用 `Arrays.sort()`，需要手写实现。

**解决方案**（快速选择算法）：
```java
public int[] getLeastNumbers(int[] arr, int k) {
    if (k == 0 || arr.length == 0) return new int[0];
    // 快速选择，找到第k小的数，左侧就是最小的k个数
    return quickSelect(arr, 0, arr.length - 1, k);
}

private int[] quickSelect(int[] arr, int left, int right, int k) {
    int pivotIndex = partition(arr, left, right);
    if (pivotIndex == k - 1) {
        return Arrays.copyOf(arr, k);
    } else if (pivotIndex < k - 1) {
        return quickSelect(arr, pivotIndex + 1, right, k);
    } else {
        return quickSelect(arr, left, pivotIndex - 1, k);
    }
}

private int partition(int[] arr, int left, int right) {
    int pivot = arr[left];
    int i = left, j = right;
    while (i < j) {
        while (i < j && arr[j] >= pivot) j--;
        arr[i] = arr[j];
        while (i < j && arr[i] <= pivot) i++;
        arr[j] = arr[i];
    }
    arr[i] = pivot;
    return i;
}
```

**2. 合并有序数组**（力扣88题）  
**解决方案**：
```java
public void merge(int[] nums1, int m, int[] nums2, int n) {
    int i = m - 1, j = n - 1, k = m + n - 1;
    while (i >= 0 && j >= 0) {
        if (nums1[i] > nums2[j]) {
            nums1[k--] = nums1[i--];
        } else {
            nums1[k--] = nums2[j--];
        }
    }
    while (j >= 0) {
        nums1[k--] = nums2[j--];
    }
}
```

---

#### 八股文深度问题

**1. 深浅拷贝了解吗？怎么实现深拷贝？多说几种方法**

**深拷贝实现方式**：
- **手动拷贝**：逐层递归复制所有引用类型字段
- **序列化/反序列化**：通过ObjectOutputStream和ObjectInputStream
- **Cloneable接口**：重写clone()方法并实现深拷贝逻辑
- **第三方工具**：Apache Commons Lang的SerializationUtils、JSON序列化等

**为什么序列化反序列化是深拷贝**：
序列化将对象转换为字节流，反序列化时重新创建全新的对象图，所有引用关系都是新建的，实现了完全的深拷贝。

**Swift反序列化**：
Swift中通过Codable协议实现序列化，类似Java的Serializable。使用JSONEncoder/JSONDecoder或PropertyListEncoder/PropertyListDecoder进行序列化反序列化操作。

**2. CAS在MySQL中的应用（不是乐观锁），MySQL源码中哪些地方用了CAS？MVCC哪里用到了CAS？**

**MySQL中CAS的应用**：
- **InnoDB缓冲池管理**：页面替换算法中的引用计数更新
- **事务ID分配**：全局事务ID的原子性递增分配
- **undo log管理**：undo页面的分配和回收的并发控制
- **自适应哈希索引**：AHI的并发更新操作

**MVCC中CAS的应用**：
- **Read View创建**：事务开始时创建Read View，使用CAS保证事务ID分配的原子性
- **trx_sys->max_trx_id**：全局最大事务ID的更新使用CAS操作
- **undo page指针**：undo链表的维护使用CAS保证并发安全

**3. Redis的GEO结构底层原理**

**GEO底层实现**：
- **基于Sorted Set**：GEO使用有序集合存储地理位置数据
- **GeoHash编码**：将二维经纬度编码为一维字符串
- **52位整数表示**：GeoHash值作为score，成员名作为value
- **附近的人实现**：通过GeoHash的前缀匹配快速查找相邻区域

**GeoHash原理**：
- 将地球划分为网格，每个网格用二进制编码
- 经度和纬度交替编码，奇数位经度，偶数位纬度
- 编码长度决定精度，8位编码约±19米精度

---

#### 项目相关问题

**1. DDD实践问题：订单服务写在交易域里不符合DDD**

**DDD正确实践**：
- **领域划分**：订单应该属于"订单域"，交易属于"交易域"
- **界限上下文**：订单管理和交易支付是不同的界限上下文
- **领域服务**：订单服务应专注于订单生命周期管理
- **领域事件**：通过领域事件进行跨域通信（如OrderCreated事件触发交易）

**改进方案**：
```java
// 正确的领域划分
@DomainService
public class OrderApplicationService {
    // 订单域业务逻辑
}

@DomainService  
public class TradeApplicationService {
    // 交易域业务逻辑
}

// 通过领域事件解耦
public class OrderCreatedEvent {
    private OrderId orderId;
    private BigDecimal amount;
    // 事件触发交易流程
}
```

**2. 说说最难最有挑战的一个流程**

**示例回答**（分布式事务场景）：
"最有挑战的是分布式订单支付流程，涉及多个微服务的数据一致性。我们最初使用本地事务，但遇到跨服务数据不一致问题。

**挑战**：
- 订单服务、库存服务、支付服务的原子性操作
- 网络超时和部分失败的回滚处理
- 高并发下的性能与一致性平衡

**解决方案**：
1. **Saga模式**：将分布式事务拆分为多个可补偿的本地事务
2. **事务协调器**：使用Seata框架管理全局事务状态
3. **幂等性设计**：通过业务唯一键保证重试的安全性
4. **异步补偿**：失败时自动触发补偿操作回滚数据

**技术细节**：
- 订单状态机管理订单生命周期
- 消息队列确保最终一致性
- 分布式锁控制并发操作

这个方案将事务成功率从92%提升到99.8%，同时保证了系统的高可用性。"

---

以上回答展示了扎实的技术功底和项目实践经验，符合美团业务研发平台的技术要求。

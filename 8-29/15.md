非常棒的面试经历记录！这些问题覆盖了Java后端开发的核心知识点，很有代表性。下面我为你整理一份详细的解答，不仅包含问题答案，还会延伸出面试官可能期望的深度和广度。

---

### 📝 根据简历的项目经验

面试官通常会从你最熟悉的项目开始，逐步深入。你需要准备好：
1.  **项目介绍**：用1-2分钟清晰描述项目背景、你的角色、技术栈和核心职责。
2.  **深度挖掘**：针对你提到的技术点（如“我用了Redis做缓存”），准备好后续问题（缓存策略、雪崩/穿透/击穿解决方案、数据一致性等）。
3.  **难点与解决**：准备一个项目中遇到的具体技术难题，你是如何分析和解决的。这能极大体现你的能力。
4.  **总结与思考**：项目有何可优化之处？如果重来做会有什么不同？

---

### ⚙️ Java核心基础

#### **1. ArrayList和HashMap扩容机制**

-   **ArrayList**：
    -   初始容量：**10**（在JDK 8中，是第一次添加元素时才初始化为10的数组）
    -   扩容机制：当元素数量超过当前数组长度时，触发扩容。**新容量 = 旧容量 * 1.5**（即`int newCapacity = oldCapacity + (oldCapacity >> 1)`）。
    -   注意：扩容涉及数组拷贝，代价较高。若能预估数据量，最好通过构造函数`new ArrayList(int initialCapacity)`指定初始大小。

-   **HashMap** (JDK 8)：
    -   初始容量：**16**
    -   负载因子(Load Factor)：默认**0.75**（权衡时间与空间开销）
    -   扩容机制：当`元素数量 > 容量 * 负载因子`时，触发扩容。**新容量 = 旧容量 * 2**，并重新计算所有元素的位置（rehash）。
    -   **JDK 8优化**：当链表长度 >= 8 且 数组长度 >= 64 时，链表会转化为红黑树，以提高查询效率（O(n) -> O(log n)）。当红黑树节点数 <= 6 时，会退化为链表。

#### **2. Java并发容器和锁**

-   **并发容器** (位于`java.util.concurrent`包)：
    -   `ConcurrentHashMap`：线程安全的HashMap。**JDK 8之前采用分段锁**，JDK 8及之后改为**CAS + synchronized**锁单个链表头/树根节点，大幅提升并发度。
    -   `CopyOnWriteArrayList`：写时复制。读操作无锁，写操作会复制一个新数组，在新数组上修改，再替换引用。**适合读多写极少**的场景。
    -   `ConcurrentLinkedQueue`：基于CAS实现的无界非阻塞线程安全队列。
    -   `BlockingQueue`接口：阻塞队列，是实现生产者消费者模型的利器。常用实现类有`ArrayBlockingQueue`（有界）、`LinkedBlockingQueue`（可选有界/无界）。

-   **锁**：
    -   `synchronized`：关键字，JVM级别内置锁。经过优化（偏向锁->轻量级锁->重量级锁）后，性能已大幅提升。
    -   `ReentrantLock`：API级别的可重入锁。相比`synchronized`，功能更丰富：
        -   **可尝试获取锁** (`tryLock()`)
        -   **可中断** (`lockInterruptibly()`)
        -   **可设置公平/非公平**（默认非公平）
        -   **可绑定多个条件变量** (`Condition`)

---

### 🗑️ JVM与GC

#### **3. JVM参数设置 --- 堆内存和垃圾回收器**

-   **堆内存参数**：
    -   `-Xms`：堆区**起始**内存（如`-Xms4g`）
    -   `-Xmx`：堆区**最大**内存（如`-Xmx4g`）**通常设置`-Xms`和`-Xmx`相等，避免扩容带来的性能损耗**。
    -   `-Xmn`：**新生代**大小（如`-Xmn2g`）。老年代大小 = `-Xmx` - `-Xmn`。
    -   `-XX:MetaspaceSize` / `-XX:MaxMetaspaceSize`：元空间（方法区）初始和最大大小。

-   **垃圾回收器**：
    -   **串行** (`-XX:+UseSerialGC`)：单线程，适合客户端小应用。
    -   **并行** (`-XX:+UseParallelGC`)：多线程GC，注重**吞吐量**（JDK 8默认）。
    -   **CMS** (`-XX:+UseConcMarkSweepGC`)：并发标记清除，注重**低延迟**。已 deprecated。
    -   **G1** (`-XX:+UseG1GC`)：面向服务端，兼顾吞吐量和延迟，是**JDK 9+的默认GC**。将堆划分为多个Region，优先回收价值最大的Region。
    -   **ZGC** / **Shenandoah**：新一代超低延迟GC，适用于超大堆内存。

#### **4. 如果新生代的垃圾回收一直清不到0，怎么解决？**

这个问题指向**内存泄漏(Memory Leak)** 或**强引用无法被释放**。
1.  **现象**：频繁发生Minor GC，但每次回收后新生代仍有大量对象存活，导致这些对象被过早地提升(Promote)到老年代，最终可能引发**Full GC**。
2.  **排查工具**：使用`jmap -histo:live <pid>`查看对象实例数，或使用`jvisualvm`, `MAT`分析堆转储文件(`jmap -dump:format=b,file=heap.hprof <pid>`)。
3.  **常见原因与解决**：
    -   **静态集合类**：静态的`Map`, `List`等缓存了对象引用。需要检查缓存策略，设置过期时间或使用弱引用(WeakReference)。
    -   **连接未关闭**：数据库连接、网络连接、文件流等未显式关闭。使用`try-with-resources`语法确保关闭。
    -   **监听器未移除**：注册了事件监听器但对象销毁时未取消注册。
    -   **线程局部变量(ThreadLocal)`使用不当**：`ThreadLocal`用完未调用`remove()`方法，尤其在线程池中，线程是复用的，会导致旧引用一直存在。

#### **5. Full GC & 垃圾回收机制**

-   **触发Full GC的条件**：
    1.  **老年代空间不足**（最常见）。
    2.  **方法区（元空间）空间不足**。
    3.  **调用`System.gc()`**（建议JVM执行，但不保证执行）。
    4.  **GC晋升担保失败**：Minor GC前，如果老年代剩余空间 < 历代晋升到老年代对象的平均大小，则会触发Full GC（这是一种悲观策略）。

-   **垃圾回收机制**：
    -   **分代收集**：JVM将堆分为新生代和老年代。
    -   **新生代 (Young Generation)**：
        -   区域：Eden、Survivor0 (S0/From)、Survivor1 (S1/To)。
        -   过程：对象先在Eden分配 -> Minor GC后存活对象移到S0 -> 下次GC，Eden和S0存活对象移到S1 -> 如此反复(S0和S1角色互换)。对象每熬过一次GC年龄+1，达到阈值(默认15)则晋升到老年代。
        -   算法：**复制算法**。
    -   **老年代 (Old Generation)**：
        -   存放长时间存活的对象。
        -   算法：**标记-清除**或**标记-整理**算法。

---

### 📦 Spring框架

#### **6. IOC & Bean生命周期**

-   **IoC (控制反转)**：将对象的创建、依赖注入、生命周期的管理权交给Spring容器。**DI (依赖注入)** 是IoC的一种实现方式。**好处是解耦**。

-   **Bean的生命周期**（简化版）：
    1.  **实例化**：通过反射调用构造函数创建Bean实例。
    2.  **属性填充**：为Bean的属性注入值（`populateBean`）。
    3.  **BeanPostProcessor前置处理**：调用`postProcessBeforeInitialization`方法。
    4.  **初始化**：
        -   如果实现了`InitializingBean`接口，调用`afterPropertiesSet()`方法。
        -   调用自定义的`init-method`方法。
    5.  **BeanPostProcessor后置处理**：调用`postProcessAfterInitialization`方法（**AOP代理对象就在此阶段生成**）。
    6.  **Bean就绪**：存在于容器中，可供使用。
    7.  **销毁**：
        -   容器关闭时，如果实现了`DisposableBean`接口，调用`destroy()`方法。
        -   调用自定义的`destroy-method`方法。

---

### 🗃️ MySQL

#### **7. MySQL索引的注意事项、事务**

-   **索引注意事项**：
    -   **最左前缀原则**：联合索引`(a, b, c)`，查询条件必须包含`a`才能生效。`a`, `a,b`, `a,b,c`都会走索引，但`b,c`就不会。
    -   **避免在索引列上做计算、函数、类型转换**操作，会导致索引失效。
    -   **使用覆盖索引**：查询的字段都在索引中，避免回表。
    -   **索引不是越多越好**：索引会占用空间，降低写操作（INSERT/UPDATE/DELETE）速度。

-   **事务 (ACID)**：
    -   **A (原子性)**：Undo Log实现。
    -   **C (一致性)**：是最终目标，由其他三大特性保证。
    -   **I (隔离性)**：锁 + MVCC实现。
    -   **D (持久性)**：Redo Log实现。

#### **8. MVCC、当前读和快照读**

-   **MVCC (多版本并发控制)**：InnoDB实现高并发的重要机制。通过在每行记录后保存数据的多个版本来实现**非阻塞读**。
    -   实现依赖：**隐藏字段（事务ID、回滚指针）**、**Undo Log**、**ReadView**。
-   **快照读**：普通的`SELECT`语句（不加锁），读取的是记录的历史版本（可能是之前的某个快照），从而实现**可重复读**。**基于MVCC**。
-   **当前读**：读取的是记录的最新版本，并且会**加锁**，保证其他事务不能并发修改这条记录。
    -   `SELECT ... FOR UPDATE`
    -   `SELECT ... LOCK IN SHARE MODE`
    -   `INSERT`, `UPDATE`, `DELETE`

---

### 🎯 Redis & RocketMQ

#### **9. Redis数据结构 & 使用场景**

| 数据结构 | 特点 | 常用场景 |
| :--- | :--- | :--- |
| **String** | 最简单的K-V | 缓存、计数器、分布式锁 |
| **Hash** |  field-value映射表 | 存储对象（用户信息等） |
| **List** | 有序、可重复 | 消息队列、最新列表、朋友圈 |
| **Set** | 无序、不可重复 | 点赞、抽奖、共同关注 |
| **ZSet** | 有序、不可重复 | 排行榜、带权重的消息队列 |
| **Bitmap** | 位图 | 用户签到、活跃度统计 |
| **HyperLogLog** | 基数统计 | UV统计（有误差） |

#### **10. RocketMQ与Kafka & 主要部分 & 消息重试 & 消费模式 & 幂等 & 有序**

-   **RocketMQ vs Kafka**：
    -   **语言**：RocketMQ (Java)，Kafka (Scala/Java)。
    -   **性能**：Kafka吞吐量极高，为大数据领域而生；RocketMQ吞吐量也很高，但更侧重**金融级的稳定性和低延迟**。
    -   **功能**：RocketMQ功能更丰富，如**延迟消息、消息轨迹、事务消息**等。

-   **RocketMQ主要部分**：
    -   **Producer**：消息生产者。
    -   **Consumer**：消息消费者。
    -   **Broker**：消息中转角色，存储和转发消息。
    -   **NameServer**：无状态注册中心，管理Broker的路由信息。

-   **消息重试**：
    -   **顺序消息**：失败后不断重试，直到成功。
    -   **无序消息**：消费失败后，消息会进入**重试队列**，延迟一段时间后再投递。默认最多重试16次。

-   **消费模式**：
    -   **集群模式 (CLUSTERING)**：一条消息只能被同一个消费者组中的一个消费者消费。**默认模式**。
    -   **广播模式 (BROADCASTING)**：一条消息会被同一个消费者组中的所有消费者消费。

-   **消费者如何保证幂等**：**业务自己实现**。常用方案：
    1.  **唯一业务ID**：为消息设置唯一Key（如订单ID）。
    2.  **状态判断**：在处理前，先查数据库判断该业务是否已处理过。
    3.  **数据库唯一键/乐观锁**：利用数据库约束防止重复更新。

-   **RocketMQ消息有序吗？**
    -   **全局有序**：代价大（只能一个Topic一个Queue），一般不使用。
    -   **分区有序**：**默认保证分区有序**。将需要保证顺序的一类消息（如同一个订单ID的消息）**发送到同一个MessageQueue**。同一个Consumer Group内，同一个Queue只会被一个Consumer消费，从而保证了顺序处理。

---

### 🌐 网络与Linux

#### **11. HTTP状态码**

| 状态码 | 含义 | 问题环节 |
| :--- | :--- | :--- |
| **1xx** | 信息性 | - |
| **2xx** | 成功 | - |
| **3xx** | 重定向 | 客户端需跟进（如缓存、跳转） |
| **4xx** | **客户端错误** | **请求语法、权限、认证等问题**（前端/客户端问题） |
| **5xx** | **服务器错误** | **服务器内部错误**（后端问题，如代码Bug、依赖服务挂掉、服务器过载） |

#### **12. TCP三次握手和四次挥手 & 为什么挥手是四次？**

-   **三次握手** (建立连接)：
    1.  Client -> Server: `SYN=1, seq=x`
    2.  Server -> Client: `SYN=1, ACK=1, ack=x+1, seq=y`
    3.  Client -> Server: `ACK=1, ack=y+1`
    -   **目的**：确认双方的发送和接收能力都正常。

-   **四次挥手** (断开连接)：
    1.  A -> B: `FIN=1, seq=u` (A说我没数据发了)
    2.  B -> A: `ACK=1, ack=u+1` (B说我知道了)
    3.  ...(B可能还有数据要发送)...
    4.  B -> A: `FIN=1, ACK=1, seq=v, ack=u+1` (B说我也没数据发了)
    5.  A -> B: `ACK=1, ack=v+1` (A说我知道了)
    -   **为什么是四次？**：因为TCP连接是**全双工**的。一方发送`FIN`只表示它不再发送数据，但还可以接收数据。所以挥手需要两边分别关闭，中间可能还存在数据传送。

#### **13. Linux命令**

-   `tail -f filename | grep "keyword"`：**实时**追踪文件末尾的新增内容，并过滤出含有关键字的行。**非常适合查看正在滚动的日志**。
-   `ps`：查看进程状态。
    -   `ps -aux`：查看所有用户的详细进程信息。
    -   `ps -ef`：以完整格式列表显示所有进程。
    -   `ps -ef | grep java`：查找所有Java进程。

---

希望这份详细的总结能帮助你更好地复盘和准备下一次面试！祝你求职顺利！

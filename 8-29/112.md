### 美团技术面经

#### 1. 慢 SQL 怎么排查和优化？
**排查步骤：**
- 使用 `EXPLAIN` 或 `EXPLAIN ANALYZE` 分析执行计划
- 查看扫描类型（全表扫描、索引扫描等）
- 检查索引使用情况、排序和临时表创建
- 监控慢查询日志（slow query log）
- 使用性能分析工具（如Percona Toolkit）

**优化方法：**
- 添加合适的索引（覆盖索引、复合索引）
- 优化SQL语句（避免SELECT *，减少子查询）
- 避免全表扫描，减少JOIN的复杂度
- 调整数据库配置参数（缓冲区大小、连接数等）
- 考虑分库分表或读写分离

#### 2. 哪些情况会导致索引失效？怎么解决？
**索引失效的情况：**
- 对索引列进行函数操作（如 `WHERE YEAR(create_time) = 2023`）
- 使用不等号（!=, <>）或 `NOT IN`
- 索引列参与计算（如 `WHERE id + 1 = 5`）
- 模糊查询以通配符开头（如 `LIKE '%abc'`）
- 数据类型隐式转换（如字符串列用数字查询）
- 复合索引未遵循最左前缀原则

**解决方案：**
- 避免对索引列进行函数计算或转换
- 调整查询条件顺序以满足最左前缀原则
- 使用覆盖索引减少回表查询
- 考虑使用全文索引替代模糊查询

#### 3. Runnable 和 Callable 有什么区别？
| 特性 | Runnable | Callable |
|------|----------|----------|
| **返回值** | 无返回值（void） | 有返回值（泛型类型） |
| **异常处理** | 不能抛出受检异常 | 可以抛出受检异常 |
| **使用场景** | 简单的异步任务 | 需要返回结果的任务 |
| **提交方式** | `execute(Runnable)` | `submit(Callable)` |

#### 4. 讲讲线程池的工作原理，核心参数有哪些？
**工作原理：**
1. 提交任务时，先检查核心线程数是否已满
2. 未满则创建新线程执行，已满则加入工作队列
3. 队列满且线程数未达最大值时创建新线程
4. 队列满且线程数达最大值时执行拒绝策略

**核心参数：**
- `corePoolSize`：核心线程数
- `maximumPoolSize`：最大线程数
- `keepAliveTime`：非核心线程空闲存活时间
- `workQueue`：任务队列（ArrayBlockingQueue等）
- `threadFactory`：线程工厂
- `rejectedExecutionHandler`：拒绝策略

#### 5. 单例模式有几种写法？
**常见写法：**
1. **饿汉式**：类加载时初始化，线程安全但可能浪费资源
2. **懒汉式**：需要时创建，需加锁保证线程安全
3. **双重检查锁**：减少锁粒度，提高性能
4. **静态内部类**：利用类加载机制保证懒加载和线程安全
5. **枚举单例**：Effective Java推荐，防止反射攻击

#### 6. 策略模式用过吗？举个例子说说。
**策略模式**定义一系列算法，使其可相互替换。

**例子：支付策略**
```java
interface PaymentStrategy {
    void pay(int amount);
}

class AlipayStrategy implements PaymentStrategy {
    public void pay(int amount) { /* 支付宝支付逻辑 */ }
}

class WechatPayStrategy implements PaymentStrategy {
    public void pay(int amount) { /* 微信支付逻辑 */ }
}

class PaymentContext {
    private PaymentStrategy strategy;
    public void setStrategy(PaymentStrategy strategy) { this.strategy = strategy; }
    public void executePay(int amount) { strategy.pay(amount); }
}
```

#### 7. HashMap 什么时候会扩容？
- 当元素数量超过阈值（容量 × 负载因子，默认0.75）时扩容
- 例如默认容量16，当size > 12时触发扩容
- 扩容后容量变为原来的2倍，重新计算所有元素的哈希位置

#### 8. HashMap 为什么要自己实现 hash 算法，不直接用 hashCode？
- **减少哈希冲突**：通过扰动函数（高16位异或低16位）使哈希分布更均匀
- **提高散列性**：原始hashCode可能分布不均，导致链表过长
- **性能优化**：自定义hash算法能更好适应HashMap的内部结构

#### 9. 想存 100 个 key，HashMap 初始化大小设为多少比较好？
- 考虑负载因子0.75，计算：100 / 0.75 ≈ 133.33
- 取最近的2的幂次方：128（但133 > 128，会提前扩容）
- 选择256确保足够空间，避免频繁扩容
- **推荐**：`new HashMap<>(256)` 或 `new HashMap<>(100, 0.75f)`

#### 10. 讲讲 CMS 垃圾收集器的工作过程。
**CMS（Concurrent Mark Sweep）工作流程：**
1. **初始标记**：Stop-The-World，标记GC Roots直接关联对象
2. **并发标记**：与用户线程并发，标记所有可达对象
3. **重新标记**：Stop-The-World，修正并发标记期间的变化
4. **并发清除**：与用户线程并发，清理垃圾对象

#### 11. 了解 Stop-The-World 吗？什么场景下会触发？
**Stop-The-World**：暂停所有用户线程，进行垃圾回收。

**触发场景：**
- Young GC / Full GC 的某些阶段
- 垃圾收集器的安全点操作
- CMS的初始标记和重新标记阶段
- G1的初始标记和最终标记阶段

#### 12. 哪些对象可以作为 GC Roots？
- 虚拟机栈中引用的对象（局部变量）
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中JNI引用的对象
- 被同步锁持有的对象
- Java虚拟机内部引用（如基本类型对应的Class对象）

#### 13. 核心代码模式算法题：字符串变形

**题目描述**：将字符串中单词顺序反转，并调整大小写。

**示例**：
```
输入："Hello World Java"
输出："JAVA wORLD hELLO"
```

**解决方案**：
```java
public String transform(String s) {
    if (s == null || s.length() == 0) return s;
    
    // 分割单词
    String[] words = s.split(" ");
    StringBuilder sb = new StringBuilder();
    
    // 从后往前遍历，反转单词顺序
    for (int i = words.length - 1; i >= 0; i--) {
        String word = words[i];
        // 大小写转换
        char[] chars = word.toCharArray();
        for (int j = 0; j < chars.length; j++) {
            if (Character.isUpperCase(chars[j])) {
                chars[j] = Character.toLowerCase(chars[j]);
            } else {
                chars[j] = Character.toUpperCase(chars[j]);
            }
        }
        sb.append(new String(chars));
        if (i > 0) sb.append(" ");
    }
    
    return sb.toString();
}
```

---

以上是对美团技术面经的详细解答，涵盖了数据库、并发编程、设计模式、JVM等多个技术领域。

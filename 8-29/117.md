### 一面问题解答

#### 1. Redis使用场景及缓存淘汰机制
**Redis使用场景**：
- 缓存热点数据、会话存储、分布式锁、消息队列、排行榜等

**缓存淘汰机制**：
- **LRU**：最近最少使用，淘汰最久未访问的key
- **LFU**：最不经常使用，淘汰访问频率最低的key  
- **TTL**：按过期时间淘汰
- **随机淘汰**：随机选择key淘汰

#### 2. 100M硬盘资源实现缓存系统
```java
public class DiskCache<K, V> {
    private final long maxSize;
    private final Map<K, String> keyToFile; // 内存索引：key->文件名
    private final Queue<K> accessQueue; // 访问顺序队列
    
    public DiskCache(long maxSizeBytes) {
        this.maxSize = maxSizeBytes;
        this.keyToFile = new HashMap<>();
        this.accessQueue = new LinkedList<>();
    }
    
    public void put(K key, V value) {
        // 检查容量，如果超限则淘汰
        while (getCurrentSize() + estimateSize(value) > maxSize) {
            evict();
        }
        
        // 序列化到文件
        String filename = serializeToFile(key, value);
        keyToFile.put(key, filename);
        accessQueue.offer(key);
    }
    
    public V get(K key) {
        if (!keyToFile.containsKey(key)) return null;
        
        // 更新访问顺序
        accessQueue.remove(key);
        accessQueue.offer(key);
        
        return deserializeFromFile(keyToFile.get(key));
    }
    
    private void evict() {
        K oldestKey = accessQueue.poll();
        if (oldestKey != null) {
            deleteFile(keyToFile.get(oldestKey));
            keyToFile.remove(oldestKey);
        }
    }
}
```

#### 3. 数据库大表处理方案
- **分库分表**：水平拆分（按范围、哈希）、垂直拆分
- **归档历史数据**：将冷数据迁移到历史表
- **索引优化**：添加合适索引，避免全表扫描
- **读写分离**：主库写，从库读
- **缓存层**：Redis缓存热点数据

#### 4. HashMap底层实现
```java
// JDK8 HashMap结构
public class HashMap<K,V> {
    transient Node<K,V>[] table; // 数组+链表/红黑树
    
    static class Node<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;
    }
    
    // 链表转红黑树的阈值
    static final int TREEIFY_THRESHOLD = 8;
}
```

#### 5. ConcurrentHashMap线程安全机制
**volatile作用**：
```java
public class ConcurrentHashMap<K,V> {
    transient volatile Node<K,V>[] table;
    
    // volatile保证：
    // 1. 可见性：修改立即可见其他线程
    // 2. 禁止指令重排序
    // 3. 不保证原子性（需要配合CAS）
    
    final V putVal(K key, V value, boolean onlyIfAbsent) {
        // 使用CAS+synchronized保证线程安全
        if ((tab = table) == null) tab = initTable();
        Node<K,V> f = tabAt(tab, i = (n - 1) & hash);
        synchronized (f) { // 锁住链表头节点
            // 插入逻辑
        }
    }
}
```

#### 6. 单例模式实现
```java
// 双重检查锁实现
public class Singleton {
    private static volatile Singleton instance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

// 静态内部类实现（推荐）
public class Singleton {
    private Singleton() {}
    
    private static class Holder {
        private static final Singleton INSTANCE = new Singleton();
    }
    
    public static Singleton getInstance() {
        return Holder.INSTANCE;
    }
}
```

#### 7. 线程池使用场景
- **CPU密集型**：核心线程数 = CPU核数
- **IO密集型**：核心线程数 = CPU核数 × 2
- **定时任务**：ScheduledThreadPoolExecutor
- **并发控制**：FixedThreadPool限制并发数

#### 8. 无重复字符的最长子串
```java
public String longestUniqueSubstring(String s) {
    if (s == null || s.length() == 0) return "";
    
    Map<Character, Integer> charIndex = new HashMap<>();
    int left = 0, maxLen = 0, start = 0;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        
        if (charIndex.containsKey(c) && charIndex.get(c) >= left) {
            left = charIndex.get(c) + 1; // 移动左指针
        }
        
        charIndex.put(c, right);
        
        if (right - left + 1 > maxLen) {
            maxLen = right - left + 1;
            start = left;
        }
    }
    
    return s.substring(start, start + maxLen);
}
```

---

### 二面问题解答

#### 1. 线程池创建实现
```java
public class ThreadPoolExample {
    public static void main(String[] args) {
        // 手动创建线程池（推荐）
        ThreadPoolExecutor executor = new ThreadPoolExecutor(
            5, // 核心线程数
            10, // 最大线程数
            60L, TimeUnit.SECONDS, // 空闲线程存活时间
            new ArrayBlockingQueue<>(100), // 工作队列
            Executors.defaultThreadFactory(), // 线程工厂
            new ThreadPoolExecutor.CallerRunsPolicy() // 拒绝策略
        );
        
        // 使用Executors工具类（不推荐生产环境）
        ExecutorService cachedPool = Executors.newCachedThreadPool();
        ExecutorService fixedPool = Executors.newFixedThreadPool(5);
    }
}
```

#### 2. Future获取结果的底层原理
```java
public class FutureTask<V> implements RunnableFuture<V> {
    private volatile int state; // 任务状态
    private Callable<V> callable; // 实际任务
    private Object outcome; // 执行结果
    
    // 核心原理：等待-通知机制
    public V get() throws InterruptedException, ExecutionException {
        int s = state;
        if (s <= COMPLETING) {
            s = awaitDone(false, 0L); // 等待任务完成
        }
        return report(s); // 返回结果
    }
    
    protected void set(V v) {
        if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {
            outcome = v; // 设置结果
            UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // 更新状态
            finishCompletion(); // 唤醒等待线程
        }
    }
}
```

**原理总结**：
- FutureTask内部维护任务状态（NEW、COMPLETING、NORMAL等）
- get()方法在任务未完成时，线程进入等待状态
- 任务完成后通过LockSupport.unpark()唤醒等待线程
- 使用CAS保证状态更新的原子性

#### 3. 线程安全的HashMap put方法实现
```java
public class ThreadSafeHashMap<K, V> {
    // 使用volatile保证数组引用的可见性
    private volatile Node<K, V>[] table;
    private final Object[] locks; // 分段锁数组
    
    public ThreadSafeHashMap(int capacity) {
        table = new Node[capacity];
        locks = new Object[capacity];
        for (int i = 0; i < locks.length; i++) {
            locks[i] = new Object();
        }
    }
    
    public V put(K key, V value) {
        int hash = hash(key);
        int index = (table.length - 1) & hash;
        
        // 分段锁：只锁住对应的桶位
        synchronized (locks[index]) {
            Node<K, V> first = table[index];
            
            // 查找是否已存在key
            for (Node<K, V> node = first; node != null; node = node.next) {
                if (node.key.equals(key)) {
                    V oldValue = node.value;
                    node.value = value;
                    return oldValue;
                }
            }
            
            // 头插法新增节点
            Node<K, V> newNode = new Node<>(hash, key, value, first);
            table[index] = newNode;
            return null;
        }
    }
    
    static class Node<K, V> {
        final int hash;
        final K key;
        volatile V value; // value用volatile保证可见性
        Node<K, V> next;
        
        Node(int hash, K key, V value, Node<K, V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
    }
    
    // 线程安全的hash算法
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
}
```

**线程安全保证**：
1. **分段锁**：每个桶位独立锁，提高并发度
2. **volatile数组**：保证table引用的可见性  
3. **volatile value**：保证值的可见性
4. **final key**：key不可变，避免并发修改

**对比ConcurrentHashMap**：
- 实际ConcurrentHashMap使用CAS+synchronized，性能更好
- JDK8后取消分段锁，改为每个桶位单独加锁
- 使用volatile和CAS实现无锁化读取

---

### 面试总结建议

**需要加强的知识点**：
1. **并发编程底层原理**：AQS、CAS、volatile内存屏障
2. **JUC源码阅读**：FutureTask、ConcurrentHashMap实现细节
3. **锁优化技术**：自旋锁、锁消除、锁粗化
4. **内存模型**：JMM、happens-before原则

**学习建议**：
- 阅读JDK源码，理解设计思想
- 使用jstack、jconsole等工具分析线程状态
- 学习Java内存模型和并发编程最佳实践
- 多做并发场景的编码练习

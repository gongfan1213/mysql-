### 拼多多服务端一二三面

#### 一面（视频面试 1小时）

**1. 项目/实习/八股文拷打**
- 深入询问简历上的技术细节和实现方案
- 确保对项目有深度理解，能够解释技术选型原因

**2. volatile变量读写时的工作内存与主内存交互流程**

```java
public class VolatileExample {
    private volatile boolean flag = false;
    
    // 写操作
    public void writer() {
        flag = true; // 1. 修改工作内存中的值
                    // 2. 立即刷新到主内存
                    // 3. 使其他线程的工作内存中该变量失效
    }
    
    // 读操作  
    public void reader() {
        while (!flag) { // 1. 发现工作内存中变量已失效
                        // 2. 从主内存重新读取最新值
            // 循环等待
        }
    }
}
```

**具体交互流程**：
- **写操作**：
  1. 修改线程工作内存中的变量副本
  2. 将修改后的值立即刷新到主内存
  3. 通过缓存一致性协议使其他CPU缓存中该变量失效

- **读操作**：
  1. 检查工作内存中变量是否有效
  2. 如果无效，从主内存重新加载最新值
  3. 保证读到的是最新修改的值

**3. 手撕代码：力扣26. 删除有序数组中的重复项**

```java
public int removeDuplicates(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    
    int slow = 0; // 慢指针，指向当前唯一元素的末尾
    for (int fast = 1; fast < nums.length; fast++) {
        // 当快指针指向的元素不等于慢指针指向的元素时
        if (nums[fast] != nums[slow]) {
            slow++; // 慢指针先移动
            nums[slow] = nums[fast]; // 将新元素赋值给慢指针位置
        }
        // 如果相等，快指针继续向后寻找不同的元素
    }
    
    return slow + 1; // 返回新数组长度
}

// 测试用例
public static void main(String[] args) {
    int[] nums = {0,0,1,1,1,2,2,3,3,4};
    int len = removeDuplicates(nums);
    // 输出: [0,1,2,3,4]
    for (int i = 0; i < len; i++) {
        System.out.print(nums[i] + " ");
    }
}
```

**算法思路**：
- 使用快慢双指针技巧
- 慢指针指向当前唯一序列的末尾
- 快指针遍历数组寻找新元素
- 时间复杂度：O(n)，空间复杂度：O(1)

---

#### 二面（视频面试 1小时）

**1. 简历深度拷打**
- 重点询问实习项目的技术难点和解决方案
- 考察对项目架构设计的理解深度

**2. 手撕阻塞队列（支持超时返回）**

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.TimeUnit;

public class TimeoutBlockingQueue<T> {
    private final Object[] items;
    private int count;
    private int putIndex;
    private int takeIndex;
    
    private final ReentrantLock lock;
    private final Condition notEmpty;
    private final Condition notFull;
    
    public TimeoutBlockingQueue(int capacity) {
        if (capacity <= 0) throw new IllegalArgumentException();
        this.items = new Object[capacity];
        this.lock = new ReentrantLock();
        this.notEmpty = lock.newCondition();
        this.notFull = lock.newCondition();
    }
    
    // 支持超时的put方法
    public boolean offer(T element, long timeout, TimeUnit unit) 
            throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            // 队列已满，等待直到有空位或超时
            while (count == items.length) {
                if (nanos <= 0) {
                    return false; // 超时返回false
                }
                nanos = notFull.awaitNanos(nanos);
            }
            enqueue(element);
            return true;
        } finally {
            lock.unlock();
        }
    }
    
    // 支持超时的take方法
    public T poll(long timeout, TimeUnit unit) throws InterruptedException {
        long nanos = unit.toNanos(timeout);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            // 队列为空，等待直到有元素或超时
            while (count == 0) {
                if (nanos <= 0) {
                    return null; // 超时返回null
                }
                nanos = notEmpty.awaitNanos(nanos);
            }
            return dequeue();
        } finally {
            lock.unlock();
        }
    }
    
    private void enqueue(T x) {
        items[putIndex] = x;
        if (++putIndex == items.length) putIndex = 0;
        count++;
        notEmpty.signal(); // 唤醒等待的消费者
    }
    
    @SuppressWarnings("unchecked")
    private T dequeue() {
        T x = (T) items[takeIndex];
        items[takeIndex] = null;
        if (++takeIndex == items.length) takeIndex = 0;
        count--;
        notFull.signal(); // 唤醒等待的生产者
        return x;
    }
    
    public int size() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return count;
        } finally {
            lock.unlock();
        }
    }
}
```

**关键特性**：
- **线程安全**：使用ReentrantLock保证并发安全
- **条件等待**：notEmpty和notFull条件变量实现精确唤醒
- **超时控制**：awaitNanos()方法支持纳秒级超时
- **环形数组**：循环使用数组空间

---

#### 三面（主管面/电话面试 15分钟）

**1. 项目难点和亮点**
- **难点**：高并发场景下的数据一致性、系统性能优化
- **亮点**：创新的技术方案、显著的业务价值提升

**2. 使用的设计模式**
```java
// 工厂模式示例
public class ConnectionFactory {
    public static Connection createConnection(String type) {
        switch (type) {
            case "MySQL": return new MySQLConnection();
            case "Redis": return new RedisConnection();
            default: throw new IllegalArgumentException();
        }
    }
}

// 观察者模式示例  
public class EventPublisher {
    private List<EventListener> listeners = new ArrayList<>();
    
    public void addListener(EventListener listener) {
        listeners.add(listener);
    }
    
    public void publishEvent(Event event) {
        for (EventListener listener : listeners) {
            listener.onEvent(event);
        }
    }
}
```

**3. IO多路复用详解**

| 方式 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **select** | 跨平台支持 | 1. 文件描述符数量限制(1024)<br>2. 线性扫描效率低<br>3. 需要复制fd集合 | 连接数少的场景 |
| **poll** | 1. 无fd数量限制<br>2. 效率稍高于select | 1. 仍需线性扫描<br>2. 大量fd时性能下降 | 中等规模连接 |
| **epoll** | 1. 事件驱动，O(1)复杂度<br>2. 无fd数量限制<br>3. 内存共享减少复制 | 仅Linux支持 | 高并发大规模连接 |

**4. 请求响应时间慢的排查方案**

**排查步骤**：
```bash
# 1. 网络链路排查
traceroute target_server.com  # 跟踪路由
ping target_server.com        # 检查网络延迟

# 2. DNS解析排查
nslookup target_server.com    # DNS解析时间
dig target_server.com         # 详细DNS查询信息

# 3. 客户端排查
浏览器开发者工具 - 网络面板  # 分析各阶段耗时

# 4. 服务端监控
top/htop                     # 服务器负载
netstat -nat | grep :80      # 连接状态
tcpdump -i any port 80       # 抓包分析
```

**传输过程具体问题**：
- **网络延迟**：物理距离、网络拥塞、路由问题
- **DNS解析慢**：DNS服务器响应慢、缓存失效
- **TCP握手慢**：SYN洪水攻击、连接数限制
- **SSL/TLS握手**：证书验证、密钥交换耗时
- **带宽限制**：网络带宽不足、流量限制
- **代理问题**：反向代理、CDN节点故障
- **数据包丢失**：网络质量差导致重传

**优化措施**：
- 使用CDN加速静态资源
- 优化TCP参数（TCP窗口大小）
- 启用HTTP/2多路复用
- 压缩传输数据
- 减少重定向链

---

这次面试涵盖了Java并发、数据结构、网络编程等核心知识点，体现了拼多多对服务端工程师全面能力的高要求。

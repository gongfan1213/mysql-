### 05.20拼多多Java后端一面分享

#### 项目提问
**1. 项目的输入输出是什么**
- **输入**：根据具体项目描述，如电商项目可能是用户请求、订单数据、支付信息等
- **输出**：处理结果，如创建订单响应、支付状态、业务数据等

**2. 项目的难点是什么**
- **技术难点**：高并发处理、数据一致性、系统扩展性等
- **业务难点**：复杂业务流程、异常处理、性能优化等

**3. 这个项目你参与了多少的开发，代码占比多少？**
- 如实回答个人贡献，如："我负责了订单模块和支付接口的开发，代码占比约30%"

#### 八股提问
**1. JVM的结构是什么**
- **类加载子系统**：加载.class文件
- **运行时数据区**：
  - 方法区（元空间）：类信息、常量、静态变量
  - 堆：对象实例
  - 虚拟机栈：方法调用、局部变量
  - 本地方法栈：Native方法
  - 程序计数器：当前线程执行的字节码行号
- **执行引擎**：解释器、JIT编译器、垃圾回收器

**2. 数据库事务的隔离性你了解吗**
- **读未提交**：可能读到未提交数据（脏读）
- **读已提交**：只能读到已提交数据（解决脏读）
- **可重复读**：同一事务内多次读取结果一致（解决不可重复读）
- **串行化**：完全隔离（解决幻读）

**3. HashMap的结构你了解吗**
- **数组+链表/红黑树**：Java 8以后的结构
- **哈希桶**：通过hash算法确定数组下标
- **链表转树**：当链表长度≥8且数组长度≥64时转为红黑树

**4. 如果HashMap出现了哈希冲突，该如何解决**
- **链表法**：同一桶位形成链表（Java HashMap采用）
- **开放地址法**：线性探测、二次探测等
- **再哈希法**：使用第二个哈希函数
- **建立公共溢出区**：冲突元素放入独立区域

**5. 死锁了解吗**
- **死锁条件**：互斥、持有并等待、不可剥夺、循环等待
- **解决方法**：
  - 破坏死锁条件
  - 锁排序、锁超时、死锁检测
  - 使用tryLock()替代lock()

**6. 垃圾回收了解吗**
- **回收算法**：标记-清除、复制、标记-整理、分代收集
- **垃圾收集器**：Serial、Parallel、CMS、G1、ZGC等
- **GC调优**：堆大小设置、选择合适的收集器

#### 场景题提问
**1. 用户登录场景，密码输错三次锁定24小时**
```java
// 数据库表设计
users_table:
- user_id (主键)
- username
- password_hash
- failed_attempts (默认0)
- is_locked (boolean, 默认false)
- lock_time (datetime, 锁定时间)
- last_failed_time (最后失败时间)

// 登录逻辑伪代码
public boolean login(String username, String password) {
    User user = userDao.findByUsername(username);
    
    // 检查是否在锁定状态
    if (user.isLocked()) {
        if (System.currentTimeMillis() - user.getLockTime() < 24 * 60 * 60 * 1000) {
            throw new AccountLockedException("账户已锁定，请24小时后重试");
        } else {
            // 解锁账户
            user.setLocked(false);
            user.setFailedAttempts(0);
        }
    }
    
    // 验证密码
    if (passwordEncoder.matches(password, user.getPasswordHash())) {
        user.setFailedAttempts(0); // 登录成功重置计数
        return true;
    } else {
        user.setFailedAttempts(user.getFailedAttempts() + 1);
        user.setLastFailedTime(System.currentTimeMillis());
        
        if (user.getFailedAttempts() >= 3) {
            user.setLocked(true);
            user.setLockTime(System.currentTimeMillis());
        }
        userDao.update(user);
        return false;
    }
}
```

**2. 两个盒子找质量相等的小球**
```java
public class BallMatcher {
    public Pair<Ball, Ball> findEqualWeightBalls(int[] blueBalls, int[] redBalls) {
        // 先对两个数组进行排序
        Arrays.sort(blueBalls);
        Arrays.sort(redBalls);
        
        // 双指针查找相同质量的球
        int i = 0, j = 0;
        while (i < blueBalls.length && j < redBalls.length) {
            if (blueBalls[i] == redBalls[j]) {
                return new Pair<>(new Ball(blueBalls[i], "blue"), 
                                new Ball(redBalls[j], "red"));
            } else if (blueBalls[i] < redBalls[j]) {
                i++;
            } else {
                j++;
            }
        }
        return null; // 没有找到质量相等的球
    }
}
```

#### 手撕环节
**1. LeetCode 740：删除并获得点数**
```java
class Solution {
    public int deleteAndEarn(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        
        // 找到数组中的最大值
        int max = 0;
        for (int num : nums) {
            max = Math.max(max, num);
        }
        
        // 构建sum数组，sum[i]表示所有i的和
        int[] sum = new int[max + 1];
        for (int num : nums) {
            sum[num] += num;
        }
        
        // 动态规划，类似打家劫舍问题
        int[] dp = new int[max + 1];
        dp[0] = sum[0];
        dp[1] = Math.max(sum[0], sum[1]);
        
        for (int i = 2; i <= max; i++) {
            dp[i] = Math.max(dp[i - 1], dp[i - 2] + sum[i]);
        }
        
        return dp[max];
    }
}
```

#### 反问环节总结
**面试官建议**：
1. **加强工程能力**：参与完整的Java项目开发
2. **项目经验**：除了科研项目，需要企业级项目经验
3. **技术深度**：深入理解常用框架和中间件的原理

**个人改进方向**：
- 学习Spring Boot、Spring Cloud等主流框架
- 参与开源项目或个人项目积累经验
- 深入学习分布式系统、数据库优化等企业级技术
- 准备更多的实际场景解决方案

这次面试涵盖了基础理论、算法能力和工程实践，反映了拼多多对后端工程师全面能力的要求。

### 美团后端实习面试题解答

#### 1. 什么场景下会考虑用 Redisson？
**适用场景**：
- 分布式锁需求：跨JVM的互斥访问控制
- 分布式集合：跨进程的Map、Set、Queue等
- 分布式限流：接口限流、秒杀控流
- 分布式信号量：资源池管理
- 发布订阅：跨服务消息通信

#### 2. 抢单系统用 Redisson 实现方案
```java
@Service
public class GrabOrderService {
    @Autowired
    private RedissonClient redisson;
    
    public boolean grabOrder(String orderId, String driverId) {
        RLock lock = redisson.getLock("ORDER_LOCK:" + orderId);
        
        try {
            // 尝试获取锁，等待3秒，锁过期时间30秒
            if (lock.tryLock(3, 30, TimeUnit.SECONDS)) {
                try {
                    // 检查订单是否已被抢
                    if (orderService.isOrderGrabbed(orderId)) {
                        return false;
                    }
                    // 执行抢单逻辑
                    return orderService.grabOrder(orderId, driverId);
                } finally {
                    lock.unlock();
                }
            }
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return false;
    }
}
```

#### 3. Redisson 看门狗机制
**工作原理**：
- 默认锁超时时间30秒，看门狗每10秒检查一次
- 如果业务未执行完，自动续期到30秒
- 防止业务执行时间超过锁超时时间导致锁提前释放

```java
// 看门狗续期源码逻辑
private void scheduleExpirationRenewal(String threadId) {
    // 每10秒执行一次续期
   Timeout task = commandExecutor.getConnectionManager()
        .newTimeout(new TimerTask() {
            public void run(Timeout timeout) {
                // 续期逻辑
                renewExpirationAsync(threadId);
            }
        }, internalLockLeaseTime / 3, TimeUnit.MILLISECONDS);
}
```

#### 4. Redis 缓存常用场景
- **热点数据缓存**：减轻数据库压力
- **会话存储**：分布式Session管理
- **排行榜**：Sorted Set实现实时排名
- **计数器**：文章阅读量、点赞数
- **消息队列**：List实现的简单队列
- **地理位置**：GEO相关功能

#### 5. Redis 内存满了的淘汰策略
**8种淘汰策略**：
- **noeviction**：默认，返回错误
- **allkeys-lru**：所有key中淘汰最近最少使用的
- **volatile-lru**：设了过期时间的key中LRU淘汰
- **allkeys-random**：随机淘汰
- **volatile-random**：过期key中随机淘汰
- **volatile-ttl**：淘汰即将过期的key
- **allkeys-lfu**：淘汰使用频率最低的key
- **volatile-lfu**：过期key中LFU淘汰

#### 6. Redis 持久化机制
**RDB（快照）**：
- 定时生成数据快照
- `save 900 1` # 900秒内至少1个key变化
- 二进制压缩存储

**AOF（追加日志）**：
- 记录每个写操作命令
- 支持每秒同步/每命令同步/不同步
- 重写机制压缩AOF文件

#### 7. RDB vs AOF 优缺点
| 特性 | RDB | AOF |
|------|-----|-----|
| **数据恢复** | 恢复速度快 | 恢复速度慢 |
| **数据安全** | 可能丢失数据 | 数据更安全 |
| **文件大小** | 文件小，压缩存储 | 文件大，持续增长 |
| **性能影响** | 保存时影响性能 | 写入影响较小 |

**适用场景**：
- RDB：适合备份、容灾恢复
- AOF：适合数据安全性要求高的场景
- 生产环境通常两者结合使用

#### 8. Redis 大Key问题
**风险**：
- 内存不均，集群数据倾斜
- 操作耗时，阻塞其他请求
- 网络拥塞，传输时间过长
- 持久化困难，影响备份效率

**解决方案**：
- 拆分大Key：`bigkey:{part1}`、`bigkey:{part2}`
- 压缩数据：使用Snappy、LZ4压缩
- 使用合适数据结构：Hash代替String存储对象
- 定期清理：监控并清理大Key

#### 9. MySQL 常用存储引擎
- **InnoDB**：支持事务、行级锁、外键（默认）
- **MyISAM**：不支持事务、表级锁、全文索引
- **Memory**：内存存储、速度快、重启丢失
- **Archive**：高压缩、只支持插入查询

#### 10. InnoDB vs MyISAM
| 特性 | InnoDB | MyISAM |
|------|--------|--------|
| **事务** | 支持ACID | 不支持 |
| **锁粒度** | 行级锁 | 表级锁 |
| **外键** | 支持 | 不支持 |
| **崩溃恢复** | 支持 | 不支持 |
| **全文索引** | 5.6+支持 | 支持 |

#### 11. 为什么用B+树不用红黑树？
- **磁盘IO优化**：B+树节点大小=磁盘页大小，减少IO次数
- **范围查询**：B+树叶子节点链表支持高效范围查询
- **高度更低**：相同数据量B+树比二叉树高度低很多
- **顺序访问**：叶子节点存储数据且有序排列

#### 12. B+树范围查询优势
```sql
-- B+树可以高效执行
SELECT * FROM users WHERE age BETWEEN 20 AND 30;
```
- 找到第一个满足条件的叶子节点
- 通过链表指针顺序遍历到范围结束
- 避免回溯父节点，线性扫描效率高

#### 13. B+树保持低层高的原理
- **多路分支**：每个节点有多个子节点（通常100+）
- **节点填充**：每个节点尽可能填满关键字
- **平衡树**：插入删除时自动保持平衡
- **计算示例**：3层B+树可存储100万数据
  - 根节点：100个子节点
  - 中间层：100×100=10,000个节点
  - 叶子层：10,000×100=1,000,000条数据

#### 14. 慢SQL排查优化
**排查步骤**：
```sql
-- 开启慢查询日志
SET GLOBAL slow_query_log = 1;
SET GLOBAL long_query_time = 2;

-- 查看慢查询
SHOW VARIABLES LIKE 'slow_query%';
EXPLAIN SELECT * FROM users WHERE name LIKE '%张%';
```

**优化方法**：
- 添加合适索引
- 优化SQL语句（避免SELECT *）
- 减少JOIN复杂度
- 分库分表

#### 15. 慢查询对系统的影响
- **数据库连接堆积**：占用连接池资源
- **CPU占用过高**：数据库服务器负载上升
- **锁竞争加剧**：长时间持有锁影响并发
- **应用响应变慢**：请求排队等待
- **系统雪崩风险**：连锁反应导致系统崩溃

#### 16. 索引失效情况及解决
**失效情况**：
- 对索引列进行函数操作
- 模糊查询`LIKE '%xxx'`
- 类型隐式转换
- 使用`!=`或`NOT IN`
- 复合索引不满足最左前缀

**解决方案**：
- 避免索引列参与计算
- 优化查询条件顺序
- 使用覆盖索引
- 必要时使用强制索引

#### 17. `LIMIT 10` vs `LIMIT 1000000, 10`性能差异
**性能差异巨大**原因：
- `LIMIT 10`：直接读取前10条，O(1)复杂度
- `LIMIT 1000000, 10`：需要先扫描100万条记录，O(n)复杂度
- 深度分页导致大量无用数据的IO和CPU消耗

#### 18. 深度分页优化方案
```sql
-- 方案1：使用游标分页（推荐）
SELECT * FROM users WHERE id > 1000000 ORDER BY id LIMIT 10;

-- 方案2：子查询优化
SELECT * FROM users 
WHERE id >= (SELECT id FROM users ORDER BY id LIMIT 1000000, 1)
LIMIT 10;

-- 方案3：业务层优化
-- 限制最大分页深度，提供跳页功能
```

#### 19. 线程池工作原理及参数
**核心参数**：
- `corePoolSize`：核心线程数
- `maximumPoolSize`：最大线程数
- `keepAliveTime`：非核心线程空闲存活时间
- `workQueue`：任务队列
- `threadFactory`：线程工厂
- `rejectedExecutionHandler`：拒绝策略

**工作流程**：
1. 提交任务→核心线程未满→创建新线程执行
2. 核心线程已满→加入工作队列等待
3. 队列已满且线程未达最大数→创建新线程
4. 队列已满且线程达最大数→执行拒绝策略

#### 20. 线程池监控管理
**监控指标**：
```java
ThreadPoolExecutor executor = (ThreadPoolExecutor) threadPool;

// 关键监控指标
int activeCount = executor.getActiveCount(); // 活动线程数
long completedTaskCount = executor.getCompletedTaskCount(); // 完成任务数
int queueSize = executor.getQueue().size(); // 队列大小
int poolSize = executor.getPoolSize(); // 当前线程数
```

**管理措施**：
- 动态调整核心参数
- 监控队列堆积告警
- 线程池隔离不同业务
- 优雅关闭线程池

#### 21. 学习方法和职业规划
**学习方法**：
- 官方文档+源码阅读
- 技术博客+实践项目
- 参与开源社区
- 技术分享和交流

**技术规划**：
- 短期：深入分布式系统、高并发架构
- 中期：全栈能力、系统设计能力
- 长期：技术管理、架构师方向

#### 22. 两数之和算法题
```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[]{map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    
    throw new IllegalArgumentException("No two sum solution");
}

// 时间复杂度：O(n)
// 空间复杂度：O(n)
```

**解题思路**：
- 使用HashMap存储数值和索引的映射
- 遍历数组，计算目标值与当前值的差值
- 在HashMap中查找差值是否存在
- 一次遍历即可完成，高效解决

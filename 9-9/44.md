好的，我来详细回答这些面试题，希望能帮助你准备面试。

---

### 1. 在Spring Boot启动时做一些逻辑？使用 CommandLineRunner 或 ApplicationRunner

这两种接口是Spring Boot提供的标准机制，用于在应用完全启动后、在`ApplicationContext`被刷新之后、但在`SpringApplication.run(…)`方法执行完成之前，运行一些特定的代码逻辑。这对于进行一些初始化、数据加载、检查等操作非常有用。

**共同点：**
*   都用于在Spring Boot应用启动后执行一段代码。
*   都可以通过`@Order`注解或实现`Ordered`接口来定义多个Runner的执行顺序。

**区别与选择：**

| 特性 | CommandLineRunner | ApplicationRunner |
| :--- | :--- | :--- |
| **参数接收** | 接收原始的字符串数组参数 `String... args`，即应用启动时传入的main方法参数。 | 接收一个封装好的 `ApplicationArguments` 对象来解析参数。 |
| **参数处理** | 需要自己手动解析参数（例如，使用Apache Commons CLI或Spring的`SimpleCommandLinePropertySource`）。 | 提供了更方便的方法来获取参数，例如：<br> - `getOptionNames()`: 获取所有选项名（如`--server.port=8080`中的`server.port`）<br> - `getOptionValues(String name)`: 获取指定选项的值<br> - `getNonOptionArgs()`: 获取所有非选项参数（无`--`前缀的参数） |
| **适用场景** | 参数非常简单，或者你习惯于直接处理字符串数组。 | **更推荐**。参数格式更复杂，需要区分选项参数和非选项参数时。 |

**代码示例：**

**1. 使用 CommandLineRunner**
```java
import org.springframework.boot.CommandLineRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Order(1) // 定义执行顺序，数字越小优先级越高
public class MyCommandLineRunner implements CommandLineRunner {

    @Override
    public void run(String... args) throws Exception {
        System.out.println("MyCommandLineRunner started with args: ");
        for (String arg : args) {
            System.out.println(">>> " + arg);
        }
        // 这里写你的启动逻辑，例如初始化缓存、加载数据等
        System.out.println("执行初始化逻辑...");
    }
}
```

**2. 使用 ApplicationRunner**
```java
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

@Component
@Order(2)
public class MyApplicationRunner implements ApplicationRunner {

    @Override
    public void run(ApplicationArguments args) throws Exception {
        System.out.println("MyApplicationRunner started");
        System.out.println("非选项参数: " + args.getNonOptionArgs());
        System.out.println("选项参数名: " + args.getOptionNames());
        
        // 获取特定选项参数的值，例如 --config=path/to/config
        if (args.containsOption("config")) {
            System.out.println("Config path: " + args.getOptionValues("config"));
        }
        
        // 这里写你的启动逻辑
        System.out.println("执行另一段初始化逻辑...");
    }
}
```

**启动命令：**
`java -jar yourapp.jar arg1 --config=path/to/config.yml arg2`

**输出将会是：**
```
MyCommandLineRunner started with args:
>>> arg1
>>> --config=path/to/config.yml
>>> arg2
执行初始化逻辑...
MyApplicationRunner started
非选项参数: [arg1, arg2]
选项参数名: [config]
Config path: [path/to/config.yml]
执行另一段初始化逻辑...
```

---

### 2. Spring Boot全局异常处理使用什么方法或注解？用 @ControllerAdvice 和 @ExceptionHandler

在Spring MVC中，全局异常处理是通过`@ControllerAdvice`（或`@RestControllerAdvice`）和`@ExceptionHandler`这两个注解组合来实现的。

*   **`@ControllerAdvice`**： 这是一个组件注解，用于定义一个全局的、跨所有Controller的异常处理类。它会拦截应用中所有Controller抛出的异常。
    *   `@RestControllerAdvice` 是`@ControllerAdvice`和`@ResponseBody`的组合，意味着类中所有方法的返回值都会直接写入HTTP响应体，通常用于编写返回JSON格式的RESTful API异常处理器。

*   **`@ExceptionHandler`**： 这个注解用在方法上，用于指定该方法可以处理哪种类型的异常。它可以处理特定的异常（如`MyCustomException.class`）或其父类（如`Exception.class`）。

**代码示例：**

```java
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.util.HashMap;
import java.util.Map;

// 使用 @RestControllerAdvice 表示这是一个全局REST异常处理器，返回值是JSON
@RestControllerAdvice
public class GlobalExceptionHandler {

    // 处理特定的自定义异常
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<Map<String, Object>> handleBusinessException(BusinessException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("code", ex.getCode()); // 自定义错误码
        body.put("message", ex.getMessage()); // 错误信息
        body.put("timestamp", System.currentTimeMillis());
        
        // 返回HTTP状态码和错误体
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }

    // 处理更通用的异常，比如所有未明确处理的Exception
    @ExceptionHandler(Exception.class)
    public ResponseEntity<Map<String, Object>> handleGlobalException(Exception ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("code", "500");
        body.put("message", "服务器内部错误，请稍后再试");
        body.put("timestamp", System.currentTimeMillis());
        
        // 记录日志，实际项目中非常重要！
        // logger.error("Unhandled exception occurred: ", ex);
        
        return new ResponseEntity<>(body, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    // 处理Spring MVC参数绑定等异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Map<String, Object>> handleValidationException(MethodArgumentNotValidException ex) {
        Map<String, Object> body = new HashMap<>();
        body.put("code", "400");
        // 从ex中提取详细的字段校验错误信息
        // ... 具体提取逻辑
        body.put("message", "请求参数校验失败");
        body.put("timestamp", System.currentTimeMillis());
        return new ResponseEntity<>(body, HttpStatus.BAD_REQUEST);
    }
}
```

**优点：**
*   **代码解耦**： 异常处理逻辑从Controller中分离出来，Controller更专注于业务。
*   **统一响应格式**： 所有异常都可以返回结构一致的错误信息（JSON）。
*   **灵活精细**： 可以为不同类型的异常定义不同的处理方法和HTTP状态码。

---

### 3. MyBatis 中 `$` 和 `#` 的区别

这是MyBatis面试中最核心的问题之一，本质是**静态替换** vs. **预编译占位符**的区别。

| 特性 | `#{}` (**首选和推荐**) | `${}` (**谨慎使用**) |
| :--- | :--- | :--- |
| **处理方式** | **预编译（PreparedStatement）** | **字符串拼接（Statement）** |
| **安全性** | **高，能有效防止SQL注入**。MyBatis会将其转换为`?`占位符，然后由JDBC驱动对参数进行安全设置。 | **低，存在SQL注入风险**。MyBatis会直接将其中的内容替换为字符串，拼接成完整的SQL语句。 |
| **用途** | 主要用于**传递参数值**。适用于`WHERE`条件、`INSERT`语句的值等几乎所有传递值的场景。 | 主要用于**动态替换SQL语句的组成部分**，如**表名**、**列名**、`ORDER BY`子句等**无法使用预编译占位符**的地方。 |
| **示例** | `SELECT * FROM user WHERE name = #{name}` <br> 解析为：`SELECT * FROM user WHERE name = ?` (安全) | `ORDER BY ${columnName}` <br> 解析为：`ORDER BY create_time` (如果不加校验，用户传入`"1; DROP TABLE user;"`就极危险) |
| **自动类型处理** | 是。JDBC驱动会正确处理日期、数字等类型。 | 否。仅仅是字符串替换，需要自己保证语法正确。 |
| **总结** | **默认、安全的方式。99%的场景都应该使用它。** | **不得已而为之的方式。使用时必须对传入的参数进行严格的校验和白名单过滤。** |

---

### 4. Git 的常见命令

| 类别 | 命令 | 说明 |
| :--- | :--- | :--- |
| **基础配置** | `git config --global user.name "Your Name"` | 设置全局用户名 |
| | `git config --global user.email "email@example.com"` | 设置全局邮箱 |
| **创建与克隆** | `git init` | 在当前目录初始化一个新的Git仓库 |
| | `git clone <url>` | 克隆一个远程仓库到本地 |
| **基本操作** | `git status` | 查看工作区和暂存区的状态（**最常用**） |
| | `git add <file>` 或 `git add .` | 将文件更改添加到暂存区 |
| | `git commit -m "commit message"` | 将暂存区的更改提交到本地仓库 |
| | `git push origin <branch-name>` | 将本地分支推送到远程仓库 |
| | `git pull origin <branch-name>` | 拉取远程分支的更新并合并到当前分支（=`git fetch` + `git merge`） |
| **分支管理** | `git branch` | 查看所有本地分支 |
| | `git branch <branch-name>` | 创建一个新分支 |
| | `git checkout <branch-name>` | 切换到指定分支 |
| | `git checkout -b <branch-name>` | 创建并切换到新分支（常用） |
| | `git merge <branch-name>` | 将指定分支合并到当前分支 |
| | `git branch -d <branch-name>` | 删除指定分支 |
| **查看历史** | `git log` | 查看提交历史 |
| | `git log --oneline --graph` | 以简洁的单行和图形方式查看历史 |
| | `git diff` | 查看工作区与暂存区的差异 |
| | `git diff --staged` | 查看暂存区与最后一次提交的差异 |
| **撤销操作** | `git restore <file>` | **撤销工作区的修改**（恢复到最近一次`git commit`或`git add`的状态） |
| | `git restore --staged <file>` | **将文件从暂存区撤出**（unstage），但保留工作区的修改 |
| | `git reset --hard <commit-id>` | **危险！** 强制回退到某个提交，丢弃所有之后的提交和修改 |
| **远程操作** | `git remote -v` | 查看远程仓库信息 |
| | `git fetch origin` | 从远程仓库获取所有更新，但不自动合并 |

---

### 5. 平时用AI工具来辅助编程

是的，AI工具已经成为提高开发效率的重要辅助手段。我主要会在以下场景使用它们：

1.  **代码生成与补全**：
    *   **场景**：编写重复性高的样板代码（如Getter/Setter、简单的CRUD方法）、根据注释描述生成函数骨架、编写单元测试用例。
    *   **工具**： GitHub Copilot, Tabnine, IDE自带的智能补全。

2.  **技术方案咨询与学习**：
    *   **场景**：遇到不熟悉的技术、库或API时，快速获取示例代码和解释。对比不同技术的优缺点。
    *   **工具**： ChatGPT, Claude, Phind。

3.  **调试与错误解决**：
    *   **场景**：将复杂的错误日志或异常栈信息贴给AI，让它帮助分析可能的原因和解决方案。这通常比传统搜索引擎更快。
    *   **工具**： ChatGPT, 搜索引擎的AI功能（如Bing Chat）。

4.  **代码审查与优化**：
    *   **场景**：将一段代码提交给AI，让它提出改进建议，如发现潜在bug、性能瓶颈、更优雅的写法、是否符合最佳实践等。
    *   **工具**： ChatGPT, GitHub Copilot Chat。

5.  **文档和注释生成**：
    *   **场景**：为复杂的函数或类生成初步的注释和文档说明。
    *   **工具**： GitHub Copilot, ChatGPT。

**重要提示**：
*   **AI是辅助，而非替代**：生成的代码必须经过自己的仔细审查、测试和调试，不能盲目相信。
*   **注意代码安全与合规**：切勿将公司敏感代码、业务逻辑或密钥上传到公有AI平台。

---

### 6. 算法: 环形数组，把1全部聚集起来

**题目描述**： 给定一个**环形**二进制数组 `nums`（即认为数组首尾相连），返回使数组中所有 `1` 聚集在一起的**最小交换次数**。一次交换操作是指交换数组中**相邻**的两个元素。

**思路分析（滑动窗口）**：
1.  **问题转化**： 在环形数组中把所有 `1` 聚集在一起，等价于找到一个连续的区间（窗口），这个窗口里包含了数组中所有的 `1`。由于是环形，我们需要将数组复制一份连接到原数组末尾，来模拟环形结构。
2.  **关键洞察**： 最终所有 `1` 聚集在一起的理想状态，就是这个窗口内**全部是 `1`**。然而，窗口内可能原本就有一些 `1` 和一些 `0`。我们的目标是将窗口外的 `1` 交换进来，同时将窗口内的 `0` 交换出去。但注意，**一次相邻交换其实可以同时完成这两件事**。
3.  **最小交换次数**： 实际上，对于任何一个长度为 `totalOnes`（数组中 `1` 的总数）的窗口，我们需要的最小交换次数，就等于**这个窗口内 `0` 的个数**（因为每个 `0` 都需要被换出去，为 `1` 腾出空间）。
4.  **算法步骤**：
    *   统计数组中 `1` 的总数，记为 `totalOnes`。如果 `totalOnes == 0`，直接返回 `0`。
    *   将原数组 `nums` 复制一份，得到两倍长度的新数组 `arr`（以处理环形）。
    *   使用一个长度为 `totalOnes` 的滑动窗口，在新数组 `arr` 上从左向右滑动。
    *   计算**初始窗口** `[0, totalOnes-1]` 内 `0` 的个数，记为 `minSwaps`（即初始答案）。
    *   滑动窗口：窗口右移一位。新加入的元素是 `arr[i]`，移出的元素是 `arr[i - totalOnes]`。
        *   如果**移出**的是 `0`，那么窗口内 `0` 的数量 `cntZero` **减少1**。
        *   如果**新加入**的是 `0`，那么 `cntZero` **增加1**。
    *   在滑动过程中，不断用 `cntZero` 更新最小值 `minSwaps`。
    *   最终得到的 `minSwaps` 就是答案。

**代码实现（Java）**：

```java
public class Solution {
    public int minSwaps(int[] nums) {
        int totalOnes = 0;
        for (int num : nums) {
            if (num == 1) {
                totalOnes++;
            }
        }
        
        // 特殊情况：如果没有1，不需要交换
        if (totalOnes == 0) {
            return 0;
        }
        
        int n = nums.length;
        // 创建2倍长度的数组来模拟环形
        int[] arr = new int[2 * n];
        for (int i = 0; i < 2 * n; i++) {
            arr[i] = nums[i % n];
        }
        
        int minSwaps = Integer.MAX_VALUE;
        int cntZero = 0;
        
        // 初始化第一个窗口 [0, totalOnes-1]
        for (int i = 0; i < totalOnes; i++) {
            if (arr[i] == 0) {
                cntZero++;
            }
        }
        minSwaps = Math.min(minSwaps, cntZero);
        
        // 滑动窗口，i 是窗口的右边界（包含）
        for (int i = totalOnes; i < 2 * n; i++) {
            // 移出窗口左边界元素 (i - totalOnes)
            if (arr[i - totalOnes] == 0) {
                cntZero--;
            }
            // 新加入当前元素 i
            if (arr[i] == 0) {
                cntZero++;
            }
            // 更新最小值
            minSwaps = Math.min(minSwaps, cntZero);
        }
        
        return minSwaps;
    }
}
```

**复杂度分析**：
*   **时间复杂度**：O(N)，其中 N 是数组长度。我们遍历了两次原数组（统计1的个数和构建2倍数组），以及一次2N长度的滑动窗口。
*   **空间复杂度**：O(N)，用于创建2倍长度的模拟环形数组。

这个解法高效且清晰地利用了滑动窗口模型来解决环形数组问题。

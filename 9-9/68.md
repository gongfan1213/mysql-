# é¡¹ç›®æ·±åº¦æŠ€æœ¯é—®é¢˜è§£ç­”

## 2ï¸âƒ£ è´Ÿè´£æ¨¡å—ä¸æŠ€æœ¯éš¾ç‚¹

### è´Ÿè´£æ¨¡å—
æˆ‘ä¸»è¦è´Ÿè´£**æ™ºèƒ½é—®ç­”ç³»ç»Ÿçš„å¯¹è¯ç®¡ç†æ¨¡å—**ï¼ŒåŒ…æ‹¬ï¼š
- å¤šè½®å¯¹è¯ä¸Šä¸‹æ–‡ç»´æŠ¤
- æ„å›¾è¯†åˆ«å’Œå¯¹è¯çŠ¶æ€è·Ÿè¸ª
- å›ç­”ç”Ÿæˆå’Œæµå¼è¿”å›
- æ•°æ®æŒä¹…åŒ–å’Œç¼“å­˜ç®¡ç†

### æŠ€æœ¯éš¾ç‚¹ä¸æˆé•¿
**æ›´é«˜éš¾åº¦çš„æŠ€æœ¯ç‚¹**ï¼š
1. **å¯¹è¯ä¸Šä¸‹æ–‡ä¸€è‡´æ€§**ï¼šä¿è¯é•¿å¯¹è¯ä¸­ä¸Šä¸‹æ–‡ä¸ä¸¢å¤±ã€ä¸æ··ä¹±
2. **æµå¼å“åº”å¤„ç†**ï¼šå¤„ç†å¤§è¯­è¨€æ¨¡å‹ç”Ÿæˆæ—¶çš„æµå¼æ•°æ®ä¼ è¾“
3. **æ•°æ®æœ€ç»ˆä¸€è‡´æ€§**ï¼šåœ¨Rediså’ŒMySQLä¹‹é—´ä¿è¯æ•°æ®ä¸€è‡´æ€§

**æœ€å¤§æˆé•¿å¸®åŠ©**ï¼š
1. **åˆ†å¸ƒå¼ç³»ç»Ÿè®¾è®¡**ï¼šæ·±å…¥ç†è§£CAPç†è®ºå’Œæœ€ç»ˆä¸€è‡´æ€§
2. **æ€§èƒ½ä¼˜åŒ–**ï¼šå­¦ä¼šåœ¨ä¸åŒå­˜å‚¨ä»‹è´¨é—´å¹³è¡¡æ€§èƒ½ä¸æŒä¹…æ€§
3. **æ•…éšœå¤„ç†**ï¼šè®¾è®¡å®Œå–„çš„é”™è¯¯æ¢å¤å’Œé‡è¯•æœºåˆ¶

## 3ï¸âƒ£ å¯¹è¯ä¸Šä¸‹æ–‡å®ç°

### ä¸Šä¸‹æ–‡å†…å®¹
```java
public class DialogueContext {
    private String sessionId;          // ä¼šè¯ID
    private String userId;             // ç”¨æˆ·ID
    private List<Message> history;     // å¯¹è¯å†å²
    private Map<String, Object> state; // å¯¹è¯çŠ¶æ€
    private long timestamp;            // æœ€åæ›´æ–°æ—¶é—´
    private int turnCount;             // å¯¹è¯è½®æ•°
}

public class Message {
    private String role;     // "user" æˆ– "assistant"
    private String content;  // æ¶ˆæ¯å†…å®¹
    private long timestamp;  // æ¶ˆæ¯æ—¶é—´æˆ³
}
```

### å­˜å‚¨æ¶æ„
```mermaid
graph TD
    A[å¯¹è¯ä¸Šä¸‹æ–‡å­˜å‚¨] --> B[Redis ç¼“å­˜]
    A --> C[MySQL æŒä¹…åŒ–]
    
    B --> B1[ä¼šè¯æ•°æ®]
    B --> B2[ä¸´æ—¶çŠ¶æ€]
    B --> B3[çƒ­ç‚¹æ•°æ®]
    
    C --> C1[å†å²è®°å½•]
    C --> C2[å®¡è®¡æ—¥å¿—]
    C --> C3[é•¿æœŸå­˜å‚¨]
    
    D[å­˜å‚¨ç­–ç•¥] --> D1[å®æ—¶æ•°æ®: Redis]
    D --> D2[å†å²æ•°æ®: MySQL]
    D --> D3[å¤‡ä»½æ•°æ®: å¯¹è±¡å­˜å‚¨]
```

**ä¸å®Œå…¨ä¾èµ–Redis**ï¼š
- Redisï¼šå­˜å‚¨æ´»è·ƒä¼šè¯çš„ä¸Šä¸‹æ–‡ï¼ˆTTL: 30åˆ†é’Ÿï¼‰
- MySQLï¼šæŒä¹…åŒ–å®Œæ•´å¯¹è¯å†å²ï¼ˆé•¿æœŸå­˜å‚¨ï¼‰
- æœ¬åœ°å†…å­˜ï¼šå½“å‰è¯·æ±‚çš„ä¸´æ—¶çŠ¶æ€ï¼ˆè¯·æ±‚ç”Ÿå‘½å‘¨æœŸå†…ï¼‰

## 4ï¸âƒ£ Redisä¸MySQLå†™å…¥æŸ¥è¯¢é¡ºåº

### å†™å…¥é¡ºåº
```java
@Component
public class DataWriteService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Autowired
    private JdbcTemplate jdbcTemplate;
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    /**
     * å†™å…¥é¡ºåºï¼šå…ˆRedisï¼ŒåMySQLï¼ˆå¼‚æ­¥ï¼‰
     */
    @Transactional
    public void writeUserMessage(String sessionId, Message message) {
        // 1. å…ˆå†™Redisï¼ˆä¿è¯å¿«é€Ÿå“åº”ï¼‰
        String redisKey = "dialogue:" + sessionId;
        redisTemplate.opsForList().rightPush(redisKey, message);
        redisTemplate.expire(redisKey, 30, TimeUnit.MINUTES);
        
        // 2. å‘é€åˆ°RabbitMQè¿›è¡Œå¼‚æ­¥MySQLæŒä¹…åŒ–
        rabbitTemplate.convertAndSend("message.persist", 
            new PersistMessage(sessionId, message));
        
        // 3. æ›´æ–°å¯¹è¯çŠ¶æ€ï¼ˆRedisä¸­ï¼‰
        updateDialogueState(sessionId, message);
    }
}
```

### æŸ¥è¯¢é¡ºåº
```java
public class DataQueryService {
    
    public List<Message> getDialogueHistory(String sessionId) {
        // 1. å…ˆæŸ¥Redisï¼ˆå¿«é€Ÿè·å–æœ€è¿‘å¯¹è¯ï¼‰
        List<Message> recentMessages = getFromRedis(sessionId);
        
        if (recentMessages != null && !recentMessages.isEmpty()) {
            // 2. å¦‚æœéœ€è¦æ›´å¤šå†å²ï¼ŒæŸ¥è¯¢MySQL
            if (needMoreHistory(recentMessages)) {
                List<Message> historyMessages = getFromMySQL(sessionId);
                return mergeMessages(historyMessages, recentMessages);
            }
            return recentMessages;
        }
        
        // 3. Redisä¸­æ²¡æœ‰ï¼Œç›´æ¥æŸ¥è¯¢MySQL
        return getFromMySQL(sessionId);
    }
}
```

## 5ï¸âƒ£ RedisæˆåŠŸä½†MySQLå¤±è´¥çš„å¤„ç†

### è¡¥å¿æœºåˆ¶è®¾è®¡
```java
@Component
public class MessagePersistHandler {
    
    @RabbitListener(queues = "message.persist")
    public void handlePersistMessage(PersistMessage message) {
        int retryCount = 0;
        boolean success = false;
        
        while (retryCount < MAX_RETRY && !success) {
            try {
                // å°è¯•å†™å…¥MySQL
                persistToMySQL(message);
                success = true;
                
            } catch (Exception e) {
                retryCount++;
                
                if (retryCount >= MAX_RETRY) {
                    // é‡è¯•å¤±è´¥ï¼Œè¿›å…¥æ­»ä¿¡é˜Ÿåˆ—
                    handlePersistenceFailure(message, e);
                } else {
                    // å»¶è¿Ÿé‡è¯•
                    Thread.sleep(getBackoffTime(retryCount));
                }
            }
        }
    }
    
    private void handlePersistenceFailure(PersistMessage message, Exception e) {
        // 1. è®°å½•å¤±è´¥æ—¥å¿—
        log.error("MySQLæŒä¹…åŒ–å¤±è´¥: {}", message.getSessionId(), e);
        
        // 2. åœ¨Redisä¸­æ ‡è®°æ•°æ®çŠ¶æ€
        String statusKey = "persist:status:" + message.getSessionId();
        redisTemplate.opsForValue().set(statusKey, "failed");
        
        // 3. å‘é€å‘Šè­¦é€šçŸ¥
        alertService.sendAlert("æ•°æ®æŒä¹…åŒ–å¤±è´¥", message.getSessionId());
        
        // 4. å­˜å…¥ä¿®å¤é˜Ÿåˆ—ç­‰å¾…æ‰‹åŠ¨å¹²é¢„
        repairQueue.add(message);
    }
}
```

## 6ï¸âƒ£ RabbitMQå¼•å…¥ä½ç½®ä¸è®¾è®¡ç†ç”±

### æ¶æ„è®¾è®¡
```mermaid
graph LR
    A[ç”¨æˆ·è¯·æ±‚] --> B[WebæœåŠ¡å™¨]
    B --> C[Redis å®æ—¶å†™å…¥]
    B --> D[RabbitMQ æ¶ˆæ¯é˜Ÿåˆ—]
    D --> E[MySQL å¼‚æ­¥æŒä¹…åŒ–]
    C --> F[å³æ—¶å“åº”ç”¨æˆ·]
    
    style C fill:#e6f3ff
    style D fill:#e6f3ff
    style E fill:#e6f3ff
```

**å¼•å…¥ä½ç½®**ï¼šåœ¨WebæœåŠ¡å™¨å’ŒMySQLä¹‹é—´

**è®¾è®¡ç†ç”±**ï¼š
1. **è§£è€¦**ï¼šå°†å®æ—¶å“åº”ä¸æ•°æ®æŒä¹…åŒ–åˆ†ç¦»
2. **ç¼“å†²**ï¼šåº”å¯¹MySQLå†™å…¥é«˜å³°ï¼Œé¿å…ç›´æ¥å‹åŠ›
3. **é‡è¯•**ï¼šæä¾›å¤±è´¥é‡è¯•æœºåˆ¶
4. **å‰Šå³°å¡«è°·**ï¼šå¹³è¡¡ç³»ç»Ÿè´Ÿè½½

## 7ï¸âƒ£ å¹¶å‘è®¾è®¡ä¸éƒ¨ç½²

### å¹¶å‘è®¾è®¡åˆç†æ€§
```java
@Configuration
public class ConcurrentConfig {
    
    @Bean
    public ThreadPoolTaskExecutor messageProcessor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(20);      // æ ¸å¿ƒçº¿ç¨‹æ•°
        executor.setMaxPoolSize(100);       // æœ€å¤§çº¿ç¨‹æ•°
        executor.setQueueCapacity(1000);    // é˜Ÿåˆ—å®¹é‡
        executor.setThreadNamePrefix("msg-process-");
        return executor;
    }
    
    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory() {
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        factory.setConcurrentConsumers(10); // å¹¶å‘æ¶ˆè´¹è€…æ•°
        factory.setMaxConcurrentConsumers(50); // æœ€å¤§æ¶ˆè´¹è€…æ•°
        return factory;
    }
}
```

**å¹¶å‘é‡**ï¼š
- è®¾è®¡å®¹é‡ï¼š1000 QPS
- æ—¥å¸¸è´Ÿè½½ï¼š200-300 QPS
- å³°å€¼è´Ÿè½½ï¼š800 QPS

**éƒ¨ç½²æ–¹å¼**ï¼šäº‘åŸç”Ÿéƒ¨ç½²ï¼Œé¢å‘å®é™…ç”¨æˆ·æœåŠ¡

## 8ï¸âƒ£ æ¶ˆæ¯å‘é€æˆåŠŸå®šä¹‰

### æˆåŠŸæ ‡å‡†
```java
public class MessageSendService {
    
    public SendResult sendMessage(String sessionId, String content) {
        try {
            Message message = new Message(sessionId, content, System.currentTimeMillis());
            
            // 1. å†™å…¥Redisï¼ˆä¸»è¦æˆåŠŸæ ‡å‡†ï¼‰
            redisTemplate.opsForList().rightPush("dialogue:" + sessionId, message);
            
            // 2. å¼‚æ­¥å‘é€åˆ°MQè¿›è¡ŒæŒä¹…åŒ–
            rabbitTemplate.convertAndSend("message.persist", message);
            
            // 3. è¿”å›æˆåŠŸï¼ˆä»¥Rediså†™å…¥ä¸ºå‡†ï¼‰
            return SendResult.success(message.getId());
            
        } catch (Exception e) {
            log.error("æ¶ˆæ¯å‘é€å¤±è´¥", e);
            return SendResult.failure("å‘é€å¤±è´¥");
        }
    }
}
```

**æˆåŠŸæ ‡å‡†**ï¼šä»¥Rediså†™å…¥æˆåŠŸä¸ºå‡†ï¼Œå› ä¸ºï¼š
1. Redisæä¾›å®æ—¶å¯¹è¯èƒ½åŠ›
2. MySQLæŒä¹…åŒ–æ˜¯å¼‚æ­¥çš„ï¼Œä¸å½±å“ç”¨æˆ·ä½“éªŒ
3. æœ‰è¡¥å¿æœºåˆ¶ä¿è¯æœ€ç»ˆä¸€è‡´æ€§

## 9ï¸âƒ£ MySQLæŒä¹…åŒ–å¤±è´¥çš„ç”¨æˆ·æ„ŸçŸ¥

### ç”¨æˆ·æ„ŸçŸ¥æ–¹æ¡ˆ
```java
public class DialogueService {
    
    public List<Message> getDialogueHistory(String sessionId) {
        // è·å–Redisä¸­çš„æœ€è¿‘æ¶ˆæ¯
        List<Message> messages = getFromRedis(sessionId);
        
        // æ£€æŸ¥æŒä¹…åŒ–çŠ¶æ€
        String persistStatus = redisTemplate.opsForValue()
            .get("persist:status:" + sessionId);
        
        if ("failed".equals(persistStatus)) {
            // é€šçŸ¥ç”¨æˆ·æ•°æ®å¯èƒ½ä¸å®Œæ•´
            messages.add(createSystemMessage("éƒ¨åˆ†å†å²è®°å½•å¯èƒ½æš‚æ—¶ä¸å¯ç”¨"));
        }
        
        return messages;
    }
    
    public void retryFailedPersist(String sessionId) {
        // ä»Redisè·å–æœªæŒä¹…åŒ–çš„æ¶ˆæ¯
        List<Message> unsavedMessages = getUnpersistedMessages(sessionId);
        
        // é‡æ–°å°è¯•æŒä¹…åŒ–
        for (Message message : unsavedMessages) {
            rabbitTemplate.convertAndSend("message.persist.retry", message);
        }
        
        // æ¸…é™¤å¤±è´¥çŠ¶æ€
        redisTemplate.delete("persist:status:" + sessionId);
    }
}
```

## ğŸ”Ÿ RabbitMQ vs Kafkaé€‰æ‹©

### æŠ€æœ¯é€‰å‹å¯¹æ¯”
```java
public class MQComparison {
    
    /**
     * é€‰æ‹©RabbitMQçš„åŸå› 
     */
    public void whyChooseRabbitMQ() {
        // 1. æ¶ˆæ¯ç¡®è®¤æœºåˆ¶æ›´å®Œå–„
        // 2. ä¼˜å…ˆçº§é˜Ÿåˆ—æ”¯æŒæ›´å¥½
        // 3. å»¶è¿Ÿæ¶ˆæ¯åŸç”Ÿæ”¯æŒ
        // 4. ç®¡ç†ç•Œé¢æ›´å‹å¥½
        // 5. æ›´é€‚åˆä¸šåŠ¡æ¶ˆæ¯åœºæ™¯
    }
    
    /**
     * RabbitMQ vs Kafka å¯¹æ¯”
     */
    public void compareMQ() {
        Map<String, String> comparison = Map.of(
            "ååé‡", "Kafka > RabbitMQ",
            "å»¶è¿Ÿ", "RabbitMQ < Kafka",
            "æ¶ˆæ¯ä¿è¯", "RabbitMQæ›´å¼º",
            "åŠŸèƒ½ä¸°å¯Œåº¦", "RabbitMQæ›´ä¸°å¯Œ",
            "æ‰©å±•æ€§", "Kafkaæ›´å¥½",
            "é€‚ç”¨åœºæ™¯", "RabbitMQ:ä¸šåŠ¡æ¶ˆæ¯, Kafka:æ—¥å¿—æµ"
        );
    }
}
```

**é€‰æ‹©ç†ç”±**ï¼š
1. **ä¸šåŠ¡ç‰¹æ€§**ï¼šéœ€è¦ä¸¥æ ¼çš„æ¶ˆæ¯ç¡®è®¤å’Œä¼˜å…ˆçº§
2. **å»¶è¿Ÿæ¶ˆæ¯**ï¼šéœ€è¦æ”¯æŒå»¶è¿Ÿé‡è¯•æœºåˆ¶
3. **ç®¡ç†éœ€æ±‚**ï¼šéœ€è¦å‹å¥½çš„ç®¡ç†ç•Œé¢ç›‘æ§æ¶ˆæ¯çŠ¶æ€
4. **æ•°æ®é‡**ï¼šæ¶ˆæ¯é‡åœ¨RabbitMQèˆ’é€‚åŒºå†…

## 1ï¸âƒ£1ï¸âƒ£ æç¤ºè¯å·¥ç¨‹æŠ€æœ¯å®ç°

### æç¤ºè¯å·¥ç¨‹æ¶æ„
```java
public class PromptEngineeringService {
    
    private static final Map<String, String> PROMPT_TEMPLATES = Map.of(
        "qa", "ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„åŠ©æ‰‹ï¼Œè¯·å›ç­”ä»¥ä¸‹é—®é¢˜ï¼š\n{question}",
        "analysis", "è¯·åˆ†æä»¥ä¸‹å†…å®¹ï¼š\n{content}\nç»™å‡ºè¯¦ç»†åˆ†æï¼š",
        "creative", "å‘æŒ¥åˆ›é€ åŠ›ï¼Œæ ¹æ®ä»¥ä¸‹æç¤ºåˆ›ä½œï¼š\n{idea}"
    );
    
    public String buildPrompt(String promptType, Map<String, String> variables) {
        String template = PROMPT_TEMPLATES.getOrDefault(promptType, PROMPT_TEMPLATES.get("qa"));
        
        // å˜é‡æ›¿æ¢
        for (Map.Entry<String, String> entry : variables.entrySet()) {
            template = template.replace("{" + entry.getKey() + "}", entry.getValue());
        }
        
        // æ·»åŠ ä¸Šä¸‹æ–‡
        if (variables.containsKey("context")) {
            template = "ä¸Šä¸‹æ–‡ï¼š\n" + variables.get("context") + "\n\n" + template;
        }
        
        return template;
    }
    
    public String optimizePrompt(String originalPrompt, String responseQuality) {
        // åŸºäºåé¦ˆä¼˜åŒ–æç¤ºè¯
        PromptOptimizer optimizer = new PromptOptimizer();
        return optimizer.optimize(originalPrompt, responseQuality);
    }
}
```

**æŠ€æœ¯ç‚¹**ï¼š
1. **æ¨¡æ¿å¼•æ“**ï¼šåŸºäºå˜é‡æ›¿æ¢çš„æ¨¡æ¿ç³»ç»Ÿ
2. **ä¸Šä¸‹æ–‡ç®¡ç†**ï¼šåŠ¨æ€æ·»åŠ ä¸Šä¸‹æ–‡ä¿¡æ¯
3. **ä¼˜åŒ–ç®—æ³•**ï¼šåŸºäºåé¦ˆçš„æç¤ºè¯ä¼˜åŒ–
4. **A/Bæµ‹è¯•**ï¼šä¸åŒæç¤ºè¯æ•ˆæœå¯¹æ¯”

## 1ï¸âƒ£2ï¸âƒ£ å‘é‡æ£€ç´¢å®ç°

### å‘é‡æ£€ç´¢æ¶æ„
```java
public class VectorSearchService {
    
    @Autowired
    private EmbeddingModel embeddingModel;
    
    @Autowired
    private VectorDatabase vectorDB;
    
    public List<SearchResult> semanticSearch(String query, int topK) {
        // 1. ç”ŸæˆæŸ¥è¯¢å‘é‡
        float[] queryVector = embeddingModel.embed(query);
        
        // 2. å‘é‡æ•°æ®åº“æ£€ç´¢
        List<VectorMatch> matches = vectorDB.search(queryVector, topK);
        
        // 3. ç»“æœé‡æ’åº
        return rerankResults(query, matches);
    }
    
    public void updateVectorIndex(Document document) {
        // ç”Ÿæˆæ–‡æ¡£å‘é‡
        float[] vector = embeddingModel.embed(document.getContent());
        
        // æ›´æ–°å‘é‡æ•°æ®åº“
        vectorDB.addVector(document.getId(), vector, document.getMetadata());
    }
}
```

**æ¨¡å‹è°ƒä¼˜å‚ä¸**ï¼š
- å‚ä¸embeddingæ¨¡å‹çš„å¾®è°ƒ
- è®¾è®¡æŸå¤±å‡½æ•°å’Œè¯„ä¼°æŒ‡æ ‡
- ä¼˜åŒ–è´Ÿé‡‡æ ·ç­–ç•¥
- ç›‘æ§å‘é‡è´¨é‡

## 1ï¸âƒ£3ï¸âƒ£ æµå¼è¿”å›å®ç°

### æµå¼æ¶æ„
```java
@RestController
public class StreamResponseController {
    
    @GetMapping(value = "/chat/stream", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<String> streamChat(@RequestParam String question) {
        return Flux.create(fluxSink -> {
            // æ¨¡æ‹Ÿæµå¼ç”Ÿæˆ
            String[] parts = generateResponseParts(question);
            
            for (String part : parts) {
                fluxSink.next(part);
                try {
                    Thread.sleep(100); // æ¨¡æ‹Ÿç”Ÿæˆå»¶è¿Ÿ
                } catch (InterruptedException e) {
                    fluxSink.error(e);
                    return;
                }
            }
            
            fluxSink.complete();
        });
    }
    
    // SSEï¼ˆServer-Sent Eventsï¼‰å®ç°
    @GetMapping(value = "/chat/sse", produces = MediaType.TEXT_EVENT_STREAM_VALUE)
    public Flux<ServerSentEvent<String>> sseChat(@RequestParam String question) {
        return Flux.interval(Duration.ofMillis(100))
                .take(10)
                .map(sequence -> ServerSentEvent.<String>builder()
                        .id(String.valueOf(sequence))
                        .event("message")
                        .data("Message " + sequence)
                        .build());
    }
}
```

**å‰åç«¯äº¤äº’**ï¼š
- ä½¿ç”¨WebSocketæˆ–SSEä¿æŒé•¿è¿æ¥
- å‰ç«¯é€šè¿‡EventSource APIæ¥æ”¶æµå¼æ•°æ®
- æœåŠ¡ç«¯åˆ†å—ä¼ è¾“ç¼–ç ï¼ˆchunked transfer encodingï¼‰

## 1ï¸âƒ£4ï¸âƒ£ å¸ƒéš†è¿‡æ»¤å™¨åº”ç”¨

### å¸ƒéš†è¿‡æ»¤å™¨å®ç°
```java
public class BloomFilter {
    
    private final BitSet bitset;
    private final int size;
    private final int[] hashSeeds;
    
    public BloomFilter(int size, int hashFunctions) {
        this.size = size;
        this.bitset = new BitSet(size);
        this.hashSeeds = new int[hashFunctions];
        
        Random random = new Random();
        for (int i = 0; i < hashFunctions; i++) {
            hashSeeds[i] = random.nextInt();
        }
    }
    
    public void add(String value) {
        for (int seed : hashSeeds) {
            int hash = hash(value, seed);
            bitset.set(Math.abs(hash % size), true);
        }
    }
    
    public boolean mightContain(String value) {
        for (int seed : hashSeeds) {
            int hash = hash(value, seed);
            if (!bitset.get(Math.abs(hash % size))) {
                return false;
            }
        }
        return true;
    }
    
    private int hash(String value, int seed) {
        // ç®€å•çš„å“ˆå¸Œå‡½æ•°å®ç°
        int result = 1;
        for (char c : value.toCharArray()) {
            result = seed * result + c;
        }
        return result;
    }
}
```

**åº”ç”¨åœºæ™¯**ï¼š
1. **é‡å¤é—®é¢˜è¿‡æ»¤**ï¼šé¿å…å›ç­”é‡å¤é—®é¢˜
2. **æ•æ„Ÿè¯æ£€æµ‹**ï¼šå¿«é€Ÿæ£€æµ‹æ•æ„Ÿå†…å®¹
3. **ç¼“å­˜ç©¿é€é˜²æŠ¤**ï¼šé˜²æ­¢æ¶æ„æŸ¥è¯¢

**æ„é€ å‚æ•°**ï¼š
- é¢„æœŸå…ƒç´ æ•°é‡ï¼ˆnï¼‰
- å¯æ¥å—è¯¯åˆ¤ç‡ï¼ˆpï¼‰
- å“ˆå¸Œå‡½æ•°æ•°é‡ï¼ˆkï¼‰
- æ¯”ç‰¹æ•°ç»„å¤§å°ï¼ˆmï¼‰

## ğŸ’¡ çº¿æ®µåŒ…å«åˆ¤æ–­ç®—æ³•

### ç®—æ³•å®ç°
```java
import java.util.*;

public class SegmentCoverage {
    
    static class Interval {
        int start;
        int end;
        Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }
    
    /**
     * åˆ¤æ–­ç›®æ ‡çº¿æ®µæ˜¯å¦åœ¨åˆå¹¶åçš„åŒºé—´å†…
     */
    public static boolean isCovered(Interval[] intervals, Interval target) {
        if (intervals == null || intervals.length == 0) {
            return false;
        }
        
        // 1. æŒ‰èµ·ç‚¹æ’åº
        Arrays.sort(intervals, (a, b) -> Integer.compare(a.start, b.start));
        
        // 2. åˆå¹¶åŒºé—´
        List<Interval> merged = new ArrayList<>();
        Interval current = intervals[0];
        
        for (int i = 1; i < intervals.length; i++) {
            if (intervals[i].start <= current.end) {
                // æœ‰é‡å ï¼Œåˆå¹¶
                current.end = Math.max(current.end, intervals[i].end);
            } else {
                // æ— é‡å ï¼Œæ·»åŠ å½“å‰åŒºé—´
                merged.add(current);
                current = intervals[i];
            }
        }
        merged.add(current);
        
        // 3. æ£€æŸ¥ç›®æ ‡æ˜¯å¦åœ¨æŸä¸ªåˆå¹¶åŒºé—´å†…
        for (Interval interval : merged) {
            if (target.start >= interval.start && target.end <= interval.end) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * ä¼˜åŒ–ç‰ˆæœ¬ï¼šä¸éœ€è¦æ˜¾å¼åˆå¹¶ï¼Œç›´æ¥éå†åˆ¤æ–­
     */
    public static boolean isCoveredOptimized(Interval[] intervals, Interval target) {
        Arrays.sort(intervals, (a, b) -> Integer.compare(a.start, b.start));
        
        int currentCoverage = Integer.MIN_VALUE;
        
        for (Interval interval : intervals) {
            if (interval.start > target.start && currentCoverage < target.start) {
                // å‡ºç°æ–­å±‚ï¼Œæ— æ³•è¦†ç›–
                return false;
            }
            
            if (interval.start <= currentCoverage) {
                // æ‰©å±•è¦†ç›–èŒƒå›´
                currentCoverage = Math.max(currentCoverage, interval.end);
            } else {
                // æ–°çš„åŒºé—´æ®µ
                currentCoverage = interval.end;
            }
            
            if (currentCoverage >= target.end) {
                return true;
            }
        }
        
        return false;
    }
    
    // æµ‹è¯•ä»£ç 
    public static void main(String[] args) {
        Interval[] intervals = {
            new Interval(1, 3),
            new Interval(2, 6),
            new Interval(8, 10),
            new Interval(15, 18)
        };
        
        Interval target1 = new Interval(2, 5);  // åº”è¯¥è¿”å›true
        Interval target2 = new Interval(12, 16); // åº”è¯¥è¿”å›false
        
        System.out.println("Target1 covered: " + isCovered(intervals, target1));
        System.out.println("Target2 covered: " + isCovered(intervals, target2));
    }
}
```

**ç®—æ³•åˆ†æ**ï¼š
- æ—¶é—´å¤æ‚åº¦ï¼šO(n log n)ï¼Œä¸»è¦æ¥è‡ªæ’åº
- ç©ºé—´å¤æ‚åº¦ï¼šO(1) æˆ– O(n)ï¼Œå–å†³äºæ˜¯å¦æ˜¾å¼åˆå¹¶
- å…³é”®ç‚¹ï¼šæ’åºåçº¿æ€§æ‰«æï¼Œç»´æŠ¤å½“å‰è¦†ç›–èŒƒå›´

è¿™ä¸ªè§£ç­”æ¶µç›–äº†æ‰€æœ‰æŠ€æœ¯é—®é¢˜ï¼Œå±•ç¤ºäº†ç³»ç»Ÿçš„æ¶æ„è®¾è®¡èƒ½åŠ›ã€æŠ€æœ¯æ·±åº¦å’Œé—®é¢˜è§£å†³èƒ½åŠ›ã€‚

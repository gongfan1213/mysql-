看到你的复盘，我非常理解你的感受。这场面试官非常务实，问的都是生产环境中真正会遇到的问题和实操技能。这恰恰是区分“背题家”和“有经验的开发者”的关键。别灰心，这次暴露出的问题非常宝贵，让我们把它们一个个彻底攻克。

---

### **1. & 2. 数据库隔离级别：为什么选择读已提交（RC）？**

**问题1答案**：互联网公司最常用的MySQL隔离级别是**读已提交（Read Committed, RC）**，其次是可重复读（RR）。**Oracle的默认级别就是RC**。很多公司选择RC是因为在性能和并发度上的一个权衡。

**问题2答案：为什么选择RC？相比RR有什么好处？**

这是一个非常有深度的问题，面试官在考察你对数据库内部机制的理解。

| 方面 | **读已提交（RC）** | **可重复读（RR）** |
| :--- | :--- | :--- |
| **实现原理** | 每次执行语句都会生成一个新的**Read View**（快照）。 | 只在事务开始时生成一个Read View，整个事务期间都用它。 |
| **并发性能** | **更高**。锁的持有时间更短（语句级）。 | 更低。锁（特别是间隙锁）的持有时间更长（事务级），并发冲突更多。 |
| **幻读问题** | **存在幻读**。 | 通过**间隙锁（Gap Lock）** 解决幻读。 |
| **二进制日志** | 使用**statement**格式的binlog时，主从复制可能出问题（因为两次读结果不同）。 | 无此问题，因此是MySQL的默认级别。 |
| **优点** | **死锁更少**：因为不持有间隙锁，大大降低了死锁的概率。**性能更好**：锁竞争更少。 | **数据一致性视图**：保证事务内看到的数据一致。 |
| **缺点** | **不可重复读**：同一事务内两次相同的查询可能得到不同结果。 | **性能开销**：额外的间隙锁开销，更容易发生锁等待和死锁。 |

**结论**：很多互联网公司选择**RC + `row`格式的binlog**。因为：
1.  在**RC**级别下，**没有了间隙锁**，大大减少了**死锁**的发生，提高了数据库的**并发写入性能**。
2.  配合**`row`**格式的binlog，可以解决statement格式下的主从一致性问题。
3.  对于“不可重复读”业务场景，通常影响不大（比如一个事务内查询两次账户余额，余额变了通常是正常的），或者可以在应用层通过乐观锁等方式解决。

**高分回答**：“我们公司使用的是读已提交（RC）隔离级别。主要是因为RC级别下MySQL不会使用间隙锁（Gap Lock），这极大地减少了死锁发生的概率，提升了数据库的并发处理能力，这对于高并发的互联网业务非常重要。虽然牺牲了可重复读的隔离性，但在这个级别下发生的不可重复读问题，对于我们的业务场景来说通常是可以接受的，或者我们会在应用层通过版本号等机制来规避。”

---

### **3. & 4. SQL优化与事务**

#### **3. 如何定位优化的慢SQL？**
你的回答方向是对的，可以补充得更体系化：
1.  **定位**：
    - **慢查询日志（Slow Query Log）**：这是最直接有效的方法。MySQL可以设置一个阈值（如`long_query_time = 1s`），执行时间超过这个阈值的SQL都会被记录下来。
    - **监控平台**：如你所说，通过APM（Application Performance Management）工具（如SkyWalking, Pinpoint）或云平台监控，可以快速发现慢SQL和其调用链。
2.  **分析**：
    - **`EXPLAIN`**：分析SQL的执行计划，这是必做步骤。关键看：
        - `type`：访问类型，至少要是`range`，最好达到`ref`或`const`。
        - `key`：是否使用了索引。
        - `rows`：预估扫描行数，越小越好。
        - `Extra`：注意是否有`Using filesort`（需要优化排序）或`Using temporary`（需要创建临时表）。
    - **`SHOW PROFILE`**（已过时）或**Performance Schema**：用于分析SQL执行各个阶段的耗时。

#### **4. 刷库时事务是怎么考虑的？**
“刷库”通常指大批量的数据更新（如数据迁移、批量处理）。这里核心考察的是**大事务**的风险和处理。
- **风险**：
    1.  **锁持有时间长**：可能导致其他事务长时间阻塞，甚至死锁。
    2.  **Undo Log膨胀**：回滚段会变得非常大，影响性能。
    3.  **主从延迟**：一个大事备会产生一个很大的binlog事件，导致从库应用变慢。
- **如何做**：
    1.  **避免大事务**：将大批量操作**拆分成多个小批次**（如每次处理1000条），每批用一个独立的事务提交。
    2.  **在业务低峰期进行**。
    3.  **暂时降低隔离级别**：在批量更新时，可以将会话的隔离级别暂时降到**读未提交**，以避免获取不必要的锁。

---

### **场景结合八股**

#### **1. redo log 和 binlog 的写入时机**
- **redo log（重做日志）**：
    - **写入时机**：事务执行过程中，SQL语句修改数据时，就会先写到redo log buffer中。
    - **刷盘策略**：由`innodb_flush_log_at_trx_commit`参数控制。
        - `=1`（默认）：**每次事务提交时**都会将redo log buffer的内容**fsync**到磁盘。最安全，性能也相对最差。
        - `=0`：每秒刷一次。
        - `=2`：每次提交只写到操作系统的页面缓存，每秒fsync一次。
- **binlog（归档日志）**：
    - **写入时机**：事务执行过程中，SQL语句会先写到binlog cache中。
    - **刷盘策略**：由`sync_binlog`参数控制。
        - `=1`：**每次事务提交时**都会将binlog **fsync**到磁盘。保证主从数据一致性。
        - `=N`：每N次事务提交fsync一次。

**“两阶段提交”**：为了保证redo log和binlog的逻辑一致性，在事务提交时，采用两阶段提交：
1.  **prepare阶段**：将redo log写入磁盘，并标记为prepare状态。
2.  **commit阶段**：将binlog写入磁盘。
3.  **最终commit**：在redo log上打上commit标记。

#### **2. & 3. & 4. CPU/内存飙高 & JVM状态观察（Linux/JVM实操）**
这是典型的运维排查问题，需要记住标准流程和命令。

**2. CPU突然飙高如何处理？**
1.  **定位高CPU进程**：`top` -> 按`P`（CPU排序），找到最耗CPU的进程PID。
2.  **定位高CPU线程**：`top -Hp <PID>` -> 按`P`，找到最耗CPU的线程TID（十进制）。
3.  **线程ID转换**：`printf "%x\n" <TID>` 将TID转换为十六进制（nid）。
4.  **分析线程栈**：`jstack <PID> | grep -A 20 <nid>` 查看这个线程的堆栈信息，定位到正在执行的代码。
    - **常见原因**：死循环、频繁GC、加密解密计算等。

**3. 内存突然飙高如何处理？**
1.  **定位高内存进程**：`top` -> 按`M`（内存排序）。
2.  **判断是JVM还是其他**：如果是JVM，用JVM工具分析。
3.  **查看JVM内存概况**：`jstat -gcutil <PID> 1s`，观察各个内存区域（Eden, Old, Meta等）的使用率和GC次数。如果Old区一直很高且Full GC后回收不多，可能**内存泄漏**。
4.  **Dump堆内存**：`jmap -dump:format=b,file=heap.hprof <PID>` （对线上服务影响大，谨慎使用）。
5.  **使用MAT/JProfiler等工具分析heap.hprof文件**，找到泄漏的对象和引用链。

**4. 观察JVM状态 & 日志**
- **JVM日志**：通过启动参数配置，通常保存在应用的工作目录或`/logs`目录下。
    - **GC日志**：最重要的日志。添加参数：
      `-Xloggc:/path/to/gc.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps`
    - **输出内容**：每次GC的时间、类型、耗时、内存回收前后的大小。
- **观察状态命令**：
    - `jps`：查看所有Java进程。
    - `jinfo`：查看和修改JVM参数。
    - `jstack`：查看线程栈，诊断死锁、死循环。
    - `jmap`：查看内存使用，生成堆转储快照。
    - `jstat`：实时查看GC和类加载情况。

#### **5. JVM垃圾回收算法 & G1回收器**
- **垃圾回收算法**：
    1.  **标记-清除**：产生碎片。
    2.  **复制**：无碎片，但浪费空间。
    3.  **标记-整理**：无碎片，但效率低。
    4.  **分代收集**：JVM采用的综合策略，将堆分为新生代（Young）和老年代（Old），对不同代使用不同的算法。
- **G1垃圾回收器**：
    - **目标**：延迟可控的情况下获得高吞吐量。
    - **特点**：将堆划分为多个大小相等的**Region**，不再物理隔离新生代和老年代。G1跟踪各个Region的“价值”（回收所能获得的空间以及所需时间），优先回收价值最大的Region，故名Garbage-First。
    - **工作流程**：
        1.  **Young GC**：Eden区满时触发，采用复制算法。
        2.  **Mixed GC**：老年代占用达到阈值（`InitiatingHeapOccupancyPercent`）时触发，不仅回收Young区，还会**并发**地回收一部分价值最大的Old区。

---

### **总结与行动计划**

这次面试给你指出了一个非常明确的努力方向：**从“知道”到“会用”**。

**你的行动计划**：
1.  **搭建一个本地MySQL环境**：亲自设置不同的隔离级别，打开慢查询日志，用`EXPLAIN`分析几条SQL，感受一下区别。
2.  **在自己的电脑上演练排查命令**：写一个死循环程序，然后用`top`、`jstack`去定位它。写一个内存泄漏程序，用`jmap`和MAT去分析它。
3.  **深度思考项目**：针对你的项目，自己问自己：“如果CPU高了怎么办？如果内存泄漏了怎么排查？数据库死锁了怎么分析？”并把答案想清楚。
4.  **理解而不是背诵**：对于GC、日志、事务等概念，多问几个为什么，直到你能把它讲清楚为止。

这些问题都是高级工程师的日常，掌握它们你的竞争力会提升一个巨大的档次。这次面试不是失败，而是一次极其有价值的“能力体检”。加油！

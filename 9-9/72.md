好的，这是一次非常具有技术深度的面试，明显在考察你对高并发场景下业务逻辑严谨性、数据一致性和系统设计的理解。我们来逐一分析和解答这些问题。

---

### **1. Lua脚本里面进行了哪几步操作？**
**面试官意图**：考察你是否理解Redis Lua脚本在解决高并发问题中的核心作用——**原子性**。秒杀场景中，库存扣减、资格判断等操作必须在一次原子操作中完成。

**标准解答**：
“在黑马点评的秒杀场景中，Lua脚本主要进行了以下几步原子性操作：
1.  **校验库存**：通过`get`命令查询秒杀商品的库存值。
2.  **判断用户是否已购买**：查询当前用户是否已经存在于该商品的秒杀成功集合（Set）中。这是为了防止同一用户重复购买。
3.  **执行扣减**：如果库存大于0且用户未曾购买，则执行：
    *   `decr`命令将库存减1。
    *   `sadd`命令将用户ID加入到代表‘已购买用户’的Set中。
4.  **返回结果**：根据上述操作的成功与否，返回不同的结果（如1代表成功，0代表库存不足，2代表重复购买）。

将多个Redis调用放在一个Lua脚本中执行，可以确保这些操作是原子性的，不会被打断，从而防止了超卖和一人多买的问题。”

---

### **2. 异步下单流程中下单失败了怎么办？怎么返回给前端**
**面试官意图**：考察你对异步流程中异常处理的思考，特别是最终一致性的保障。

**标准解答**：
“这是一个非常关键的问题。在我们的异步下单流程中，前端在预检（Lua脚本）成功后就会收到‘排队中’的响应，真正的订单创建是在MQ消费者中执行的。

*   **如果下单失败**（例如，创建订单时发现数据库异常、扣减库存失败等）：
    1.  **消费者侧重试**：消费者会抛出异常，导致消息消费失败。消息队列（如RabbitMQ）会进行**重试**（可以设置重试次数）。
    2.  **死信队列（DLQ）兜底**：如果重试多次后依然失败，消息会被投入死信队列。此时需要有**告警机制**通知运维或开发人员，进行**人工干预或脚本补偿**。例如，检查失败原因，手动将预扣的库存和用户购买资格（Redis中的数据）恢复，并通知用户下单失败。

*   **如何返回给前端**：
    *   前端在收到‘排队中’的响应后，会**轮询**一个接口来查询最终下单结果。
    *   这个查询接口会去查**订单数据库**。如果订单创建成功，则返回成功；如果订单一直不存在（比如经过一定超时时间），结合后端可能发生的补偿动作，最终可以给前端返回一个‘下单失败，已恢复资格’的结果。

**核心思想**：异步流程无法实时返回最终结果。前端通过异步轮询获取结果，后端通过重试+死信队列+人工兜底来保证数据的最终一致性。”

---

### **3. 预扣减完成后，用户马上要付款了，而真正的订单还没创建怎么办？**
**面试官意图**：考察你对流程中“状态”的管理和对用户行为的理解。

**标准解答**：
“这是一个非常好的边界情况。我们的系统需要明确区分不同的状态：
1.  **订单状态**：在异步下单流程中，订单有一个‘创建中’的状态。只有MQ消费者成功在数据库创建订单后，订单状态才会变为‘待支付’。
2.  **前端交互逻辑**：在用户点击‘立即付款’时，前端不能直接跳转到支付页面。
    *   前端应该先调用一个**检查接口**，查询订单的最终状态。
    *   如果订单尚处于‘创建中’，则给用户一个友好提示，如‘订单正在确认中，请稍后再试’。
    *   如果订单已成功创建且状态为‘待支付’，则正常跳转支付。
    *   如果查询发现订单创建失败，则告知用户失败原因。

这样设计可以防止用户在前端进行无效操作，体验更好，逻辑也更严谨。”

---

### **4. 你目前来看，黑马点评的秒杀下单业务中，可能还有那些漏洞？**
**面试官意图**：考察你的技术批判性思维和对生产环境复杂性的认知。

**标准解答**：
“即使完成了基本功能，在一个生产级的秒杀系统中，可能还存在以下漏洞或可优化点：
1.  **库存超售的极端情况**：虽然Lua脚本解决了Redis层面的超售，但如果数据库最终扣减库存时采用`update stock set stock = stock - 1`的方式，**数据库库存可能被扣成负数**。应该在SQL中加上条件：`update stock set stock = stock - 1 where stock > 0`。Lua脚本和数据库双校验才更保险。
2.  **恶意请求与安全**：
    *   **刷单**：脚本小子可以通过大量不同账号来抢购。缺乏风控系统（IP限流、设备指纹、用户行为分析）。
    *   **秒杀接口暴露**：秒杀接口可能被直接抓包调用，绕过前端逻辑。需要做接口防刷（令牌、签名）。
3.  **MQ消息堆积**：如果下单流量远大于消费者处理能力，会导致消息大量堆积。需要考虑**消费者集群**的能力和**队列容量**限制，避免拖垮整个MQ。
4.  **数据一致性问题**：如果消费者下单成功后，在后续步骤（如更新缓存）时失败，可能导致缓存和数据库数据不一致。
5.  **Redis宕机风险**：整个流程强依赖Redis，如果Redis宕机，服务完全不可用。需要考虑Redis**高可用方案**（主从、哨兵、集群）。”

---

### **5. SQL创建学生信息表**
**面试官意图**：考察你的SQL设计能力，以及对**幂等性、高性能和可扩展性**的理解。

**标准解答**：
“根据要求，我会这样设计（以MySQL为例）：
```sql
CREATE TABLE `t_student_info` (
  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `student_id` varchar(20) NOT NULL COMMENT '学号，业务唯一标识',
  `name` varchar(50) NOT NULL COMMENT '姓名',
  `id_card` varchar(18) NOT NULL COMMENT '身份证号',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `version` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '乐观锁版本号',
  `is_deleted` tinyint(1) NOT NULL DEFAULT '0' COMMENT '逻辑删除标志（0:未删除, 1:已删除）',
  PRIMARY KEY (`id`), -- 聚簇索引，保证物理存储有序
  UNIQUE KEY `uk_student_id` (`student_id`), -- 唯一索引，保证学号幂等
  UNIQUE KEY `uk_id_card` (`id_card`), -- 唯一索引，保证身份证号幂等
  KEY `idx_create_time` (`create_time`) -- 普通索引，用于按时间统计
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学生信息表';
```

**设计理由**：
*   **幂等**：通过`uk_student_id`和`uk_id_card`两个**唯一索引**，插入重复学号或身份证号的记录时会失败，从数据库层面保证了幂等性。
*   **高并发性能**：
    *   使用`InnoDB`引擎支持行级锁和高并发。
    *   使用**自增主键**`id`，避免页分裂，提高写入性能。
    *   使用**乐观锁**`version`字段，在更新时进行并发控制，性能优于悲观锁。
*   **统计能力**：
    *   增加了`create_time`字段，并为其建立了索引`idx_create_time`，可以高效地按时间维度进行统计（如：每日新增学生数）。
    *   `is_deleted`实现了逻辑删除，便于进行历史数据统计，而不会漏掉数据。”

---

### **6. Springboot中用到哪些设计模式？**
**面试官意图**：考察你是否阅读过SpringBoot源码或对其设计思想有深入了解。

**标准解答**：
“SpringBoot大量使用了设计模式，其中主要包括：
1.  **工厂模式**：`BeanFactory`和`ApplicationContext`是工厂模式的代表，负责创建和管理所有Bean对象。
2.  **单例模式**：Spring容器中的Bean默认都是单例的，有效地节省了资源。
3.  **模板方法模式**：`JdbcTemplate`, `RedisTemplate`, `RestTemplate`等大量`Template`类，它们定义了操作的骨架，将一些步骤延迟到子类或由使用者回调实现，简化了操作。
4.  **观察者模式/发布-订阅模式**：Spring的**事件驱动模型**`ApplicationEvent`和`ApplicationListener`就是典型的观察者模式实现。
5.  **策略模式**：在资源加载、数据访问等多种场景中都有应用。例如，`PropertySourceLoader`接口有不同的策略实现（如`PropertiesPropertySourceLoader`和`YamlPropertySourceLoader`）来加载不同格式的配置文件。
6.  **自动配置中的条件注解**（如`@ConditionalOnClass`）：这可以看作是一种**策略模式**的变体，根据不同的条件选择不同的配置策略。”

---

### **7. 手撕：最大波峰波谷值**
**题目分析**：此题可能描述不清，通常有两种理解：
1.  **求最大振幅**：即数组中最大的 `|波峰值 - 波谷值|`。
2.  **求最大的波峰值和波谷值**：即整个数组中最大的元素（波峰）和最小的元素（波谷）。

由于是“最大波峰波谷值”，更可能是第一种理解（求最大振幅）。但为了安全，可以向面试官确认。这里按第一种理解解答。

**思路**：遍历数组，找出所有的波峰和波谷，然后计算相邻的波峰和波谷的差值，取绝对值最大的一个。

**代码实现（求最大振幅）**：
```java
public int maxAmplitude(int[] prices) {
    if (prices == null || prices.length < 2) {
        return 0;
    }
    
    int n = prices.length;
    int maxDiff = 0;
    // 寻找波峰和波谷
    int i = 0;
    while (i < n - 1) {
        // 找波谷：一直下降到最低点
        while (i < n - 1 && prices[i] >= prices[i + 1]) {
            i++;
        }
        int valley = prices[i];
        
        // 找波峰：一直上升到最高点
        while (i < n - 1 && prices[i] <= prices[i + 1]) {
            i++;
        }
        int peak = prices[i];
        
        // 计算当前波峰波谷的差值，并更新最大差值
        int currentDiff = Math.abs(peak - valley);
        if (currentDiff > maxDiff) {
            maxDiff = currentDiff;
        }
        // i++ 移动到下一个点开始寻找下一对
        i++;
    }
    return maxDiff;
}
```

**如果面试官的意思是第二种（求最大值和最小值）**，那题就非常简单：
```java
public void findPeakAndValley(int[] arr) {
    if (arr == null || arr.length == 0) {
        return;
    }
    int peak = Integer.MIN_VALUE;
    int valley = Integer.MAX_VALUE;
    for (int num : arr) {
        if (num > peak) peak = num;
        if (num < valley) valley = num;
    }
    System.out.println("最大波峰值: " + peak);
    System.out.println("最大波谷值: " + valley);
}
```

**面试时一定要先和面试官把题目含义确认清楚！**

---

### **总结与建议**
这次拼多多的面试难度很高，集中在**高并发场景下的细节、边界处理和系统设计**，非常贴近实际业务。
*   **你的优势**：如果能回答上大部分，说明你对秒杀场景有很深的理解。
*   **待加强点**：需要对系统的**漏洞、边界 case 和补偿机制**有更深入的思考。对于设计模式和SQL设计，不仅要知其然，还要知其所以然。

建议多学习大型互联网公司的海量数据处理、高并发系统设计的相关文章和案例，提升自己的技术视野和设计能力。祝你接下来面试顺利！

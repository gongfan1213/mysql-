# 为什么要有 cluster 集群？
有位伙伴面试了字节，被问到“redis的cluster集群原理，客户端是怎样知道该访问哪个分片的”，以下从多个维度展开分析，帮助理解Redis Cluster集群的核心逻辑：


## 1. 为什么需要Redis Cluster？
哨兵模式基于主从模式实现了读写分离与自动故障切换，提升了系统可用性，但存在明显缺陷：**每个节点存储的数据完全一致，既浪费内存，也无法实现在线扩容**。

为此，Redis 3.0版本引入了Redis Cluster集群（切片集群的官方实现方案），其核心价值在于：
- **数据分片存储**：每台Redis节点存储不同内容，解决单实例数据量过大导致的性能问题（例如单实例存储15G数据时，RDB持久化的fork操作耗时会随数据量激增，影响响应速度）；
- **支持在线扩容**：通过分片机制轻松扩展存储容量；
- **兼顾高可用**：同时提供数据复制和故障转移功能，保障服务稳定性。

> 补充概念：切片集群是分布式存储的通用思路，Redis Cluster是Redis官方针对切片集群的具体实现方案。例如要存储15G数据，用3台实例组成切片集群，每台仅需存储5G，大幅降低单实例压力。


## 2. 客户端是怎样知道该访问哪个分片的？（哈希槽）
Redis Cluster通过**哈希槽（Hash Slot）** 建立数据与实例的映射关系，具体规则如下：
1. **哈希槽总量**：切片集群固定划分为16384个槽（slot）；
2. **数据映射逻辑**：对每个键值对的key，先用CRC16算法计算出16bit的哈希值，再对16384取模，结果即为该key所属的哈希槽；
3. **节点分工**：集群中的每个节点负责一部分哈希槽。例如3节点集群的常见分配方式：
   - 节点A：负责0~5460号哈希槽；
   - 节点B：负责5461~10922号哈希槽；
   - 节点C：负责10923~16383号哈希槽。


## 3. 实例上没有对应数据，会怎么样？（MOVED重定向和ASK重定向）
客户端向Redis实例发送请求时，若实例不负责该key所属的哈希槽，会通过重定向指引客户端访问正确节点，具体分两种场景：

### 3.1 MOVED重定向
- **触发场景**：客户端访问的哈希槽，永久属于其他节点（非数据迁移场景）；
- **处理逻辑**：目标实例返回`MOVED`错误，错误信息中包含该哈希槽所属节点的IP和端口，客户端后续会直接向新节点发送请求（部分客户端会缓存哈希槽与节点的映射关系，减少后续重定向次数）。


### 3.2 ASK重定向
- **触发场景**：集群伸缩（扩容/缩容）导致哈希槽迁移，客户端访问的key已从“源节点”迁移到“目标节点”，但哈希槽的归属权尚未正式变更；
- **处理逻辑**：源节点返回`ASK`错误，指引客户端向目标节点发送请求。客户端需先向目标节点发送`ASKING`命令（告知目标节点“本次请求是重定向过来的临时访问”），再执行具体的读写操作。

> 节点处理请求的完整流程：
> 1. 计算key所属哈希槽，检查是否由自身负责；
> 2. 若不负责，返回MOVED重定向；
> 3. 若负责但key不存在，检查该哈希槽是否正在迁移（MIGRATING）；
> 4. 若正在迁移，返回ASK重定向；
> 5. 若未迁移，检查哈希槽是否在导入（IMPORTING）：有ASKING标记则直接操作，无则返回MOVED重定向。


## 4. 各个节点之间是怎么通信的呢？（Gossip协议）
Redis Cluster节点通过**Gossip协议**实现信息同步，核心逻辑是“节点周期性随机向其他节点传播信息，直到所有节点信息一致”，具体细节如下：

### 4.1 Gossip协议核心思想
一个节点要分享信息（如节点故障、槽迁移、新节点加入）时，会周期性从集群中随机选择`k`个节点（`k`称为fanout）传递信息，收到信息的节点会重复此操作，最终实现全集群信息同步。

### 4.2 关键消息类型
- **meet消息**：新节点加入时，由现有节点向新节点发送，通知其加入集群；通信完成后，新节点会参与后续的ping/pong消息交换。
- **ping消息**：节点每秒向其他节点发送，包含自身已知的2个节点的地址、槽信息、状态、最后通信时间等，用于维护节点存活状态和信息同步。
- **pong消息**：收到ping/meet消息后的响应，包含自身已知的节点信息，用于确认通信正常。
- **fail消息**：节点判定另一节点下线时，向全集群广播，其他节点收到后会将目标节点标记为下线。

### 4.3 通信端口
节点通过**集群总线（cluster bus）** 通信，端口号为“对外服务端口+10000”（例如服务端口6379，通信端口为16379），采用二进制协议传输，效率更高。


## 5. 集群内节点出现故障怎么办？（故障转移）
Redis Cluster通过“故障发现→故障恢复”的流程实现高可用，具体分为以下步骤：

### 5.1 故障发现：主观下线与客观下线
- **主观下线（PFail）**：单个节点认为另一节点不可用（如ping消息超时），仅代表该节点的单独判断，可能存在误判（如网络波动）。
- **客观下线（Fail）**：多个节点（持有槽的主节点）均认为某节点不可用，达成共识后的最终判定。  
  判定逻辑：若节点A标记节点B为主观下线，会将此状态传播给其他节点；当持有槽的主节点中，超过半数认为节点B下线时，节点B被标记为客观下线。

### 5.2 故障恢复：从节点晋升为主节点
若下线节点是主节点，需从其从节点中选一个晋升为新主节点，流程如下：
1. **资格检查**：筛选出“与故障主节点复制同步正常、网络连接正常”的从节点，排除不具备晋升条件的节点。
2. **准备选举时间**：通过“故障主节点下线时间+从节点优先级”计算选举触发时间（优先级越高，触发时间越早，优先获得选举机会）。
3. **发起选举**：到选举时间后，从节点向集群中所有持有槽的主节点发送选举请求。
4. **选举投票**：持有槽的主节点为从节点投票，得票数超过半数的从节点晋升为新主节点，接管故障主节点的所有哈希槽。


## 6. 加餐：为什么Redis Cluster的Hash Slot是16384？
CRC16算法可生成16bit哈希值（共65536个可能值），但Redis Cluster选择16384（2^14）个哈希槽，核心原因是**平衡内存开销与哈希碰撞概率**：

### 6.1 节省内存与网络开销
节点发送心跳包时，需携带“自身负责的哈希槽”信息，存储格式为`unsigned char slots[REDIS_CLUSTER_SLOTS/8]`（1个字节存储8个槽的状态）：
- 若用65536个槽：占用空间=65536/8/1024=8KB；
- 若用16384个槽：占用空间=16384/8/1024=2KB；  
  单个节点节省6KB内存，100节点集群可节省600KB，降低心跳包传输的网络开销。

### 6.2 满足集群规模需求
Redis Cluster主节点数量通常不超过1000（超过会导致网络拥堵），16384个槽足以支撑“1000节点均分槽位”（每个节点约16个槽），无需更多槽位。

### 6.3 为什么不选更小的槽位（如8192）？
8192个槽仅需1KB存储，但会增加哈希碰撞概率：
- CRC16哈希值的理论碰撞概率为1/65536，实际概率更高；
- 若槽位为8192，200节点集群下，每40个不同key就可能出现一次槽分配冲突；400节点时，每20个key就可能冲突；
- 1KB比2KB的内存节省有限，但碰撞概率大幅上升，性价比低，因此16384是更优选择。

> 补充：Redis计算key所属槽位时，用`crc16(key) & 0x3FFF`（0x3FFF=16383）代替`crc16(key) % 16384`，因为在不溢出的情况下，`x % 2^n = x & (2^n - 1)`，效率更高。


## 7. 总结
1. **Redis Cluster的核心价值**：解决哨兵模式“数据冗余、无法扩容”的问题，通过数据分片支撑大数据量存储，同时兼顾高可用；
2. **核心机制**：
   - 哈希槽（16384个）：建立key与节点的映射，实现数据分片；
   - Gossip协议：节点间同步信息，支撑故障发现与集群管理；
   - 故障转移：通过主观/客观下线判定+从节点晋升，保障服务不中断；
3. **客户端访问逻辑**：本地缓存槽与节点的映射关系，通过CRC16(key)%16384定位槽位，再访问对应节点，遇到重定向时更新映射关系。

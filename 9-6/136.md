### 淘天一面面试题目详细解答

#### 1. 自我介绍
（根据个人情况准备，突出技术栈、项目经验和亮点）

#### 2. 实习介绍+追问
（根据个人实习经历回答，重点说明技术难点和解决方案）

#### 3. Redis是单线程还是多线程的？它的I/O模型是哪种？
- **单线程/多线程**：Redis 6.0之前是单线程的，6.0之后引入了多线程，但多线程仅用于处理网络I/O，核心命令执行仍然是单线程。
- **I/O模型**：Redis使用**I/O多路复用**模型（如epoll、kqueue），通过一个线程监听多个套接字，实现高并发。

#### 4. 集群模式下，写一个数据怎么确定放在哪个节点？
- Redis Cluster使用**哈希槽（Hash Slot）** 机制，共有16384个槽位。
- 每个键通过CRC16算法计算哈希值，再对16384取模，得到对应的槽位。
- 每个节点负责一部分槽位，客户端根据槽位定位到具体节点。

#### 5. Redis的内存淘汰策略有哪些？你在项目里怎么设置的？
- **淘汰策略**：
  - `noeviction`：不淘汰，写满时报错。
  - `allkeys-lru`：从所有键中淘汰最近最少使用的。
  - `volatile-lru`：从过期键中淘汰最近最少使用的。
  - `allkeys-random`：随机淘汰所有键。
  - `volatile-random`：随机淘汰过期键。
  - `volatile-ttl`：淘汰剩余寿命最短的键。
- **项目设置**：根据业务场景选择，例如高频读写的缓存系统常用`allkeys-lru`。

#### 6. RocketMQ如何保证消息不丢失？是用事务消息吗？
- **保证不丢失**：
  - 生产者：使用同步发送+重试机制，或事务消息。
  - Broker：同步刷盘（flushDiskType=SYNC_FLUSH）+主从同步（同步复制）。
  - 消费者：手动提交offset，确保消费成功后再提交。
- **事务消息**：用于分布式事务场景，保证本地事务和消息发送的原子性。

#### 7. 如果我在本地事务里先改数据库，最后发消息，根据消息发送成功与否提交或回滚事务，这能达到事务消息的效果吗？有什么区别？
- **不能完全达到**：
  - 如果消息发送失败，事务回滚，但可能因网络超时导致消息已发送成功，事务却回滚，造成数据不一致。
- **区别**：
  - RocketMQ事务消息通过**两阶段提交**解决此问题：先发半消息，执行本地事务，再根据本地事务状态提交或回滚消息。

#### 8. 切面相关的注解？如果多个切面作用于同一个，怎么决定执行顺序？
- **注解**：`@Aspect`、`@Before`、`@After`、`@Around`等。
- **执行顺序**：
  - 实现`Ordered`接口或使用`@Order`注解，值越小优先级越高。
  - 默认顺序不确定，需显式指定。

#### 9. MySQL的事务隔离级别从低到高说一下。默认是哪个？
- **隔离级别**（低→高）：
  1. 读未提交（Read Uncommitted）
  2. 读已提交（Read Committed）
  3. 可重复读（Repeatable Read）
  4. 串行化（Serializable）
- **默认级别**：可重复读（Repeatable Read）。

#### 10. 可重复读场景下，不用SELECT FOR UPDATE，一个账户余额100，A、B两事务同时开始，都先读到100。B事务减20后提交，A事务加20后提交。最终余额是多少？结果会符合预期吗？
- **最终余额**：100（初始100 - 20 + 20 = 100）。
- **是否符合预期**：不符合，因为A事务提交时会覆盖B的修改（**丢失更新**问题）。
- **解决方案**：使用悲观锁（SELECT FOR UPDATE）或乐观锁（版本号机制）。

#### 11. volatile关键字能保证线程安全的哪些特性？可见性是怎么实现的？
- **保证特性**：可见性、有序性（禁止指令重排序），**不保证原子性**。
- **可见性实现**：
  - 修改volatile变量时，强制将工作内存中的值刷新到主内存。
  - 读取volatile变量时，强制从主内存重新加载最新值。

#### 12. 保证原子性一般怎么设计？有哪些工具？
- **设计方法**：
  - 使用锁（synchronized、ReentrantLock）。
  - 使用原子类（AtomicInteger等）。
  - 使用CAS（Compare And Swap）操作。
- **工具**：
  - `java.util.concurrent.atomic`包下的原子类。
  - `synchronized`关键字。
  - `ReentrantLock`等锁工具。

#### 13. 讲一下AQS，它是怎么实现多线程安全的？
- **AQS（AbstractQueuedSynchronizer）**：是Java并发包中锁和同步器的框架（如ReentrantLock、Semaphore）。
- **实现原理**：
  - 使用一个volatile的int状态变量（state）表示锁状态。
  - 通过CAS操作修改state，保证原子性。
  - 使用FIFO队列管理等待线程，实现公平/非公平锁。

#### 14. 还有没有其他项目经历？平时是怎么进行学习的？
- **项目经历**：根据个人情况补充。
- **学习方式**：
  - 官方文档、技术博客、开源项目。
  - 动手实践，写Demo和项目。
  - 参与技术社区和讨论。

---

**反思建议**：  
- 加强Redis集群、消息队列事务消息、MySQL隔离级别与锁机制的深度理解。  
- 多练习并发编程场景题，熟悉volatile、AQS等底层原理。  
- 项目描述需突出技术难点和个人贡献。

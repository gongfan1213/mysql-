好的，作为一位资深Java开发工程师，我将为您系统性地梳理和解答这套拼多多服务端开发面试题。我将首先用Mermaid图构建知识框架，然后逐一深入剖析每个问题。

## 🌲 一、核心知识点框架 (Mermaid Mindmap)

以下图表梳理了本题涉及的核心知识体系及解答逻辑：

```mermaid
mindmap
root((拼多多服务端面试体系))
    
    %% 自我介绍与项目深挖
    1_自我介绍与项目深挖
      (教育背景与技术栈)
      (项目职责与贡献)
      (技术难点与解决方案)
        NETCONF消息订阅
          :整体架构与链路
          心跳机制设计
            :间隔设置原因
            :间隔内断连问题
          定时发送/表单配置
          :消息队列选型考量
    
    %% 系统设计
    2_系统设计能力
      (语音交互系统设计)
        :端到端链路 (唤醒→ASR→NLP→服务→TTS)
        :数据格式决策 (文本vs语音)
    
    %% 网络与运维
    3_网络与运维
      (DNS解析故障排查)
        :“找不到IP地址”原因与排查
      (HTTPS证书校验原理)
        :浏览器验证机制
    
    %% 操作系统
    4_操作系统核心
      (进程 vs 线程)
        :根本区别
      (协程 vs 线程)
        :适用场景
      (用户态与内核态)
        :区别与切换时机
    
    %% 算法与数据结构
    5_算法与数据结构
      (LFU Cache实现)
        :O(1)时间复杂度要求
        :数据结构设计 (双哈希表 + 双向链表)
        :get/put操作实现
```

接下来，我将依据此框架，对每个问题进行详尽解答。

---

## 🧑‍💼 二、自我介绍 (参考模板)

**面试官您好，我是[你的姓名]。**

1.  **教育背景**：我本科/硕士毕业于[你的学校][你的专业]。
2.  **研究方向**：在校期间，我的研究方向主要集中在[分布式系统/高性能计算/大数据处理]等领域，这为我后续从事服务端开发打下了坚实的理论基础。
3.  **项目/论文**：我曾主导或深度参与过[选择1-2个最有代表性的项目，最好与电商、高并发、分布式相关]，例如《[项目名称]》。在该项目中，我负责了[核心模块]的设计与实现，解决了[某个具体技术难题]。（*注：此处为模板，需用真实项目填充，引导到你熟悉的领域*）。在论文方面，我发表了《[论文名称]》，主要探讨了[某个技术点]。
4.  **技术栈**：我的技术栈深度聚焦于Java开发生态。在**语言基础**上，我对JVM内存模型、GC调优、多线程并发（如JUC包）有深入理解和实战经验。在**后端框架**方面，我精通Spring Boot、Spring Cloud、MyBatis等主流框架，并有丰富的微服务架构设计和治理经验。在**中间件**层面，我熟练使用Kafka、RocketMQ、Redis、ZooKeeper、Elasticsearch等，并了解其核心原理。在**数据存储**方面，我有MySQL、PostgreSQL等关系型数据库的优化经验，同时也了解MongoDB等NoSQL数据库。此外，我对**分布式系统**的基本概念，如CAP理论、服务发现、负载均衡、分布式事务等，也有实践和理解。

我渴望在拼多多这样拥有海量用户和极致技术挑战的平台，不断提升自己的技术深度和广度，为公司的业务发展贡献价值。

---

## 🔍 三、项目深度追问（以NETCONF消息订阅为例）

### 1. 项目背景与切入点
**项目背景**：在网络设备管理中，NETCONF协议作为IETF标准，用于安装、操作和删除设备配置。我们需要实时监控大量网络设备的配置变更和状态变化。
**我的切入点**：我负责设计和实现NETCONF消息订阅模块，该模块是网络配置管理系统的核心组件之一，旨在为上层应用提供可靠、高效的设备事件推送能力。

### 2. 技术难点
1.  **连接保活与断线重连**：需要与成千上万的网络设备维持长连接，网络环境复杂，如何稳定维持连接是一大挑战。
2.  **海量消息处理与推送**：设备上报的消息量巨大且可能突发，如何保证消息不丢失、不重复，并能高效推送给下游消费者。
3.  **资源管理**：大量空闲连接会占用系统资源，需要有效的心跳和清理机制。
4.  **异构设备兼容**：不同厂商的设备对NETCONF标准的支持程度不一。

### 3. 整体方案/链路
我采用了基于Netty的NIO通信框架构建客户端和服务端。
```plaintext
+----------------+    建立长连接    +-------------+    订阅请求    +-------------+
|  网络设备      | <--------------> | NETCONF代理 | <------------> |  管理平台    |
| (被管设备)     |   (SSH/TLS)     |  (Netty)    |   (WebSocket) |  (Consumer) |
+----------------+                 +-------------+               +-------------+
         |                                |
         | (推送Notify消息)               | (转发Notify消息)
         +------------------------------->-----------------------------------+
```
1.  **连接建立**：设备启动后，与我们的NETCONF代理服务端（Netty实现）建立SSH/TLS长连接。
2.  **能力协商**：进行`hello`消息交换，协商双方支持的参数。
3.  **订阅请求**：管理平台通过WebSocket等方式向代理服务发送`create-subscription` RPC请求，指定订阅的流（stream）和过滤器（filter）。
4.  **消息转发**：当设备发生配置变更（如通过`edit-config`操作）时，会向代理服务端发送`notification`消息。服务端根据订阅关系，将消息转发给对应的管理平台。
5.  **心跳保活**：通过定期发送`rpc`消息（如`get`）作为心跳包，维持连接活性。

### 4. 心跳探测间隔
**间隔设置**：通常设置为**30秒**到**60秒**。

**为什么这样设置**：
1.  **权衡实时性与负载**：间隔太短（如1秒）会产生大量无用的网络流量和CPU开销（加密解密、报文处理）。间隔太长（如300秒）则无法及时探测到连接失效，导致“半开连接”（Half-Open Connection），即服务器认为连接还在，但实际已断开，导致消息丢失。
2.  **参考TCP协议**：许多操作系统的TCP Keepalive默认时间在2小时左右，这对于应用层来说太长了。30-60秒是业界（如阿里云、AWS等）对连接敏感性服务的一个常见经验值，能在连接失效后的**1分钟内**感知到。
3.  **适应NAT超时**：许多网络中的NAT会话超时时间在几分钟内。定期发送心跳可以刷新NAT映射表，防止连接被中间设备清理。

### 5. 心跳间隔内掉线且有新请求
这是一个非常好的问题，会直接导致**请求失败**。具体处理方式取决于TCP和应用的实现：
1.  **TCP重传**：客户端发起请求时，操作系统TCP栈会进行多次重传，等待ACK确认。
2.  **应用超时**：在TCP最终返回错误（如`Connection reset by peer`或超时）之前，应用程序会先等待并触发我们设置的**读写超时**（ReadTimeout）。例如，使用Netty时，我们可以配置`ReadTimeoutHandler`。
3.  **结果**：在这段“黑洞时间”内的请求，客户端会收到一个超时异常或连接重置异常。**对于需要保证可靠性的系统，必须有重试机制**。
    *   **下游重试**：管理平台（调用方）需要实现幂等重试。
    *   **上游缓冲与重连后同步**：更复杂的系统可以在代理层暂存消息（在内存或持久化队列中），待设备重连成功后再行发送。但这需要应用层维护状态，增加了复杂性。

### 6. 定时发送/表单配置实现思路
*   **定时发送**：利用**时间轮（HashedWheelTimer）** 或**延时任务队列（DelayQueue）** 实现高效的定时调度。Netty自带`HashedWheelTimer`，非常适合管理大量连接的心跳超时检测。当心跳任务到期未收到回复，则判定连接超时并关闭它。
*   **表单配置**：通常通过**Web管理界面**进行配置。后端提供RESTful API，将配置（如设备IP、心跳间隔、订阅的过滤器XML）持久化到数据库（如MySQL）。代理服务启动或接收到配置变更通知时，从DB加载配置并应用到对应的连接管理器上。这本质是一个**配置中心**的简化应用。

### 7. 消息队列选型考量
**问**：有没有采用消息队列？如果没有，原因是什么？

**答**：在我们的场景中，**没有引入独立的消息队列（如Kafka/RocketMQ）**。

**原因如下**：
1.  **复杂度与成本**：引入MQ会极大地增加系统的部署、运维和监控复杂度。我们的项目初期规模不大，消息量尚未达到需要引入独立MQ的程度。“如无必要，勿增实体”。
2.  **链路延迟**：NETCONF通知消息通常要求较高的实时性。增加MQ环节会引入额外的网络传输、序列化/反序列化开销，增加端到端延迟。
3.  **数据一致性**：我们的系统更强调CP。消息在代理服务内存中处理，逻辑简单，更容易保证一致性。引入MQ则需要考虑消息可靠投递（ACK机制）、事务消息等，复杂性高。
4.  **适用场景**：MQ更适合**解耦**、**削峰填谷**、**异步处理**和**多消费者**的场景。在我们的初期架构中，主要是**1对1**的消息转发（一个设备事件只推送给一个特定的管理平台），解耦需求不强，且可以通过内置的Channel或简单的内存队列实现缓冲。

**扩展**：如果未来业务发展，消息量剧增，并且需要支持多个消费者订阅同一设备消息（Pub/Sub模式），那么**引入RocketMQ或Kafka将是必然选择**。它们能提供强大的持久化、堆积能力和削峰功能，保证系统的高可用和可扩展性。

---

## 🎤 四、系统设计：语音交互系统

设计一个从唤醒到TTS的端到端链路。

```plaintext
+---------+   +-----+   +-----+   +---------+   +-----+
| 麦克风  |-->| 唤醒 |-->| ASR |-->|   NLP   |-->| 服务 |
+---------+   +-----+   +-----+   +---------+   +-----+
                                                        |
                                                        v
+---------+   +-----+   +-----------------------+   +-----+
|  扬声器  |<--| TTS |<--| 决策与编排(服务内部)  |<--+
+---------+   +-----+   +-----------------------+ 
```

1.  **唤醒（Wake-up）**：
    *   **功能**：设备持续监听环境音，通过本地算法（如基于CNN的语音模型）检测特定的唤醒词（如“小拼小拼”）。
    *   **技术**：通常使用**端上计算**，低功耗运行，唤醒后才会启动后续高功耗流程。
    *   **输出**：唤醒事件及后续一小段音频数据。

2.  **ASR（自动语音识别，Automatic Speech Recognition）**：
    *   **功能**：将唤醒后接收到的用户语音流，实时转换成文本。
    *   **技术**：将音频流发送到**云端ASR服务**（如科大讯飞、阿里云语音识别），服务端使用深度学习模型进行识别。通常采用**流式识别**，边录音边识别，低延迟。
    *   **输出**：识别出的文本，例如“今天天气怎么样”。

3.  **NLP（自然语言处理，Natural Language Processing）**：
    *   **功能**：理解文本的意图（Intent）和提取关键信息（Entities/Slots）。
    *   **技术**：通过**意图识别**和**槽位填充**模型。例如，识别出意图为`QueryWeather`，槽位为`date=today`、`city=当前位置`。
    *   **输出**：结构化的指令数据，如JSON：`{“intent": "QueryWeather", "slots": {"date": "today", "city": "Shanghai"}}`。

4.  **服务（Service）**：
    *   **功能**：根据NLP的解析结果，调用相应的内部或外部服务来执行任务。
    *   **技术**：
        *   **意图分发**：根据`intent`字段，通过路由规则调用不同的业务逻辑处理器（Handler）。
        *   **业务处理**：例如，`QueryWeatherHandler`会调用第三方天气API获取上海今天的天气数据。
        *   **对话管理（DM）**：维护对话状态（Dialog State），处理多轮对话。
    *   **输出**：服务执行结果，通常也是结构化的数据。例如，天气数据：`{"weather": "晴", "temp": "25°C"}`。

5.  **TTS（文本转语音，Text To Speech）**：
    *   **功能**：将服务返回的文本信息合成为自然流畅的语音。
    *   **技术**：调用云端**TTS服务**（如拼接合成、参数合成或端到端深度学习合成），生成音频流。
    *   **输出**：音频二进制数据（如PCM、MP3格式）。

**数据流**：`音频 -> (唤醒) -> 音频流 -> (ASR) -> 文本 -> (NLP) -> 结构化指令 -> (服务) -> 结构化结果 -> (TTS) -> 音频`

### 服务返回给终端是文字还是语音？为什么？

**答**：这取决于终端类型和能力，但**通常服务端返回给瘦客户端（如智能音箱、手机APP）的是经过编排的文本或结构化数据，而非最终的音频**。

**为什么？**
1.  **解耦与灵活性**：
    *   返回**文本**，让客户端自己去调用TTS，可以灵活选择不同的TTS引擎或音色，方便做A/B测试和个性化定制，而不需要服务端发布。
    *   返回**结构化数据**（如上述天气JSON），客户端可以根据自身UI能力决定如何展现（播报语音、屏幕显示卡片、图文混合），实现了业务逻辑与表现层的解耦。
2.  **网络开销**：音频数据量远大于文本。由服务端返回文本，客户端本地合成语音，可以节省大量的上行带宽（客户端到服务端）和下行带宽（服务端到客户端），降低延迟。
3.  **客户端能力**：越来越多的终端设备具备较强的本地计算能力，可以在端上完成TTS甚至简单的NLP，这进一步支持了服务端返回文本的方案。

**例外**：对于一些计算能力极弱的纯语音终端（某些早期智能硬件），或者需要保证语音风格一致性的场景，服务端也可能直接返回音频流。但这不再是行业的主流最佳实践。

---

## 🌐 五、网络与运维

### 1. 浏览器提示“找不到服务器的IP地址”
这个错误发生在**DNS解析阶段**，浏览器根本无法知道目标服务器在哪。

**可能原因与排查思路**：
1.  **本地问题**：
    *   **排查思路**：检查本地网络连接是否正常（如Wi-Fi是否已连接）。尝试`ping 114.114.114.114`看是否能通。
    *   **DNS配置错误**：检查系统的DNS服务器地址配置是否正确。可以尝试手动更换为公共DNS（如`114.114.114.114`或`8.8.8.8`）。
    *   **本地Hosts文件篡改**：检查`C:\Windows\System32\drivers\etc\hosts`文件，是否被恶意软件添加了错误映射。
    *   **浏览器代理问题**：检查浏览器是否配置了错误的代理服务器（Proxy/VPN）。
    *   **本地DNS缓存污染**：在命令行执行`ipconfig /flushdns`（Windows）或`sudo killall -HUP mDNSResponder`（macOS）来刷新本地DNS缓存。
2.  **网络问题**：
    *   **排查思路**：尝试用手机开热点连接，对比测试。
    *   **路由器/光猫故障**：重启路由器或光猫。
    *   **ISP的DNS服务器故障**：这就是为什么要换公共DNS测试的原因。
3.  **域名本身问题**：
    *   **排查思路**：使用`nslookup yourdomain.com`或`dig yourdomain.com`命令进行诊断。
    *   **域名输入错误**：检查网址是否拼写正确。
    *   **域名解析未生效或配置错误**：检查域名DNS解析记录（A记录、CNAME记录等）是否正确配置，并等待全球DNS缓存过期（TTL时间）。
    *   **域名已过期**：检查域名是否还在有效期内。
4.  **服务器问题**：
    *   **排查思路**：使用第三方网站测速工具（如17ce、boce.com）查看全国各地解析是否正常。
    *   **服务器防火墙拦截**：虽然可能性较小，但服务器防火墙如果错误地拦截了DNS查询包，也可能导致此问题。

### 2. 浏览器如何校验HTTPS证书的合法性
这是一个逐级验证的信任链过程，非常精密：
1.  **接收证书**：服务器在TLS握手时，将其数字证书发送给浏览器。
2.  **验证证书有效性**：
    *   **颁发者可信**：浏览器检查证书的颁发者（Issuer）是否在其**内置的信任的根证书颁发机构（CA）列表**中。
    *   **证书未过期**：检查证书的有效起止日期。
    *   **域名匹配**：检查证书中`Subject Alternative Name (SAN)`或`Common Name (CN)`字段是否与当前访问的域名匹配。
    *   **证书未吊销**：浏览器会通过以下一种或两种方式检查证书是否已被颁发者撤销：
        *   **CRL（证书吊销列表）**：向CA维护的吊销列表查询，但这种方式实时性差，已不常用。
        *   **OCSP（在线证书状态协议）**：浏览器直接向CA的OCSP服务发起查询，请求验证证书状态。为了性能和隐私，通常启用**OCSP Stapling**，由服务器在握手时直接提供由CA签名的OCSP响应，无需浏览器再单独去查询。
3.  **验证签名**：浏览器使用其信任的根CA证书的公钥，来解密服务器证书上的数字签名，得到一个哈希值（H1）。浏览器再使用相同的哈希算法对服务器证书的明文信息进行计算，得到另一个哈希值（H2）。如果`H1 == H2`，则证明该证书是由可信CA签发，且内容未被篡改。
4.  **完成验证**：所有步骤均通过后，浏览器认为证书合法，继而开始协商对称加密密钥，之后整个HTTPS通信才得以进行。**任何一步失败，浏览器都会弹出严重的警告提示**。

---

## 💻 六、操作系统核心

### 1. 进程与线程的根本区别
| 特性 | 进程 (Process) | 线程 (Thread) |
| :--- | :--- | :--- |
| **资源所有权** | **资源分配的基本单位**。拥有独立的地址空间、文件描述符、全局变量等系统资源。 | **CPU调度的基本单位**。**共享**其所属进程的资源（内存、文件等），自身只拥有必不可少的独有资源（如栈、寄存器状态）。 |
| **切换开销** | 大。需要切换内存地址空间（切换页表）、内核栈等，需要刷新TLB，导致CPU缓存失效。 | 小。只需切换独有资源（栈、寄存器），在同一地址空间内，CPU缓存命中率高。 |
| **通信方式** | 复杂。需要**进程间通信（IPC）**，如管道、消息队列、共享内存、信号量、Socket等。 | 简单。可直接读写**共享的进程数据**（需通过同步机制，如锁，来避免竞态条件）。 |
| **健壮性** | 高。一个进程崩溃通常不会影响其他进程，因为地址空间是隔离的。 | 低。一个线程崩溃（如非法内存访问）会导致其所属**整个进程**的所有线程崩溃。 |
| **创建开销** | 大。需要为它分配独立的系统资源。 | 小。只需分配栈、寄存器等少量资源。 |

**核心总结**：**进程是资源的容器，线程是执行的载体**。

### 2. 协程与线程的适用场景
| | 线程 (Thread) | 协程 (Coroutine) |
| :--- | :--- | :--- |
| **调度者** | **操作系统内核**（内核态线程）。抢占式调度。 | **用户态程序自身**（运行时）。协作式调度，需主动让出（yield）执行权。 |
| **切换开销** | 高。需要从用户态陷入内核态（trap），由内核完成调度。 | **极低**。**纯粹在用户态**完成上下文切换（通常只是几个寄存器的改变），无需系统调用。 |
| **阻塞影响** | 一个线程因I/O阻塞，不会影响同进程内其他线程的执行（内核会调度其他线程）。 | 一个协程阻塞（如执行了一个阻塞式I/O调用），会**阻塞整个线程**，导致该线程上所有其他协程都无法执行。 |
| **内存占用** | 大。默认栈大小在MB级别（如Java 1MB）。 | 小。栈大小通常在KB级别（如Go的goroutine初始栈仅2KB），可创建的数量远超线程。 |

**适用场景**：
*   **线程**：适用于**计算密集型**任务，需要利用多核CPU并行计算。也适用于可能发生阻塞且无法避免的场景。
*   **协程**：适用于**高并发I/O密集型**任务，特别是网络服务（如API网关、微服务、爬虫）。它能以极低的资源开销支持数十万甚至上百万的并发连接，**完美解决C10K问题**。现代编程语言Go、Java (Loom)、Python (asyncio)都大力推广协程。

### 3. 用户态与内核态的区别与切换时机
*   **用户态 (User Mode)**：
    *   **定义**：运行用户应用程序的权限模式。
    *   **权限**：权限较低。不能直接访问硬件设备等特权资源，只能执行受限的指令集。如果尝试执行特权指令，会引发异常。
*   **内核态 (Kernel Mode)**：
    *   **定义**：运行操作系统内核代码的权限模式。
    *   **权限**：权限最高。可以执行任何CPU指令，可以访问整个硬件和内存空间。

**态切换时机**（用户态 -> 内核态）：
1.  **系统调用（System Call）**：这是最主动和常见的方式。用户程序需要操作系统提供服务时，如文件读写（`read`/`write`）、创建进程（`fork`）、网络通信（`socket`），会执行一条特殊的指令（如`int 0x80`或`syscall`）来触发软中断，陷入内核。
2.  **异常（Exception）**：当CPU执行指令时发生异常，如除零错误、缺页异常、访问非法地址，会自动切换到内核态，由内核的异常处理程序来处理。
3.  **中断（Interrupt）**：当外部设备（如硬盘、网卡）完成操作后，会向CPU发出一个中断信号。CPU会暂停当前执行流，保存现场，转而执行内核中对应的中断处理程序（ISR）。

**切换开销**：态切换是有成本的。它需要**保存和恢复CPU上下文**（寄存器等），可能还需要**切换内存地址空间**，可能导致**CPU缓存局部性失效**。因此，高性能编程中会尽量减少不必要的系统调用。

---

## 🧠 七、算法与数据结构：LFU Cache

### 1. 题目关联
这道题与 **LeetCode 460. LFU Cache** 完全一致。它是设计类题目中的Hard难度，综合考察了对哈希表和双向链表的运用。

### 2. 解题思路
**要求**：设计一个LFU（最不经常使用）缓存，实现`get`和`put`方法，且两者的时间复杂度都应为**O(1)**。

**难点**：单纯的LRU可以用一个哈希表+一个双向链表实现，O(1)不难。但LFU需要根据**使用频率**来淘汰，频率相同的节点再根据LRU顺序淘汰。这就需要维护频率信息。

**数据结构设计**：
我们需要三个核心数据结构：
1.  `Map<Integer, Node> keyToNode`: 键到节点的映射，用于O(1)时间通过key找到Node。
2.  `Map<Integer, DoublyLinkedList> freqToLists`: 频率到双向链表的映射。每个频率对应一个双向链表，链表中所有节点都是这个频率的，且按LRU顺序排列（头部的最近使用，尾部的最久未用）。
3.  `Map<Integer, Integer> keyToFreq`: 键到频率的映射（可以省略，这个信息可以存储在`Node`节点中）。

**`Node`节点**：应包含`key`, `value`, `freq`（频率计数），`prev`, `next`指针。

**`DoublyLinkedList`双向链表**：应实现`addToHead(Node)`, `removeNode(Node)`, `removeTail()`等方法。

**操作逻辑**：
*   **`get(key)`**:
    1.  如果`key`不存在，返回-1。
    2.  如果存在，通过`keyToNode`找到节点。
    3.  **提升节点的频率**：将其从`freqToLists`中当前频率对应的链表里移除。然后将其频率+1，再添加到新频率对应的链表的头部。如果旧频率链表移除后为空，可以考虑删除该空链表。
    4.  更新`minFrequency`（如果被操作的节点正好是当前最小频率链表的最后一个节点，那么移除后最小频率需要更新吗？实际上，最小频率只会在`put`淘汰时或`get`一个唯一的最小频率节点时发生变化，这里需要仔细处理）。
    5.  返回节点的值。
*   **`put(key, value)`**:
    1.  如果容量为0，直接返回。
    2.  如果`key`已存在，更新其value，并执行一次`get(key)`操作来提升其频率。
    3.  如果`key`不存在：
        *   **如果缓存已满**：需要淘汰。从`freqToLists`中`minFrequency`对应的链表里，移除**尾部的节点**（最久未用的），同时在`keyToNode`中删除该节点的key。
        *   **创建新节点**：频率为1。
        *   将新节点添加到`freqToLists`中频率为1的链表的头部。
        *   在`keyToNode`中记录key到新节点的映射。
        *   **将`minFrequency`重置为1**（因为新来了一个频率为1的节点）。

**关键点**：维护一个`minFrequency`变量，指向当前所有频率中的最小值。淘汰时直接通过`minFrequency`找到需要淘汰的链表，而不用遍历所有频率。

**复杂度分析**：
*   **时间复杂度**：`get`和`put`的所有操作，包括哈希表查询、链表节点的移除和添加，都是O(1)操作。因此整体是**O(1)**。
*   **空间复杂度**：**O(capacity)**，由哈希表和链表存储所有节点消耗。

### 3. 完整Java代码实现

```java
import java.util.HashMap;
import java.util.Map;

public class LFUCache {

    // 内部节点类
    class Node {
        int key;
        int value;
        int freq; // 访问频率计数
        Node prev;
        Node next;

        public Node() {}
        public Node(int key, int value) {
            this.key = key;
            this.value = value;
            this.freq = 1; // 新节点频率初始为1
        }
    }

    // 内部双向链表类
    class DoublyLinkedList {
        Node headDummy;
        Node tailDummy;
        int size;

        public DoublyLinkedList() {
            headDummy = new Node();
            tailDummy = new Node();
            headDummy.next = tailDummy;
            tailDummy.prev = headDummy;
            size = 0;
        }

        // 将节点添加到链表头部（最新）
        public void addToHead(Node node) {
            Node next = headDummy.next;
            headDummy.next = node;
            node.prev = headDummy;
            node.next = next;
            next.prev = node;
            size++;
        }

        // 移除指定节点
        public void removeNode(Node node) {
            Node prev = node.prev;
            Node next = node.next;
            prev.next = next;
            next.prev = prev;
            size--;
        }

        // 移除链表尾部节点（最久未使用）并返回它
        public Node removeTail() {
            if (size > 0) {
                Node tailNode = tailDummy.prev;
                removeNode(tailNode);
                return tailNode;
            }
            return null;
        }
    }

    // ========== LFUCache 成员变量 ==========
    private int capacity;
    private int minFreq; // 当前最小频率
    private Map<Integer, Node> keyToNode; // key -> Node
    private Map<Integer, DoublyLinkedList> freqToLists; // frequency -> DoublyLinkedList

    public LFUCache(int capacity) {
        this.capacity = capacity;
        this.minFreq = 0;
        this.keyToNode = new HashMap<>();
        this.freqToLists = new HashMap<>();
    }

    public int get(int key) {
        if (capacity == 0 || !keyToNode.containsKey(key)) {
            return -1;
        }
        Node node = keyToNode.get(key);
        increaseFreq(node); // 提升节点频率
        return node.value;
    }

    public void put(int key, int value) {
        if (capacity == 0) return;

        if (keyToNode.containsKey(key)) {
            // key已存在，更新value并提升频率
            Node node = keyToNode.get(key);
            node.value = value;
            increaseFreq(node);
        } else {
            // key不存在，需要插入
            if (keyToNode.size() == capacity) {
                // 缓存已满，需要淘汰
                DoublyLinkedList minFreqList = freqToLists.get(minFreq);
                Node toRemove = minFreqList.removeTail(); // 淘汰最久未使用的节点
                keyToNode.remove(toRemove.key);
            }
            // 创建新节点
            Node newNode = new Node(key, value);
            keyToNode.put(key, newNode);
            // 将新节点放入频率为1的链表中
            freqToLists.putIfAbsent(1, new DoublyLinkedList());
            freqToLists.get(1).addToHead(newNode);
            minFreq = 1; // 新节点加入，最小频率必定变为1
        }
    }

    // 辅助方法：提升节点的频率
    private void increaseFreq(Node node) {
        int oldFreq = node.freq;
        DoublyLinkedList oldList = freqToLists.get(oldFreq);
        // 从旧频率链表中移除该节点
        oldList.removeNode(node);

        // 如果旧链表移除后为空，且它正好是minFreq对应的链表，则需要更新minFreq
        if (oldList.size == 0 && oldFreq == minFreq) {
            minFreq++; // 注意：这里不是直接=oldFreq+1，因为可能minFreq不是连续的。但由于此节点频率要+1，所以空出来的minFreq位置没有了，minFreq自然变成+1后的频率？不对。实际上，minFreq只有在put淘汰时和新增节点时会被重置。这里移除后链表为空，意味着再也没有节点是oldFreq频率了，而当前节点马上就要变成oldFreq+1。那么新的最小频率应该是多少？它可能是oldFreq+1，也可能还有其他更低频率的节点？不，因为minFreq是当前所有频率中的最小值，如果移除后oldFreq对应的链表空了，且oldFreq正好等于minFreq，说明当前已经没有频率为minFreq的节点了，那么minFreq就应该变为oldFreq+1吗？不一定，可能还有其他更高频率的节点，但最小值确实已经上移了。然而，在我们的逻辑中，minFreq只会在插入新节点时被置为1，在淘汰时使用。这里即使不更新minFreq，在下次淘汰时，因为minFreq对应的链表是空的，淘汰操作会无法进行。因此必须更新。
            // 但实际上，由于我们只在get和put成功时调用此方法，而get和put成功意味着缓存中一定有数据。当oldFreq==minFreq且链表变空时，说明再也没有节点是minFreq了，那么minFreq自然就是oldFreq+1（因为当前节点马上就要变成这个频率）。这是正确的。
        }

        // 更新节点频率
        int newFreq = oldFreq + 1;
        node.freq = newFreq;
        // 将节点加入到新频率对应的链表的头部
        freqToLists.putIfAbsent(newFreq, new DoublyLinkedList());
        freqToLists.get(newFreq).addToHead(node);
    }
}
```

**边界情况处理**：
*   容量为0。
*   `get`不存在的key。
*   缓存已满时再`put`。
*   频率提升后，原频率链表为空的情况。

这套解答兼具了技术深度和广度，体现了资深工程师的系统性思维和扎实功底。希望它能帮助您在面试中脱颖而出。

好的，这是对您提供的PDD提前批二面面试题的详细解答。我将题目分为【技术问题】和【非技术问题】两部分进行整理和回答。

---

### **第一部分：非技术问题（1-5）**

这类问题考察你的软技能、自我认知和项目经验。

**1. 你觉得你有什么优点？**
*   **回答思路**：结合岗位要求（如技术扎实、学习能力强、责任心强、善于沟通等），用具体事例证明。
*   **示例回答**：
    *   **技术钻研能力强**：比如，我不仅满足于使用Redis，还会深入研究其底层源码，如数据结构、持久化机制等，这帮助我在项目中能更好地进行性能调优和问题排查。
    *   **解决问题能力强**：面对线上问题，我能保持冷静，遵循“定位问题-分析原因-制定方案-验证解决”的思路。例如，我曾通过分析日志和监控，快速定位到一个因缓存击穿导致的性能瓶颈，并通过布隆过滤器解决了它。
    *   **责任心强，有主人翁意识**：对于我负责的项目模块，我会主动跟进，确保代码质量和项目进度，并乐于承担有挑战性的任务。

**2. 碰到问题是怎么解决问题的？解决思路是什么？**
*   **回答思路**：展示你有逻辑、系统化的问题解决能力。
*   **示例回答**：
    1.  **明确问题**：首先复现问题，明确问题的现象、影响范围和边界条件。
    2.  **信息收集**：查看错误日志、监控指标（CPU、内存、QPS等）、代码变更记录，尽可能多地收集信息。
    3.  **分析定位**：基于收集的信息，提出假设并验证。例如，如果是性能问题，我会使用`arthas`、`jstack`等工具分析线程状态和热点代码；如果是数据问题，会核对数据库和缓存。
    4.  **解决方案**：找到根因后，设计一个或多个解决方案，评估每个方案的优缺点（如实现成本、风险、收益），选择最优解。
    5.  **实施与复盘**：实施解决方案后，观察效果，确保问题被彻底解决。最后，进行复盘，思考如何避免类似问题再次发生，比如完善监控、增加代码检查等。

**3. 自己的协作，和其他人相处怎么样？**
*   **回答思路**：体现你的团队合作精神和沟通能力。
*   **示例回答**：我认为自己和团队成员相处得很好。在协作中，我注重以下几点：
    *   **积极沟通**：在项目开始前明确需求和接口，开发中遇到问题或阻塞会及时同步，完成后及时通知下游。
    *   **乐于分享和帮助**：我会主动分享技术知识和项目经验，也乐于帮助同事解决他们遇到的技术难题。
    *   **尊重与开放**：我尊重他人的意见和建议，在代码评审或方案讨论中，能坦诚地提出自己的想法，也能虚心接受他人的指正。

**4. 觉得你自己有什么缺点？**
*   **回答思路**：说一个真实但无伤大雅的缺点，并强调你正在如何改进。避免说影响工作的致命缺点。
*   **示例回答**：
    *   **初期版本**：有时候在接手一个复杂的新项目时，我可能会过于关注技术细节，希望一下子把所有代码和设计都理解透彻，这可能导致在项目初期效率稍低。
    *   **改进措施**：我现在正在学习更好地把握“广度”和“深度”的平衡。我会先快速理解项目的整体架构和核心流程，再根据当前任务的需要，有针对性地深入相关模块的细节，这样效率更高。

**5. 觉得哪个项目自己比较熟，讲一下**
*   **回答思路**：选择你最熟悉、最有技术亮点的项目。按“项目背景 -> 我的职责 -> 技术架构/亮点 -> 遇到的挑战与解决方案 -> 成果”的结构来讲。
*   **示例回答**：我最熟悉的是XX电商平台的秒杀系统。
    *   **背景**：为了解决高并发下系统稳定性和数据一致性问题。
    *   **我的职责**：我主要负责商品详情页的静态化、库存预扣和Redis集群的维护与优化。
    *   **技术亮点**：
        *   采用了**页面静态化**技术，将商品详情页推送到CDN，极大减轻了后端压力。
        *   使用**Redis Lua脚本**实现库存的原子性预扣，防止超卖。
        *   使用了**Redisson的分布式锁**来保证关键业务流程的互斥执行。
    *   **挑战与解决**：曾遇到缓存穿透问题，对于不存在的商品ID，大量请求直达数据库。我通过**布隆过滤器**快速判断商品ID是否存在，有效拦截了无效请求。
    *   **成果**：系统成功支撑了多次大促活动，峰值QPS达到XX万，无重大故障。

---

### **第二部分：技术问题（6-38）**

#### **Redis 相关 (6-16)**

**6. Redission的定时器是用什么实现的？**
*   **答**：Redisson的定时器（如看门狗）是基于Netty的`HashedWheelTimer`（时间轮算法）实现的。时间轮是一种高效的定时任务调度模型，它将时间分成多个槽（tick），像一个轮子一样循环转动，适合管理大量短周期的定时任务。

**7. 看门狗续期怎么检测任务是存活的？**
*   **答**：看门狗机制并不直接检测业务任务的存活。它的原理是：当成功获取一个分布式锁时，会启动一个看门狗定时任务。这个任务会定期（默认锁过期时间的1/3，如30秒过期则每10秒一次）去检查持有锁的客户端是否还“活着”（即客户端的JVM进程是否正常运行），如果还活着，它就通过`pexpire`命令重置锁的过期时间，实现“续期”。如果客户端宕机了，看门狗任务自然停止，锁最终会因过期而被释放。

**8. 如果fullgc了，然后看门狗阻塞了，此时key过期了，应该怎么处理？**
*   **答**：这是一个极端但重要的问题。
    *   **发生过程**：发生长时间的Full GC会导致JVM暂停（Stop-The-World），看门狗线程也被阻塞，无法执行续期操作。锁Key在Redis中因过期时间到了而被自动删除。
    *   **后果**：此时，其他客户端就能成功获取到该锁，意味着同一个锁被两个客户端同时持有，可能导致数据不一致。
    *   **如何缓解**：
        1.  **优化JVM**：首要任务是优化应用代码和JVM参数，尽量避免长时间Full GC。
        2.  **设置合理的锁超时时间**：设置一个远大于业务执行时间的锁超时时间，给GC留出缓冲余地。但这降低了锁的及时释放性。
        3.  **业务层面的幂等性设计**：这是最根本的解决方案。即使因为极端情况发生了锁失效，业务逻辑本身也应具备幂等性，不会因为重复执行而产生错误数据。

**9. redis的路由是在客户端路由吗？**
*   **答**：这取决于Redis集群的模式。
    *   **Redis Cluster模式**：是的，路由主要是在**客户端**实现的。客户端会缓存一份`slot-node`的映射关系（通过`CLUSTER SLOTS`命令获取）。当客户端要对一个key进行操作时，会先计算key对应的slot，然后根据映射关系直接连接到正确的节点。
    *   **代理模式（如Codis/Twemproxy）**：路由是由**代理层**完成的。客户端直接连接代理，由代理根据路由规则将请求转发到正确的Redis实例。

**10. 有部署过集群吗？**
*   **答**：如实回答。如果有，可以简述一下步骤和注意事项（如节点规划、配置文件修改、使用`redis-cli --cluster create`命令创建集群等）。如果没有，可以说了解其原理，并表达出学习的意愿。

**11. 说说redis的几种数据结构，以及底层的物理结构是什么？**
*   **答**：
    | 数据结构 | 底层物理结构（至少一种）                                     |
    | :------- | :----------------------------------------------------------- |
    | String   | SDS（简单动态字符串）                                        |
    | List     | QuickList（由多个ZipList组成的双向链表）                     |
    | Hash     | ZipList（元素少时） 或 HashTable（字典）                     |
    | Set      | IntSet（整数且元素少时） 或 HashTable（字典，value为null） |
    | ZSet     | ZipList（元素少时） 或 **SkipList + HashTable**（字典）的混合结构 |

**12. Zset底层数据结构是怎么实现的？**
*   **答**：如上表所述，对于元素数量多或元素非整数的情况，ZSet使用**跳表（SkipList）和哈希表（Dict）** 的组合。
    *   **跳表**：负责维护元素的有序性，支持基于排名的范围查询。
    *   **哈希表**：以元素为key，分值为value，支持通过元素快速查找其分值（O(1)时间复杂度）。
    *   两种结构通过指针共享元素和分值，不会浪费额外空间。

**13. redis哈希结构扩容是怎么做的？**
*   **答**：Redis哈希表采用**渐进式Rehash**。
    1.  为哈希表分配一个新的大小的数组（通常是原大小的2倍）。
    2.  在字典中维护两个哈希表（`ht[0]`和`ht[1]`），此时开始Rehash，将`ht[0]`的数据迁移到`ht[1]`。
    3.  **渐进式**：迁移不是一次性完成的，而是在每次对字典进行**增、删、改、查**操作时，顺带迁移`ht[0]`中一个索引位置上的所有条目（一个bucket）。此外，Redis也有一个定时任务，会在空闲时进行迁移。
    4.  迁移期间，查找会同时查询两个表；新增操作只会在新表`ht[1]`上进行。
    5.  当`ht[0]`的所有数据迁移完毕，将`ht[1]`设置为新的`ht[0]`，并清空旧的`ht[0]`。

**14. 有看过redis相关的书籍吗？**
*   **答**：可以回答《Redis设计与实现》。这本书深入讲解了Redis的源码和内部机制，是深入学习Redis的经典书籍。

**15. redis过期key清理机制是什么？**
*   **答**：采用**惰性删除 + 定期删除**两种策略。
    *   **惰性删除**：当客户端访问一个key时，Redis会检查它是否已过期，如果过期则立即删除。
    *   **定期删除**：Redis每隔一段时间会随机抽取一批设置了过期时间的key，检查并删除其中已过期的。如果过期key的比例很高，会继续重复这个过程，直到比例降到阈值以下。

#### **Java 基础与并发 (24-29)**

**24. JVM中如何标记垃圾的？**
*   **答**：主要使用**可达性分析算法**。
    *   从一系列称为`GC Roots`的对象（如虚拟机栈中引用的对象、方法区中静态属性引用的对象、常量引用的对象等）作为起点开始搜索。
    *   从这些根对象开始，走过的路径称为“引用链”。
    *   如果一个对象到`GC Roots`没有任何引用链相连（即不可达），则证明此对象不再被使用，可以被标记为垃圾。

**25. 说下synchronized锁升级的过程**
*   **答**：为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁->轻量级锁->重量级锁”的升级过程。
    1.  **无锁状态**：新对象。
    2.  **偏向锁**：一段时期内只有一个线程访问同步块，JVM会偏向这个线程。线程再次进入时无需任何CAS操作。
    3.  **轻量级锁**：当有第二个线程尝试获取锁（发生竞争），偏向锁升级为轻量级锁。线程通过**自旋（CAS）** 来尝试获取锁，避免直接阻塞。
    4.  **重量级锁**：如果自旋一定次数后仍未获取到锁（竞争激烈），锁会升级为重量级锁。此时，其他尝试获取锁的线程会被**阻塞**，等待持有锁的线程释放后唤醒。重量级锁依赖于操作系统底层的`mutex`互斥量。

**26. 介绍一下AQS**
*   **答**：AQS（AbstractQueuedSynchronizer）是Java并发包中构建锁和同步器（如ReentrantLock, CountDownLatch）的**核心框架**。
    *   **核心思想**：它维护了一个**volatile int state**（表示共享资源状态）和一个**FIFO线程等待队列**（CLH队列的变体）。
    *   **工作方式**：线程通过CAS操作尝试修改`state`来获取资源（如锁）。如果成功，则继续执行。如果失败，则将当前线程封装成节点加入等待队列，并可能进入阻塞状态。当持有资源的线程释放资源时，会唤醒队列中的一个或所有线程。

**27. 说下ReentrantLock的公平和非公平机制**
*   **答**：这体现在尝试获取锁时的策略。
    *   **非公平锁**（默认）：当一个线程尝试获取锁时，不管等待队列中是否有其他线程在排队，它都会**直接尝试CAS抢占**`state`。如果抢占失败，才加入队列尾部排队。这可能导致“插队”现象，但吞吐量高。
    *   **公平锁**：当一个线程尝试获取锁时，它会先检查等待队列中是否有正在等待的线程。**如果有，则直接加入队列尾部排队**；如果没有，才尝试获取锁。保证了先来后到的顺序，但性能开销稍大。

**28. java的动态代理了解吗？怎么实现的？**
*   **答**：动态代理是在运行时动态生成代理类。
    *   **JDK动态代理**：基于**接口**实现。核心类是`java.lang.reflect.Proxy`和`InvocationHandler`。通过`Proxy.newProxyInstance`方法生成一个实现了指定接口的代理对象。所有方法调用都会被转发到`InvocationHandler.invoke`方法。
    *   **CGLIB动态代理**：基于**继承**实现。它通过**字节码技术**生成一个被代理类的子类，并重写方法来实现代理。因此它不需要目标类实现接口。

**29. CGLIB是什么实现的？**
*   **答**：如上所述，CGLIB是通过**ASM字节码处理框架**，在运行时动态生成被代理类的**子类**来实现的。

#### **Spring 框架 (32-34)**

**32. Spring的自动配置原理**
*   **答**：核心是`@EnableAutoConfiguration`注解和`spring.factories`文件。
    1.  `@SpringBootApplication`包含了`@EnableAutoConfiguration`。
    2.  `@EnableAutoConfiguration`会通过`@Import`导入`AutoConfigurationImportSelector`。
    3.  这个Selector会去`META-INF/spring.factories`文件中读取所有配置的自动配置类（`EnableAutoConfiguration`键对应的全限定类名列表）。
    4.  这些自动配置类使用`@Conditional`系列注解（如`@ConditionalOnClass`, `@ConditionalOnProperty`）进行条件判断，只有满足条件（如类路径下存在某个类、配置了某个属性等）时，配置才会生效，从而自动将Bean装配到IoC容器中。

**33. Spring怎么解决循环依赖的问题？**
*   **答**：Spring通过**三级缓存**来解决**单例Bean**的**Setter注入/字段注入**方式的循环依赖。
    *   **一级缓存** `singletonObjects`：存放完全初始化好的单例Bean。
    *   **二级缓存** `earlySingletonObjects`：存放提前暴露的早期Bean（已实例化但未填充属性）。
    *   **三级缓存** `singletonFactories`：存放Bean的工厂对象，用于生成早期Bean。
    *   **过程**：A创建时，实例化后将自己（一个ObjectFactory）放入三级缓存 -> 开始为A填充属性，发现需要B -> 创建B -> 为B填充属性，发现需要A -> 从三级缓存中通过A的工厂获取A的早期引用（可能被AOP代理）并放入二级缓存，同时删除三级缓存中的A -> B完成创建 -> A得到B，完成属性填充和初始化，放入一级缓存，并清理二、三级缓存。

**34. 为什么两级不行？**
*   **答**：如果只有一级和二级缓存，无法处理存在**AOP代理**的情况。三级缓存中的`ObjectFactory`的核心作用是在需要获取早期引用时，能够**智能地返回目标Bean的普通对象或其代理对象**。如果A需要被代理，那么B依赖的A应该是代理对象。这个代理创建的时机由`ObjectFactory`来把控。如果只有两级，在存在AOP时，无法保证B和最终A拿到的是同一个代理对象。

#### **数据库与网络 (17-23, 35-36)**

**17. 操作系统内存管理的机制是什么？**
*   **答**：主要机制包括：
    *   **分页管理**：将物理内存和虚拟内存分割成固定大小的页（如4KB）。通过页表实现虚拟地址到物理地址的映射。
    *   **分段管理**：按照程序的逻辑单元（如代码段、数据段）划分内存空间。
    *   **段页式管理**：结合两者，先分段，段内再分页。是现代操作系统的主流方式。
    *   **虚拟内存**：允许程序使用比实际物理内存更大的地址空间。暂时不用的页可以被换出到磁盘（交换区）。
    *   **页面置换算法**：当发生缺页异常时，决定将哪个页面换出，如LRU（最近最少使用）。

**18. TCP中的滑动窗口和拥塞窗口的作用是什么？**
*   **答**：
    *   **滑动窗口**：用于**流量控制**。接收方通过通告自己的窗口大小（`rwnd`）来告诉发送方自己还能接收多少数据，防止发送方发送过快导致接收方缓冲区溢出。
    *   **拥塞窗口**：用于**拥塞控制**。发送方维护的一个状态变量（`cwnd`），根据网络拥塞程度动态调整，限制发送速率，防止过多的数据注入网络导致路由器或链路过载。发送窗口的实际大小 = `min(拥塞窗口cwnd, 接收窗口rwnd)`。

**19. HTTP协议的结构是什么样的？请求报文和应答报文分别有什么？**
*   **答**：
    *   **通用结构**：`起始行 + 头部字段（Headers）+ 空行（CRLF）+ 消息体（Body）`
    *   **请求报文**：
        *   起始行：`方法(GET/POST等) + 请求URL + HTTP版本`，如 `GET /index.html HTTP/1.1`
        *   头部：`Host`, `User-Agent`, `Content-Type`等。
        *   消息体：POST/PUT等方法携带的数据。
    *   **响应报文**：
        *   起始行：`HTTP版本 + 状态码 + 状态文本`，如 `HTTP/1.1 200 OK`
        *   头部：`Content-Type`, `Content-Length`, `Server`等。
        *   消息体：服务器返回的实际内容，如HTML文档。

**20. 请求头中有什么？**
*   **答**：常见请求头包括：
    *   `Host`：目标主机和端口。
    *   `User-Agent`：客户端软件标识。
    *   `Accept`：客户端能处理的内容类型。
    *   `Content-Type`：消息体的媒体类型（如`application/json`）。
    *   `Authorization`：认证信息。
    *   `Cookie`：客户端携带的Cookie。

**21. 浏览器输入URL到呈现页面会发生什么？**
*   **答**：经典八股文，简述流程：
    1.  **DNS解析**：将域名转换为IP地址。
    2.  **建立TCP连接**：与服务器进行三次握手。
    3.  **发送HTTP请求**：浏览器发送请求报文。
    4.  **服务器处理请求并返回HTTP响应**。
    5.  **浏览器解析渲染**：
        *   解析HTML构建DOM树。
        *   解析CSS构建CSSOM树。
        *   将DOM和CSSOM合并成渲染树（Render Tree）。
        *   布局（Layout）/重排（Reflow）：计算每个节点的位置和大小。
        *   绘制（Painting）：将渲染树绘制到屏幕上。
    6.  **断开TCP连接**：四次挥手。

**22. HTTPS中用到了那两种加密算法**
*   **答**：**非对称加密**（如RSA、ECC）和**对称加密**（如AES、DES）。

**23. 为什么要用非对称加密和对称加密？**
*   **答**：结合两者优势。
    *   **非对称加密**：安全性高，但**计算速度慢**。用于在HTTPS握手阶段安全地交换**对称加密的密钥**（Pre-Master Secret）和进行身份认证（数字证书）。
    *   **对称加密**：**计算速度快**，适合加密大量数据传输。在握手完成后，后续的所有通信都使用协商好的对称密钥进行加密，保证效率。

**35. RC和RR两种隔离级别在MVCC中执行有什么差异？**
*   **答**：主要体现在**一致性读视图（Read View）创建的时机不同**。
    *   **Read Committed (RC，读已提交)**：在**每一次**执行普通SELECT语句时都会生成一个新的Read View。这意味着每次读都能看到其他已提交事务的最新修改。
    *   **Repeatable Read (RR，可重复读)**：在**第一次**执行普通SELECT语句时生成一个Read View，并在整个事务范围内都使用这个视图。这就保证了在同一个事务中，多次读取同一数据的结果是一致的，不受其他已提交事务的影响，解决了不可重复读问题。

**36. MVCC是解决什么场景的问题？**
*   **答**：MVCC（多版本并发控制）主要用于解决**读-写冲突**的场景。它通过保存数据的历史版本，使得读操作（快照读）不用等待写操作释放锁，写操作也不用等待读操作释放锁，提高了数据库的并发性能。它解决了：
    *   **脏读**：读不到未提交的数据。
    *   **不可重复读**：在RR级别下解决。
    *   **幻读**：在RR级别下，通过Next-Key Lock（临键锁）配合MVCC来解决。

#### **分布式与算法 (30-31, 37-38)**

**30. 有了解过什么RPC框架吗？**
*   **答**：可以提Dubbo, gRPC, Spring Cloud等。选择一个熟悉的简单说下核心组件（如Dubbo的Provider, Consumer, Registry, Monitor）和特点（如基于Netty，高性能等）。

**31. 分布式相关内容了解吗？CAP理论和Base理论了解吗？**
*   **答**：
    *   **CAP理论**：一个分布式系统最多只能同时满足一致性（C）、可用性（A）、分区容错性（P）中的两项。由于网络分区不可避免，通常需要在C和A之间权衡（如CP的ZooKeeper，AP的Eureka）。
    *   **BASE理论**：是对CAP中AP方案的延伸，通过牺牲强一致性来获得可用性。核心思想是：
        *   **Basically Available（基本可用）**：系统出现故障时，允许损失部分可用性（如响应时间变长、功能降级）。
        *   **Soft state（软状态）**：允许系统中间状态的存在，且该状态不影响系统整体可用性。
        *   **Eventually consistent（最终一致性）**：经过一段时间后，所有副本的数据会达到一致。

**37. 算法：编码字符串解码（栈的应用）**
```java
public String decodeString(String s) {
    Stack<Integer> numStack = new Stack<>();
    Stack<StringBuilder> strStack = new Stack<>();
    StringBuilder curStr = new StringBuilder();
    int curNum = 0;

    for (char c : s.toCharArray()) {
        if (Character.isDigit(c)) {
            curNum = curNum * 10 + (c - '0');
        } else if (c == '[') {
            // 遇到左括号，将当前数字和字符串入栈，并重置
            numStack.push(curNum);
            strStack.push(curStr);
            curNum = 0;
            curStr = new StringBuilder();
        } else if (c == ']') {
            // 遇到右括号，出栈，进行字符串拼接
            int repeatTimes = numStack.pop();
            StringBuilder preStr = strStack.pop();
            for (int i = 0; i < repeatTimes; i++) {
                preStr.append(curStr);
            }
            curStr = preStr;
        } else {
            // 普通字符，直接追加到当前字符串
            curStr.append(c);
        }
    }
    return curStr.toString();
}
```

**38. 算法：求和为target的子序列长度最大值（滑动窗口/双指针）**
*   **注意**：题目说是“子序列”，但示例是连续的，且要求长度最大。通常连续子数组用滑动窗口。这里假设是**连续子数组**。
```java
public int maxSubArrayLen(int[] nums, int target) {
    // key: 前缀和, value: 该前缀和第一次出现的下标
    Map<Integer, Integer> prefixSumMap = new HashMap<>();
    prefixSumMap.put(0, -1); // 重要：前缀和为0时，下标为-1
    int maxLen = 0;
    int prefixSum = 0;

    for (int i = 0; i < nums.length; i++) {
        prefixSum += nums[i];
        // 我们要找的是：prefixSum - target 是否在Map中存在
        // 因为 prefixSum_j - prefixSum_i = target => prefixSum_i = prefixSum_j - target
        if (prefixSumMap.containsKey(prefixSum - target)) {
            int startIndex = prefixSumMap.get(prefixSum - target);
            maxLen = Math.max(maxLen, i - startIndex);
        }
        // 只记录第一次出现的位置，以保证子数组最长
        if (!prefixSumMap.containsKey(prefixSum)) {
            prefixSumMap.put(prefixSum, i);
        }
    }
    return maxLen;
}
```

---

希望这份详细的解答能帮助你更好地准备面试！

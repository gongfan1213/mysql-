这是一份非常全面的百度后端一面面经，问题覆盖了数据库、Java并发、数据结构、Linux、Spring框架以及软技能。我来为你提供详细的解答，助你备战二面！

---

### **1. 自我介绍 & 实习内容**
- **策略**：突出与目标岗位相关的技术栈、项目职责和量化成果。用STAR法则（情境-任务-行动-结果）来组织语言。
- **示例**：“在美团实习期间，我主要负责XX系统的性能优化。通过引入Redis缓存和优化SQL语句，将核心接口的响应时间从200ms降低到了50ms，提升了75%。”

### **2. 实习中印象深刻的点？**
- **考察点**：解决问题的能力、技术深度和总结反思能力。
- **回答**：选择一个有挑战性的技术问题。例如：“印象最深的是处理一个线上偶发的数据库死锁问题。我通过分析日志，使用`SHOW ENGINE INNODB STATUS`命令定位到死锁的SQL和资源竞争点，最终通过调整事务内SQL的执行顺序解决了问题。这个过程让我对InnoDB的锁机制有了更深的理解。”

### **3. B树和B+树**
- **B树**：一种平衡多路搜索树，每个节点可包含多个key和指针。所有节点都存储数据。
- **B+树**：B树的变种，核心区别：
    - **非叶子节点**只起索引作用，仅包含key，不存储数据。
    - **叶子节点**存储所有数据，并且叶子节点之间通过指针相连，形成有序链表。
- **为什么数据库索引用B+树**：
    - **查询效率更稳定**：任何查询都要走到叶子节点，时间复杂度稳定为O(log n)。
    - **范围查询高效**：叶子节点的链表结构非常适合范围查询。
    - **磁盘I/O更少**：非叶子节点能容纳更多key，树高更低，减少磁盘寻道次数。

### **4. DELETE vs TRUNCATE**
| 特性 | `DELETE` | `TRUNCATE` |
| :--- | :--- | :--- |
| **类型** | DML语句 | DDL语句 |
| **WHERE子句** | 支持，可条件删除 | 不支持，清空全表 |
| **事务** | 可回滚 | 立即生效，隐式提交，不可回滚 |
| **性能** | 逐行删除，较慢，会产生undo log | 直接回收数据页，非常快 |
| **自增ID** | 不影响自增计数器 | 重置自增计数器归零 |
| **触发器** | 会触发 | 不会触发 |

**数据清理**：两者都不会立即从磁盘物理擦除数据页，而是标记为可重用。空间由InnoDB后台线程后续回收。

### **5. ACID**
- **原子性（A）**：事务是一个不可分割的整体，要么全部成功，要么全部失败回滚。
- **一致性（C）**：事务执行前后，数据库必须从一个一致性状态变换到另一个一致性状态（如转账前后总额不变）。
- **隔离性（I）**：并发事务之间相互隔离，互不干扰。
- **持久性（D）**：事务一旦提交，其对数据的修改就是永久性的，即使系统故障也不会丢失。

### **6. 脏读、幻读、不可重复读**
- **脏读**：事务A读到了事务B**未提交**的数据。
- **不可重复读**：事务A内多次读取同一数据，期间事务B**修改并提交**了该数据，导致事务A两次读取结果不一致。**重点在于数据值的修改**。
- **幻读**：事务A内多次按相同条件查询，期间事务B**新增或删除**了符合该条件的记录并提交，导致事务A两次查询到的**记录行数**不一致。**重点在于数据行的增删**。

### **7. SQL嘴撕：求每个班级成绩第二名的学生**
**思路**：使用窗口函数`DENSE_RANK()`或自关联子查询。
```sql
-- 方法1：使用DENSE_RANK（推荐，清晰易懂）
SELECT student_id, class_id, math_score
FROM (
    SELECT *,
           DENSE_RANK() OVER (PARTITION BY class_id ORDER BY math_score DESC) as rk
    FROM exam_table
) t
WHERE rk = 2;

-- 方法2：使用子查询（理解逻辑）
-- 第二名的成绩是：比第一名成绩小的成绩中的最大值
SELECT a.class_id, a.student_id, a.math_score
FROM exam_table a
WHERE a.math_score = (
    SELECT MAX(math_score)
    FROM exam_table b
    WHERE b.class_id = a.class_id
    AND b.math_score < (
        SELECT MAX(math_score) FROM exam_table c WHERE c.class_id = a.class_id
    )
);
```

### **8. 嘴撕：求二叉树高度**
**思路**：递归（深度优先搜索）。
```java
public int getHeight(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftHeight = getHeight(root.left);
    int rightHeight = getHeight(root.right);
    return Math.max(leftHeight, rightHeight) + 1; // 当前节点的高度是左右子树最大高度+1
}
```

### **9. 嘴撕：求单链表倒数第k个节点**
**思路**：快慢指针（一次遍历）。
```java
public ListNode getKthFromEnd(ListNode head, int k) {
    ListNode fast = head, slow = head;
    // 快指针先走k步
    for (int i = 0; i < k; i++) {
        if (fast == null) return null; // k大于链表长度
        fast = fast.next;
    }
    // 快慢指针同时前进，直到快指针走到末尾
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    // 此时慢指针指向倒数第k个节点
    return slow;
}
```

### **10. 线程安全的集合与容器**
- **遗留类**：`Hashtable`, `Vector`（方法用`synchronized`修饰，性能差）。
- **包装类**：`Collections.synchronizedList/Map/Set`（通过包装器实现线程安全）。
- **JUC包下的并发容器**（推荐使用）：
    - `ConcurrentHashMap`：分段锁/CAS，高并发性能好。
    - `CopyOnWriteArrayList`：读多写少场景。
    - `ConcurrentLinkedQueue`：无界非阻塞队列。
    - `ArrayBlockingQueue`, `LinkedBlockingQueue`：阻塞队列。

### **11. AQS（AbstractQueuedSynchronizer）**
- **是什么**：构建锁和同步器（如ReentrantLock, CountDownLatch）的框架。
- **核心**：一个volatile int类型的**state**（表示共享资源状态）和一个FIFO**线程等待队列**。
- **原理**：线程通过CAS尝试修改state获取资源。成功则继续；失败则封装成节点加入队列并可能阻塞。释放资源时唤醒后继节点。

### **12. 嘴撕：生产者消费者模型**
**思路**：使用**阻塞队列**（`BlockingQueue`）是最简单的实现方式。
```java
// 共享资源池
BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(10);

// 生产者
class Producer implements Runnable {
    public void run() {
        while (true) {
            try {
                int item = produceItem();
                queue.put(item); // 队列满时阻塞
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}

// 消费者
class Consumer implements Runnable {
    public void run() {
        while (true) {
            try {
                int item = queue.take(); // 队列空时阻塞
                consumeItem(item);
            } catch (InterruptedException e) {
                break;
            }
        }
    }
}
```

### **13. 阻塞队列的线程安全与忙等待**
- **是否线程安全**：**是**。`BlockingQueue`的实现（如`ArrayBlockingQueue`）内部使用ReentrantLock等机制保证线程安全。
- **是否存在忙等待**：**否**。当队列满/空时，线程会调用`LockSupport.park()`进入**等待状态**（WAITING/TIMED_WAITING），释放CPU资源，而不是循环空转（忙等待）。

### **14. 抽象类 vs 接口（Java 8+）**
| 特性 | 抽象类 | 接口 |
| :--- | :--- | :--- |
| **成员变量** | 可以是各种类型 | 默认是`public static final`常量 |
| **方法** | 可以有抽象方法、具体方法 | Java 8前只能是抽象方法，之后可有`default`和`static`方法 |
| **构造器** | 有 | 无 |
| **继承** | 单继承 | 多实现 |
| **设计目的** | **"is-a"** 关系，代码复用 | **"has-a"** 或 **"can-do"** 关系，定义行为契约 |

### **15. Linux查找大于10MB的文件**
```bash
find /path/to/directory -type f -size +10M
```
- `find`：查找命令。
- `/path/to/directory`：指定搜索的目录。
- `-type f`：只查找文件（排除目录）。
- `-size +10M`：查找大小大于10MB的文件。

### **16. OOM后Java进程一定会退出吗？**
- **不一定**。这取决于OOM错误的类型和JVM的配置。
    - 如果OOM发生在**主线程**且**未捕获**（`OutOfMemoryError`继承自`Error`，是`Throwable`的子类，不是`Exception`），进程通常会退出。
    - 如果OOM发生在**子线程**，通常只有该线程会终止，而JVM进程不会退出。
    - 如果使用`try-catch`捕获了`OutOfMemoryError`，并在catch块中进行了处理（如释放内存），进程可能不会退出（但不推荐这样做）。

### **17. Exception vs Error**
- **Error**：指程序**无法处理**的系统级错误，由JVM抛出。如`OutOfMemoryError`, `StackOverflowError`。通常应用程序不应捕获。
- **Exception**：指程序**可以处理**的异常，是应用程序关心的。分为：
    - **受检异常（Checked）**：必须用try-catch捕获或throws声明，如`IOException`。
    - **非受检异常（Unchecked/Runtime）**：如`NullPointerException`, `IllegalArgumentException`。

### **18. 浏览器输入URL流程**
经典八股，简述：
1.  **DNS解析**：域名 -> IP地址。
2.  **建立TCP连接**：三次握手。
3.  **发送HTTP/HTTPS请求**。
4.  **服务器处理并返回响应**。
5.  **浏览器解析渲染**（解析HTML、CSS，构建DOM树、CSSOM树、渲染树，布局，绘制）。
6.  **断开连接**：TCP四次挥手。

### **19. Spring记录Controller请求日志**
**实现方式**：
1.  **使用Spring AOP**（最优雅）：
    ```java
    @Aspect
    @Component
    public class LoggingAspect {
        private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);
        
        @Around("execution(* com.yourpackage.controller..*.*(..))")
        public Object logMethodExecution(ProceedingJoinPoint joinPoint) throws Throwable {
            long start = System.currentTimeMillis();
            Object result = joinPoint.proceed(); // 执行原方法
            long duration = System.currentTimeMillis() - start;
            
            logger.info("Method {}} executed in {} ms", joinPoint.getSignature(), duration);
            // 还可以记录参数、返回值等
            return result;
        }
    }
    ```
2.  **使用拦截器（Interceptor）**：实现`HandlerInterceptor`接口，重写`preHandle`和`postHandle`方法。
3.  **使用Filter**：更底层，但获取Spring上下文信息不如AOP方便。

### **20. Spring全局异常处理**
**使用`@ControllerAdvice`或`@RestControllerAdvice`**：
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleAllExceptions(Exception ex) {
        // 记录日志
        logger.error("Uncaught exception: ", ex);
        // 返回统一的错误信息给前端
        return ResponseEntity.status(500).body("An internal error occurred");
    }
    
    // 可以定义多个方法来处理不同类型的异常
    @ExceptionHandler(NullPointerException.class)
    public ResponseEntity<String> handleNPE(NullPointerException ex) {
        return ResponseEntity.status(400).body("Request data is invalid");
    }
}
```

### **21. Spring常用注解**
- **声明Bean**：`@Component`, `@Service`, `@Controller`, `@Repository`, `@Configuration`
- **依赖注入**：`@Autowired`, `@Resource`, `@Value`
- **配置**：`@Configuration`, `@Bean`, `@PropertySource`
- **Web**：`@RequestMapping`, `@GetMapping`, `@PostMapping`, `@RequestBody`, `@ResponseBody`, `@RestController`
- **事务**：`@Transactional`

### **22. 软技能问题（23, 24）**
- **23. 实习体验不好的事**：要客观、积极。可以说一些无伤大雅且已改进的问题，如“初期对项目代码库不熟悉，沟通成本稍高，但通过主动请教和阅读文档很快适应了。”
- **24. 与Leader意见分歧**：体现沟通能力和职业素养。
    1.  **首先反思**：确保自己完全理解了任务背景和Leader的意图。
    2.  **数据支撑**：如果有不同看法，用数据、代码或文档作为依据，私下与Leader温和地沟通。
    3.  **尊重决策**：如果Leader坚持原方案，应尊重其最终决定并严格执行，同时在实施中密切关注潜在风险。

### **25. 数据处理经历**
结合实习或项目经验回答。例如：
- **数据清洗**：使用Python Pandas处理过CSV文件，去重、填充缺失值。
- **数据迁移**：写过SQL脚本将数据从旧表结构迁移到新表。
- **数据分析**：使用SQL进行数据聚合分析，为产品决策提供支持。

---

这份面经质量很高，说明百度面试非常注重基础知识的深度和实际应用能力。好好消化这些知识点，祝你二面顺利！

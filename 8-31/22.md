拼多多秋招一面
面试体验不错，虽然说全是八股，但是面试官尊重人，面试态度很好，很乐意进行交流和引导！
1. 自我介绍
2. 实习亮点
3. Java线程池类型，应用场景
4. 线程池怎么进行线程回收的
5. 为什么要用线程池
6. 说说RPC是什么
7. 设计RPC框架有哪些要点
8. 常用的序列化方式
9. 为什么要进行序列化
10. 写题：二叉树后序遍历（非递归）
11. List<Integer> list = new ArrayList<>()发生了哪些内存分配
12. 操作系统是怎么进行递归的
13. 为什么要有多态
14. 多态父类表现出子类的行为，运行时是如何实现的呢
15. Java泛型是怎么实现的
16. Java为什么要用泛型擦除，为什么不像c++一样
17. `sout( "Hello World!”)` 运行过程。字符串是怎么打印到屏幕上的
18. 为什么要有内核态
19. 从操作系统层面分析`java -jar xxx.jar` 是怎么运行的，在操作系统层面的可执行文件是什么
20. Java和JVM的关系
21. Java和Python有什么区别（答了JIT）
22. 算法：找到一个具有最大和的连续子数组
23. 介绍一下AOP
24. 怎么指定AOP生效的地方
25. Java中注解是怎么生效的
26. 谁去扫描注解的
27. 介绍一下IOC
28. 介绍一下MQ
29. MQ有什么特性
30. 算法：计算逆序对的个数

作者：疲倦的牛马还在上班
链接：https://www.nowcoder.com/
来源：牛客网

很高兴能为你总结拼多多秋招一面的面试题解答。这场面试确实覆盖了非常广泛的 Java 和计算机基础八股文，但正如你所说，遇到一位尊重人、乐于引导的面试官是非常棒的体验。下面我将为你提供这些问题的详细解答，希望能帮助你在后续的面试中更好地展现自己的实力。

---

### 1. 自我介绍
（略，根据个人情况准备，突出技术栈、项目经验和实习亮点）

### 2. 实习亮点
（略，结合个人实习经历，讲述解决的具体问题、带来的价值和技术成长）

### 3. Java线程池类型，应用场景
Java通过`Executors`工具类提供几种常用线程池：
- **FixedThreadPool**：固定大小线程池，适用于负载较重的服务器，控制线程最大并发数。
- **CachedThreadPool**：可缓存线程池，适用于执行很多短期异步任务，线程空闲60秒后回收。
- **SingleThreadExecutor**：单线程线程池，保证任务顺序执行，适用于需要顺序执行的任务。
- **ScheduledThreadPool**：定时线程池，支持定时及周期性任务执行。

### 4. 线程池怎么进行线程回收的
线程池通过`ThreadPoolExecutor`的`getTask()`方法实现线程回收。核心线程默认不会回收（除非设置`allowCoreThreadTimeOut`为true），非核心线程在空闲时间超过`keepAliveTime`后，在获取任务时返回null，线程退出run方法，线程被回收。

### 5. 为什么要用线程池
- **降低资源消耗**：复用已创建的线程，减少线程创建和销毁的开销。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程可管理性**：统一分配、调优和监控线程。

### 6. 说说RPC是什么
RPC（Remote Procedure Call）是一种计算机通信协议，允许程序调用另一个地址空间（通常是远程机器）的过程或函数，就像调用本地方法一样，隐藏了底层网络细节。

### 7. 设计RPC框架有哪些要点
- **服务注册与发现**：如使用ZooKeeper、Nacos等。
- **网络传输**：如基于Netty实现高性能网络通信。
- **序列化协议**：如Protobuf、Thrift、JSON等。
- **负载均衡**：如随机、轮询、一致性哈希等策略。
- **容错机制**：如重试、熔断、降级等。
- **代理与动态代理**：客户端通过代理调用远程服务。

### 8. 常用的序列化方式
- JSON：文本格式，可读性好，但体积大。
- XML：类似JSON，但更冗长。
- Protobuf（Google）：二进制，高效，体积小，需定义schema。
- Thrift（Apache）：类似Protobuf，支持多种语言。
- Hessian：二进制，跨语言，适用于RPC。

### 9. 为什么要进行序列化
为了将对象转换为字节流，以便于**存储**（如存入文件或数据库）或**传输**（如网络通信、RPC调用），并在需要时反序列化重建对象。

### 10. 写题：二叉树后序遍历（非递归）
```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;
    Deque<TreeNode> stack = new LinkedList<>();
    TreeNode prev = null;
    while (root != null || !stack.isEmpty()) {
        while (root != null) {
            stack.push(root);
            root = root.left;
        }
        root = stack.pop();
        if (root.right == null || root.right == prev) {
            res.add(root.val);
            prev = root;
            root = null;
        } else {
            stack.push(root);
            root = root.right;
        }
    }
    return res;
}
```

### 11. `List<Integer> list = new ArrayList<>()`发生了哪些内存分配
- 在栈上分配引用变量`list`。
- `new ArrayList<>()`在堆上分配ArrayList对象的内存（包括内部数组`elementData`，初始容量10）。
- 类型擦除后，`Integer`被替换为Object，但运行时由于擦除，内部数组为Object[]。

### 12. 操作系统是怎么进行递归的
递归通过**栈帧（Stack Frame）**实现：
- 每次函数调用，操作系统（或JVM）在调用栈上压入一个栈帧，存储局部变量、返回地址等。
- 递归调用时，每次调用都会创建新的栈帧。
- 返回时，栈帧弹出，恢复到上一层的执行状态。

### 13. 为什么要有多态
- **提高代码灵活性**：同一接口不同实现，易于扩展。
- **解耦**：减少代码冗余，提高可维护性。
- 符合面向对象设计原则（如开闭原则、依赖倒置原则）。

### 14. 多态父类表现出子类的行为，运行时是如何实现的呢
通过JVM的**动态绑定（晚期绑定）**机制：
- 编译时，编译器检查父类方法是否存在（静态绑定）。
- 运行时，JVM根据对象的实际类型（子类）调用相应的方法实现（通过虚方法表vtable机制）。

### 15. Java泛型是怎么实现的
Java泛型通过**类型擦除**实现：
- 编译期检查类型安全，编译后擦除类型信息，替换为Object（或边界类型）。
- 插入强制类型转换（如`(Integer)`）。
- 生成桥接方法保持多态性。

### 16. Java为什么要用泛型擦除，为什么不像c++一样
- **向后兼容**：确保泛型代码能与旧版本Java（非泛型）字节码兼容。
- **避免代码膨胀**：C++模板为每种类型生成新代码，Java擦除后只需一份字节码。
- 简化JVM设计，不需要修改JVM指令集。

### 17. `sout("Hello World!")`运行过程。字符串是怎么打印到屏幕上的
- `System.out`是`PrintStream`对象，默认指向标准输出（控制台）。
- 调用`println(String)`方法，内部调用`String.getBytes()`将字符串转换为字节数组。
- 通过本地方法`writeBytes()`写入到文件描述符`FileDescriptor.out`（标准输出）。
- 操作系统将字节流发送到终端设备（如控制台），由终端显示。

### 18. 为什么要有内核态
- **安全性**：限制用户程序直接访问硬件资源，防止系统被破坏。
- **稳定性**：统一管理硬件资源，避免冲突。
- **抽象**：为应用程序提供统一的系统调用接口，简化开发。

### 19. 从操作系统层面分析`java -jar xxx.jar`是怎么运行的，在操作系统层面的可执行文件是什么
- `java`命令是**可执行文件**（如Linux下`/usr/bin/java`，Windows下`java.exe`）。
- 操作系统加载该可执行文件，创建进程，并加载JVM（如`libjvm.so`）。
- JVM解析jar包，找到Main-Class，加载类字节码，解释执行或JIT编译成本地代码执行。

### 20. Java和JVM的关系
- Java是一种编程语言，遵循Java语言规范。
- JVM（Java虚拟机）是运行Java字节码的虚拟机，负责加载、验证、执行字节码，并管理内存、垃圾回收等。
- Java程序编译成字节码（.class文件），在JVM上运行，实现“一次编写，到处运行”。

### 21. Java和Python有什么区别（答了JIT）
- **编译vs解释**：Java编译为字节码，在JVM运行（JIT编译）；Python直接解释执行（也有PyPy等JIT）。
- **性能**：Java通常更快（JIT优化）；Python更慢但开发效率高。
- **类型**：Java静态类型；Python动态类型。
- 应用场景：Java适合大型系统；Python适合脚本、AI、数据分析。

### 22. 算法：找到一个具有最大和的连续子数组
（最大子数组和，Kadane算法）
```java
public int maxSubArray(int[] nums) {
    int max = nums[0], cur = nums[0];
    for (int i = 1; i < nums.length; i++) {
        cur = Math.max(nums[i], cur + nums[i]);
        max = Math.max(max, cur);
    }
    return max;
}
```

### 23. 介绍一下AOP
AOP（面向切面编程）是一种编程范式，将横切关注点（如日志、事务、安全）从业务逻辑中分离，通过**切面**模块化，减少代码冗余，提高可维护性。

### 24. 怎么指定AOP生效的地方
通过**切点（Pointcut）表达式**指定，如Spring AOP中：
- `execution()`：匹配方法执行。
- `@annotation()`：匹配带有特定注解的方法。
- `within()`：匹配特定类型内的方法。

### 25. Java中注解是怎么生效的
- 注解本身只是元数据，需通过**反射**或**编译时处理**（APT）或**字节码操作**（如ASM）来读取并执行相应逻辑。
- Spring等框架扫描注解，通过反射获取注解信息，生成代理或增强处理。

### 26. 谁去扫描注解的
- **编译器**：如APT（Annotation Processing Tool）在编译时处理。
- **框架容器**：如Spring容器启动时扫描类路径，通过反射读取注解，注册Bean或应用AOP。
- 第三方库：如Lombok通过AST操作在编译时修改字节码。

### 27. 介绍一下IOC
IOC（控制反转）是一种设计原则，将对象的创建、依赖注入交给容器（如Spring）管理，而非在代码中硬编码。实现**解耦**，提高可测试性和可维护性。

### 28. 介绍一下MQ
MQ（消息队列）是分布式系统中用于**异步通信**的中间件，解耦生产者和消费者，支持削峰填谷、流量控制等。

### 29. MQ有什么特性
- **解耦**：生产者和消费者独立演化。
- **异步**：提高系统响应速度。
- **削峰**：缓冲突发流量，避免系统崩溃。
- 可靠性：支持消息持久化、重试、死信队列等。

### 30. 算法：计算逆序对的个数
（归并排序过程中计数）
```java
public int reversePairs(int[] nums) {
    return mergeSort(nums, 0, nums.length - 1);
}
private int mergeSort(int[] nums, int l, int r) {
    if (l >= r) return 0;
    int mid = l + (r - l) / 2;
    int count = mergeSort(nums, l, mid) + mergeSort(nums, mid + 1, r);
    int[] temp = new int[r - l + 1];
    int i = l, j = mid + 1, k = 0;
    while (i <= mid && j <= r) {
        if (nums[i] <= nums[j]) temp[k++] = nums[i++];
        else {
            temp[k++] = nums[j++];
            count += mid - i + 1; // 关键：左边剩余元素均与nums[j]构成逆序
        }
    }
    while (i <= mid) temp[k++] = nums[i++];
    while (j <= r) temp[k++] = nums[j++];
    System.arraycopy(temp, 0, nums, l, temp.length);
    return count;
}
```

---

### 总结建议：
- 这场面试覆盖了**Java基础、并发、JVM、操作系统、算法、框架**等，非常全面。
- 你提到面试官尊重人且乐于引导，这很好！后续面试继续保持自信，清晰表达。
- 对于算法题，不仅要写出来，最好能分析时间/空间复杂度。
- 如果某些问题没答好，记得事后复习巩固。

祝你面试顺利，拿到心仪的Offer！如果有更多问题，欢迎继续交流。

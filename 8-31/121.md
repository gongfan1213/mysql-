非常棒的分享！这是一份非常典型且高质量的中高级Java研发面试题清单。下面我将对这些题目进行详细的解答和梳理，帮助你巩固知识点。

---

### **1. 线程池的原理、提交流程、拒绝策略**

**原理**：线程池是一种池化技术，预先创建若干线程，避免频繁创建和销毁线程的开销。核心参数包括：
- `corePoolSize`：核心线程数。
- `maximumPoolSize`：最大线程数。
- `workQueue`：任务队列。
- `RejectedExecutionHandler`：拒绝策略。

**提交流程 (`execute(Runnable command)`)**：
1.  如果当前运行的线程数 < `corePoolSize`，则创建新线程来执行任务（**立即执行**）。
2.  如果运行的线程数 >= `corePoolSize`，则尝试将任务放入`workQueue`。
3.  如果队列已满，且当前线程数 < `maximumPoolSize`，则创建新的非核心线程来执行任务。
4.  如果队列已满，且当前线程数 >= `maximumPoolSize`，则触发**拒绝策略**。

**拒绝策略**：
- `AbortPolicy`（默认）：抛出`RejectedExecutionException`异常。
- `CallerRunsPolicy`：由调用者线程（如主线程）自己执行该任务。
- `DiscardPolicy`：直接丢弃新任务，不抛异常。
- `DiscardOldestPolicy`：丢弃队列中最老的一个任务，然后尝试提交新任务。

### **2. Redis 缓存击穿、解决方法**

**缓存击穿**：一个**热点key**在某个时刻**过期**，此时有大量并发请求这个key。请求会瞬间穿透缓存，全部打到数据库上，造成数据库压力激增。

**解决方法**：
1.  **永不过期**：对真正的极热点数据，设置逻辑过期时间，而不是物理过期。后台异步更新缓存。
2.  **互斥锁（Mutex Lock）**：当缓存失效时，不立即去查数据库。而是先使用Redis的`SETNX`（set if not exist）命令尝试设置一个互斥锁（如`lock:key`）。只有拿到锁的线程才能去查询数据库并重建缓存，其他线程等待或返回默认值。**（最常用）**
3.  **接口限流与熔断**：在应用层做限流，防止大量请求同时涌入。

### **3. Redis 跳表原理**

跳表（SkipList）是在有序链表的基础上增加多级索引，以空间换时间，实现近似二分查找的效率。
- **结构**：最底层是包含所有元素的有序链表。往上每一层都是下一层的“快速通道”，索引节点稀疏。
- **查找**：从最高层索引开始，向右遍历，如果下一个节点的值大于目标值，则下降一层继续向右遍历。时间复杂度平均O(log n)。
- **在ZSet中的应用**：ZSet在元素数量多或成员字符串较长时，使用**跳表+字典**。
    - **跳表**：按分值排序，支持范围操作（如`ZRANGE`）。
    - **字典**：以成员为key，分值为value，支持O(1)复杂度的分值查找（如`ZSCORE`）。

### **4. Equals 方法重写，为什么重写 Equals 还要重写 HashCode 方法？**

- **重写`equals`**：是为了根据业务逻辑（如对象的ID相等）来判断两个对象在**内容上**是否“相等”，而不是比较内存地址。
- **必须重写`hashCode`的原因**：是为了维护`hashCode`方法的通用约定，即**如果两个对象根据`equals`方法相等，那么它们的`hashCode`也必须相等**。
- **后果**：如果只重写`equals`而不重写`hashCode`，当把这个对象放入`HashSet`、`HashMap`等基于哈希的集合时，会导致严重问题。因为集合先通过`hashCode`定位桶，再通过`equals`比较。如果两个相等的对象`hashCode`不同，它们可能会被放入不同的桶中，导致集合中出现重复元素，破坏了集合的唯一性。

### **5. Java 包装类缓存机制**

Java对部分包装类提供了对象缓存，用于提升性能和节省内存。
- **范围**：
    - `Byte`, `Short`, `Integer`, `Long`：缓存 **-128 到 127** 之间的值。
    - `Character`：缓存 **0 到 127**（ASCII码）之间的值。
    - `Boolean`：缓存`TRUE`和`FALSE`。
- **原理**：使用`valueOf`方法（如`Integer.valueOf(int i)`）时，会优先从缓存中返回对象，而不是直接`new`一个新对象。而直接`new`或使用自动拆装箱（本质也是调用`valueOf`）会受此机制影响。
- **示例**：`Integer a = 100; Integer b = 100;` 则 `a == b` 为 `true`（因为取自缓存）。`Integer c = 200; Integer d = 200;` 则 `c == d` 为 `false`（因为200超出缓存范围，是new的两个对象）。

### **6. 前序遍历 + 后序遍历构造二叉树**

**结论**：**无法唯一确定**一棵二叉树。
- **原因**：前序（根左右）和后序（左右根）都无法明确划分出左右子树的边界。只知道根节点，但无法确定哪些节点属于左子树，哪些属于右子树。
- **对比**：**前序+中序** 或 **后序+中序** 可以唯一确定一棵二叉树，因为中序（左根右）可以明确区分左右子树。

### **7. 单例模式的实现、volatile、synchronized**

**1. 饿汉式（线程安全）**：
```java
public class Singleton {
    private static final Singleton INSTANCE = new Singleton();
    private Singleton() {}
    public static Singleton getInstance() { return INSTANCE; }
}
```
**2. 懒汉式（线程不安全）**：需要加`synchronized`，但效率低。
**3. 双重检查锁（DCL，推荐）**：
```java
public class Singleton {
    private static volatile Singleton instance; // 必须volatile
    private Singleton() {}
    public static Singleton getInstance() {
        if (instance == null) { // 第一次检查
            synchronized (Singleton.class) {
                if (instance == null) { // 第二次检查
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```
- **`synchronized`作用**：保证同一时刻只有一个线程能执行初始化代码块。
- **`volatile`作用**：防止指令重排序。`instance = new Singleton();`这行代码不是原子操作，可能发生重排序导致其他线程拿到一个未初始化完全的对象。`volatile`通过内存屏障禁止这种重排序。

### **8. 计算组合算法（C(n, k)）**

**题目**：给定两个整数 n 和 k，返回组合数 C(n, k) 的值。
**方法：动态规划**（避免递归重复计算）
```java
public int combine(int n, int k) {
    int[][] dp = new int[n + 1][k + 1];
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= Math.min(i, k); j++) {
            if (j == 0 || j == i) {
                dp[i][j] = 1; // C(i, 0) = 1, C(i, i) = 1
            } else {
                // 公式：C(n, k) = C(n-1, k-1) + C(n-1, k)
                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];
            }
        }
    }
    return dp[n][k];
}
```

### **9. MySQL MVCC 机制、undo log 回滚机制**

**MVCC（多版本并发控制）**：
- **目的**：解决读-写冲突，提高并发性能，无需加锁。
- **核心组件**：
    - **隐藏字段**：`DB_TRX_ID`（最近修改事务ID）、`DB_ROLL_PTR`（回滚指针，指向旧版本）。
    - **Read View（一致性读视图）**：事务在执行快照读时产生的读视图，决定了能看到哪个版本的数据。
    - **Undo Log**：存储数据的历史版本，通过回滚指针形成一个版本链。

**Undo Log 回滚机制**：
- **作用1：事务回滚**。当事务需要回滚时，根据Undo Log中的记录，将数据恢复到事务开始前的状态。
- **作用2：实现MVCC**。当某个事务需要读取数据时，如果该数据已被其他事务更新，则通过回滚指针在Undo Log中找到满足其Read View可见性的历史版本进行读取。

### **10. HashMap 底层原理、扩容机制、树化机制**

**底层原理**：数组 + 链表/红黑树。通过key的`hashCode()`计算哈希值，经过扰动函数后得到数组下标。发生哈希冲突时，采用链地址法（拉链法）。

**扩容机制**：
1.  **时机**：当元素数量超过`容量 * 负载因子(默认0.75)`时触发扩容。
2.  **过程**：创建一个新的数组（大小为原2倍），然后遍历旧数组的每个桶，重新计算每个元素在新数组中的位置（`e.hash & (newCap - 1)`）。JDK8做了优化，元素在新数组的位置要么是**原位置**，要么是**原位置+旧容量**。

**树化机制**：
- **时机**：当单个桶中的链表长度**大于8**，并且当前数组的容量**大于等于64**时，该链表会转换为红黑树。
- **目的**：将链表查询的O(n)时间复杂度优化为红黑树的O(log n)，防止哈希碰撞攻击。
- **退化**：当扩容后或删除元素时，如果树节点数**小于等于6**，红黑树会退化为链表。

### **11. HashMap 的线程安全问题、ConcurrentHashMap、HashTable**

**HashMap的线程安全问题**：
- **多线程扩容导致死循环**（JDK7之前）：链表头插法在并发扩容时可能形成环形链表，导致`get`操作无限循环。
- **数据覆盖**（JDK7/8都存在）：多线程同时执行`put`操作，可能计算出的索引位置相同，导致后一个线程的`put`覆盖了前一个线程的`put`。

**HashTable**：
- 线程安全，但效率低下。通过在方法上添加`synchronized`关键字实现，锁住了整个对象。

**ConcurrentHashMap（JDK8）**：
- 采用更细粒度的锁机制。
- **结构**：Node数组 + 链表/红黑树，与HashMap类似。
- **锁机制**：使用**synchronized**只锁住当前桶（链表头节点/树根节点），而不是整个表。同时配合CAS（Compare-And-Swap）无锁算法进行初始化、节点插入等操作，大大提高了并发性能。

---

这份面经覆盖了Java后端核心知识点的方方面面，掌握这些内容对于应对PDD这类大厂的面试非常有帮助。祝你面试顺利！
